/*
 * Copyright (C) 1997-2009 by Objective Systems, Inc.
 *
 * This software is furnished under an open source license and may be
 * used and copied only in accordance with the terms of this license.
 * The text of the license may generally be found in the root
 * directory of this installation in the COPYING file.  It
 * can also be viewed online at the following URL:
 *
 *   http://www.obj-sys.com/open/license.html
 *
 * Any redistributions of this file including modified versions must
 * maintain this copyright notice.
 *
 *****************************************************************************/
/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.2.B, Date: 06-Apr-2009.
 */
#include "MULTIMEDIA-SYSTEM-CONTROL.h"
#include "eventHandler.h"
#include "ooCommon.h"

EXTERN int asn1PD_H245NonStandardIdentifier_h221NonStandard (OOCTXT* pctxt, H245NonStandardIdentifier_h221NonStandard* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode t35CountryCode */
   invokeStartElement (pctxt, "t35CountryCode", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->t35CountryCode, 0, 255);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->t35CountryCode);
   invokeEndElement (pctxt, "t35CountryCode", -1);

   /* decode t35Extension */
   invokeStartElement (pctxt, "t35Extension", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->t35Extension, 0, 255);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->t35Extension);
   invokeEndElement (pctxt, "t35Extension", -1);

   /* decode manufacturerCode */
   invokeStartElement (pctxt, "manufacturerCode", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->manufacturerCode, 0, 65535);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->manufacturerCode);
   invokeEndElement (pctxt, "manufacturerCode", -1);

   return (stat);
}

EXTERN int asn1PD_H245NonStandardIdentifier (OOCTXT* pctxt, H245NonStandardIdentifier* pvalue)
{
   int stat = 0;
   OOUINT32 ui;

   stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
   if (stat != 0) return stat;
   else pvalue->t = ui + 1;

   switch (ui) {
      /* object */
      case 0:
         invokeStartElement (pctxt, "object", -1);

         pvalue->u.object = memAllocTypeZ (pctxt, ASN1OBJID);

         stat = decodeObjectIdentifier (pctxt, pvalue->u.object);
         if (stat != 0) return stat;

         invokeOidValue (pctxt, pvalue->u.object->numids, pvalue->u.object->subid);
         invokeEndElement (pctxt, "object", -1);

         break;

      /* h221NonStandard */
      case 1:
         invokeStartElement (pctxt, "h221NonStandard", -1);

         pvalue->u.h221NonStandard = memAllocTypeZ (pctxt,
            H245NonStandardIdentifier_h221NonStandard);

         stat = asn1PD_H245NonStandardIdentifier_h221NonStandard (pctxt, pvalue->u.h221NonStandard);
         if (stat != 0) return stat;

         invokeEndElement (pctxt, "h221NonStandard", -1);

         break;

      default:
         return ASN_E_INVOPT;
   }

   return (stat);
}

EXTERN int asn1PD_H245NonStandardParameter (OOCTXT* pctxt, H245NonStandardParameter* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode nonStandardIdentifier */
   invokeStartElement (pctxt, "nonStandardIdentifier", -1);

   stat = asn1PD_H245NonStandardIdentifier (pctxt, &pvalue->nonStandardIdentifier);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "nonStandardIdentifier", -1);

   /* decode data */
   invokeStartElement (pctxt, "data", -1);

   stat = decodeDynOctetString (pctxt, (ASN1DynOctStr*)&pvalue->data);
   if (stat != 0) return stat;

   invokeOctStrValue (pctxt, pvalue->data.numocts, pvalue->data.data);
   invokeEndElement (pctxt, "data", -1);

   return (stat);
}

EXTERN int asn1PD_H245V42bis (OOCTXT* pctxt, H245V42bis* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode numberOfCodewords */
   invokeStartElement (pctxt, "numberOfCodewords", -1);

   stat = decodeConsUnsigned (pctxt, &pvalue->numberOfCodewords, 1, 65536);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->numberOfCodewords);
   invokeEndElement (pctxt, "numberOfCodewords", -1);

   /* decode maximumStringLength */
   invokeStartElement (pctxt, "maximumStringLength", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->maximumStringLength, 1, 256);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->maximumStringLength);
   invokeEndElement (pctxt, "maximumStringLength", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245CompressionType (OOCTXT* pctxt, H245CompressionType* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 0);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* v42bis */
         case 0:
            invokeStartElement (pctxt, "v42bis", -1);

            pvalue->u.v42bis = memAllocTypeZ (pctxt, H245V42bis);

            stat = asn1PD_H245V42bis (pctxt, pvalue->u.v42bis);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "v42bis", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 2;

      if (pvalue->t < 2) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245DataProtocolCapability_v76wCompression (OOCTXT* pctxt, H245DataProtocolCapability_v76wCompression* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* transmitCompression */
         case 0:
            invokeStartElement (pctxt, "transmitCompression", -1);

            pvalue->u.transmitCompression = memAllocTypeZ (pctxt,
               H245CompressionType);

            stat = asn1PD_H245CompressionType (pctxt, pvalue->u.transmitCompression);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "transmitCompression", -1);

            break;

         /* receiveCompression */
         case 1:
            invokeStartElement (pctxt, "receiveCompression", -1);

            pvalue->u.receiveCompression = memAllocTypeZ (pctxt,
               H245CompressionType);

            stat = asn1PD_H245CompressionType (pctxt, pvalue->u.receiveCompression);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "receiveCompression", -1);

            break;

         /* transmitAndReceiveCompression */
         case 2:
            invokeStartElement (pctxt, "transmitAndReceiveCompression", -1);

            pvalue->u.transmitAndReceiveCompression = memAllocTypeZ (pctxt,
               H245CompressionType);

            stat = asn1PD_H245CompressionType (pctxt, pvalue->u.transmitAndReceiveCompression);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "transmitAndReceiveCompression", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 4;

      if (pvalue->t < 4) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245DataProtocolCapability (OOCTXT* pctxt, H245DataProtocolCapability* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 6);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            invokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = memAllocTypeZ (pctxt,
               H245NonStandardParameter);

            stat = asn1PD_H245NonStandardParameter (pctxt, pvalue->u.nonStandard);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* v14buffered */
         case 1:
            invokeStartElement (pctxt, "v14buffered", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "v14buffered", -1);

            break;

         /* v42lapm */
         case 2:
            invokeStartElement (pctxt, "v42lapm", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "v42lapm", -1);

            break;

         /* hdlcFrameTunnelling */
         case 3:
            invokeStartElement (pctxt, "hdlcFrameTunnelling", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "hdlcFrameTunnelling", -1);

            break;

         /* h310SeparateVCStack */
         case 4:
            invokeStartElement (pctxt, "h310SeparateVCStack", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "h310SeparateVCStack", -1);

            break;

         /* h310SingleVCStack */
         case 5:
            invokeStartElement (pctxt, "h310SingleVCStack", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "h310SingleVCStack", -1);

            break;

         /* transparent */
         case 6:
            invokeStartElement (pctxt, "transparent", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "transparent", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 8;

      if (pvalue->t < 8) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt,
         (ASN1OCTET*)openType.data, openType.numocts);

      switch (pvalue->t) {
         /* segmentationAndReassembly */
         case 8:
            invokeStartElement (pctxt, "segmentationAndReassembly", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "segmentationAndReassembly", -1);

            break;

         /* hdlcFrameTunnelingwSAR */
         case 9:
            invokeStartElement (pctxt, "hdlcFrameTunnelingwSAR", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "hdlcFrameTunnelingwSAR", -1);

            break;

         /* v120 */
         case 10:
            invokeStartElement (pctxt, "v120", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "v120", -1);

            break;

         /* separateLANStack */
         case 11:
            invokeStartElement (pctxt, "separateLANStack", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "separateLANStack", -1);

            break;

         /* v76wCompression */
         case 12:
            invokeStartElement (pctxt, "v76wCompression", -1);

            pvalue->u.v76wCompression = memAllocTypeZ (pctxt,
               H245DataProtocolCapability_v76wCompression);

            stat = asn1PD_H245DataProtocolCapability_v76wCompression (pctxt, pvalue->u.v76wCompression);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "v76wCompression", -1);

            break;

         /* tcp */
         case 13:
            invokeStartElement (pctxt, "tcp", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "tcp", -1);

            break;

         /* udp */
         case 14:
            invokeStartElement (pctxt, "udp", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "udp", -1);

            break;

         default:;
      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

EXTERN int asn1PD_H245T38FaxRateManagement (OOCTXT* pctxt, H245T38FaxRateManagement* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* localTCF */
         case 0:
            invokeStartElement (pctxt, "localTCF", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "localTCF", -1);

            break;

         /* transferredTCF */
         case 1:
            invokeStartElement (pctxt, "transferredTCF", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "transferredTCF", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245T38FaxUdpOptions_t38FaxUdpEC (OOCTXT* pctxt, H245T38FaxUdpOptions_t38FaxUdpEC* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* t38UDPFEC */
         case 0:
            invokeStartElement (pctxt, "t38UDPFEC", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "t38UDPFEC", -1);

            break;

         /* t38UDPRedundancy */
         case 1:
            invokeStartElement (pctxt, "t38UDPRedundancy", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "t38UDPRedundancy", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245T38FaxUdpOptions (OOCTXT* pctxt, H245T38FaxUdpOptions* pvalue)
{
   int stat = 0;
   OOBOOL optbit = FALSE;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.t38FaxMaxBufferPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.t38FaxMaxDatagramPresent = optbit;

   /* decode root elements */
   /* decode t38FaxMaxBuffer */
   if (pvalue->m.t38FaxMaxBufferPresent) {
      invokeStartElement (pctxt, "t38FaxMaxBuffer", -1);

      stat = decodeUnconsInteger (pctxt, &pvalue->t38FaxMaxBuffer);
      if (stat != 0) return stat;

      invokeIntValue (pctxt, pvalue->t38FaxMaxBuffer);
      invokeEndElement (pctxt, "t38FaxMaxBuffer", -1);

   }

   /* decode t38FaxMaxDatagram */
   if (pvalue->m.t38FaxMaxDatagramPresent) {
      invokeStartElement (pctxt, "t38FaxMaxDatagram", -1);

      stat = decodeUnconsInteger (pctxt, &pvalue->t38FaxMaxDatagram);
      if (stat != 0) return stat;

      invokeIntValue (pctxt, pvalue->t38FaxMaxDatagram);
      invokeEndElement (pctxt, "t38FaxMaxDatagram", -1);

   }

   /* decode t38FaxUdpEC */
   invokeStartElement (pctxt, "t38FaxUdpEC", -1);

   stat = asn1PD_H245T38FaxUdpOptions_t38FaxUdpEC (pctxt, &pvalue->t38FaxUdpEC);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "t38FaxUdpEC", -1);

   return (stat);
}

EXTERN int asn1PD_H245T38FaxTcpOptions (OOCTXT* pctxt, H245T38FaxTcpOptions* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode t38TCPBidirectionalMode */
   invokeStartElement (pctxt, "t38TCPBidirectionalMode", -1);

   stat = DECODEBIT (pctxt, &pvalue->t38TCPBidirectionalMode);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->t38TCPBidirectionalMode);
   invokeEndElement (pctxt, "t38TCPBidirectionalMode", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245T38FaxProfile (OOCTXT* pctxt, H245T38FaxProfile* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   /* decode root elements */
   /* decode fillBitRemoval */
   invokeStartElement (pctxt, "fillBitRemoval", -1);

   stat = DECODEBIT (pctxt, &pvalue->fillBitRemoval);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->fillBitRemoval);
   invokeEndElement (pctxt, "fillBitRemoval", -1);

   /* decode transcodingJBIG */
   invokeStartElement (pctxt, "transcodingJBIG", -1);

   stat = DECODEBIT (pctxt, &pvalue->transcodingJBIG);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->transcodingJBIG);
   invokeEndElement (pctxt, "transcodingJBIG", -1);

   /* decode transcodingMMR */
   invokeStartElement (pctxt, "transcodingMMR", -1);

   stat = DECODEBIT (pctxt, &pvalue->transcodingMMR);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->transcodingMMR);
   invokeEndElement (pctxt, "transcodingMMR", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return stat;

            if (i < 4) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt,
                  (ASN1OCTET*)openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     if (openType.numocts == 0) break;

                     pvalue->m.versionPresent = 1;

                     invokeStartElement (pctxt, "version", -1);

                     stat = decodeConsUInt8 (pctxt, &pvalue->version, 0, 255);
                     if (stat != 0) return stat;

                     invokeUIntValue (pctxt, pvalue->version);
                     invokeEndElement (pctxt, "version", -1);

                     break;

                  case 1:
                     if (openType.numocts == 0) break;

                     pvalue->m.t38FaxRateManagementPresent = 1;

                     invokeStartElement (pctxt, "t38FaxRateManagement", -1);

                     stat = asn1PD_H245T38FaxRateManagement (pctxt, &pvalue->t38FaxRateManagement);
                     if (stat != 0) return stat;

                     invokeEndElement (pctxt, "t38FaxRateManagement", -1);

                     break;

                  case 2:
                     if (openType.numocts == 0) break;

                     pvalue->m.t38FaxUdpOptionsPresent = 1;

                     invokeStartElement (pctxt, "t38FaxUdpOptions", -1);

                     stat = asn1PD_H245T38FaxUdpOptions (pctxt, &pvalue->t38FaxUdpOptions);
                     if (stat != 0) return stat;

                     invokeEndElement (pctxt, "t38FaxUdpOptions", -1);

                     break;

                  case 3:
                     if (openType.numocts == 0) break;

                     pvalue->m.t38FaxTcpOptionsPresent = 1;

                     invokeStartElement (pctxt, "t38FaxTcpOptions", -1);

                     stat = asn1PD_H245T38FaxTcpOptions (pctxt, &pvalue->t38FaxTcpOptions);
                     if (stat != 0) return stat;

                     invokeEndElement (pctxt, "t38FaxTcpOptions", -1);

                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245QOSMode (OOCTXT* pctxt, H245QOSMode* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* guaranteedQOS */
         case 0:
            invokeStartElement (pctxt, "guaranteedQOS", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "guaranteedQOS", -1);

            break;

         /* controlledLoad */
         case 1:
            invokeStartElement (pctxt, "controlledLoad", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "controlledLoad", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245RSVPParameters (OOCTXT* pctxt, H245RSVPParameters* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;
   OOUINT32 j = 0;
   OOBOOL optbits[6];

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   for (i = 0; i < 6; i++) {
      stat = DECODEBIT (pctxt, &optbits[i]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i = 0; i < 6; i++) {
      switch (i) {
         case 0:
         /* decode qosMode */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "qosMode", -1);

            stat = asn1PD_H245QOSMode (pctxt, &pvalue->qosMode);

            pvalue->m.qosModePresent = 1;
            invokeEndElement (pctxt, "qosMode", -1);

         }
         break;

         case 1:
         /* decode tokenRate */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "tokenRate", -1);

            stat = decodeConsUnsigned (pctxt, &pvalue->tokenRate, 1, OOUINT32_MAX);

            invokeUIntValue (pctxt, pvalue->tokenRate);
            pvalue->m.tokenRatePresent = 1;
            invokeEndElement (pctxt, "tokenRate", -1);

         }
         break;

         case 2:
         /* decode bucketSize */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "bucketSize", -1);

            stat = decodeConsUnsigned (pctxt, &pvalue->bucketSize, 1, OOUINT32_MAX);

            invokeUIntValue (pctxt, pvalue->bucketSize);
            pvalue->m.bucketSizePresent = 1;
            invokeEndElement (pctxt, "bucketSize", -1);

         }
         break;

         case 3:
         /* decode peakRate */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "peakRate", -1);

            stat = decodeConsUnsigned (pctxt, &pvalue->peakRate, 1, OOUINT32_MAX);

            invokeUIntValue (pctxt, pvalue->peakRate);
            pvalue->m.peakRatePresent = 1;
            invokeEndElement (pctxt, "peakRate", -1);

         }
         break;

         case 4:
         /* decode minPoliced */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "minPoliced", -1);

            stat = decodeConsUnsigned (pctxt, &pvalue->minPoliced, 1, OOUINT32_MAX);

            invokeUIntValue (pctxt, pvalue->minPoliced);
            pvalue->m.minPolicedPresent = 1;
            invokeEndElement (pctxt, "minPoliced", -1);

         }
         break;

         case 5:
         /* decode maxPktSize */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "maxPktSize", -1);

            stat = decodeConsUnsigned (pctxt, &pvalue->maxPktSize, 1, OOUINT32_MAX);

            invokeUIntValue (pctxt, pvalue->maxPktSize);
            pvalue->m.maxPktSizePresent = 1;
            invokeEndElement (pctxt, "maxPktSize", -1);

         }
         break;

         default: j++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245ATMParameters (OOCTXT* pctxt, H245ATMParameters* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode maxNTUSize */
   invokeStartElement (pctxt, "maxNTUSize", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->maxNTUSize, 0, 65535);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->maxNTUSize);
   invokeEndElement (pctxt, "maxNTUSize", -1);

   /* decode atmUBR */
   invokeStartElement (pctxt, "atmUBR", -1);

   stat = DECODEBIT (pctxt, &pvalue->atmUBR);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->atmUBR);
   invokeEndElement (pctxt, "atmUBR", -1);

   /* decode atmrtVBR */
   invokeStartElement (pctxt, "atmrtVBR", -1);

   stat = DECODEBIT (pctxt, &pvalue->atmrtVBR);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->atmrtVBR);
   invokeEndElement (pctxt, "atmrtVBR", -1);

   /* decode atmnrtVBR */
   invokeStartElement (pctxt, "atmnrtVBR", -1);

   stat = DECODEBIT (pctxt, &pvalue->atmnrtVBR);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->atmnrtVBR);
   invokeEndElement (pctxt, "atmnrtVBR", -1);

   /* decode atmABR */
   invokeStartElement (pctxt, "atmABR", -1);

   stat = DECODEBIT (pctxt, &pvalue->atmABR);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->atmABR);
   invokeEndElement (pctxt, "atmABR", -1);

   /* decode atmCBR */
   invokeStartElement (pctxt, "atmCBR", -1);

   stat = DECODEBIT (pctxt, &pvalue->atmCBR);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->atmCBR);
   invokeEndElement (pctxt, "atmCBR", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245GenericTransportParameters (OOCTXT* pctxt, H245GenericTransportParameters* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;
   OOUINT32 j = 0;
   OOBOOL optbits[5];

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   for (i = 0; i < 5; i++) {
      stat = DECODEBIT (pctxt, &optbits[i]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i = 0; i < 5; i++) {
      switch (i) {
         case 0:
         /* decode nonStandardData */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "nonStandardData", -1);

            stat = asn1PD_H245NonStandardParameter (pctxt, &pvalue->nonStandardData);

            pvalue->m.nonStandardDataPresent = 1;
            invokeEndElement (pctxt, "nonStandardData", -1);

         }
         break;

         case 1:
         /* decode averageRate */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "averageRate", -1);

            stat = decodeConsUnsigned (pctxt, &pvalue->averageRate, 1, OOUINT32_MAX);

            invokeUIntValue (pctxt, pvalue->averageRate);
            pvalue->m.averageRatePresent = 1;
            invokeEndElement (pctxt, "averageRate", -1);

         }
         break;

         case 2:
         /* decode burst */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "burst", -1);

            stat = decodeConsUnsigned (pctxt, &pvalue->burst, 1, OOUINT32_MAX);

            invokeUIntValue (pctxt, pvalue->burst);
            pvalue->m.burstPresent = 1;
            invokeEndElement (pctxt, "burst", -1);

         }
         break;

         case 3:
         /* decode peakRate */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "peakRate", -1);

            stat = decodeConsUnsigned (pctxt, &pvalue->peakRate, 1, OOUINT32_MAX);

            invokeUIntValue (pctxt, pvalue->peakRate);
            pvalue->m.peakRatePresent = 1;
            invokeEndElement (pctxt, "peakRate", -1);

         }
         break;

         case 4:
         /* decode maxPktSize */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "maxPktSize", -1);

            stat = decodeConsUnsigned (pctxt, &pvalue->maxPktSize, 1, OOUINT32_MAX);

            invokeUIntValue (pctxt, pvalue->maxPktSize);
            pvalue->m.maxPktSizePresent = 1;
            invokeEndElement (pctxt, "maxPktSize", -1);

         }
         break;

         default: j++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245ServicePriorityValue (OOCTXT* pctxt, H245ServicePriorityValue* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.nonStandardParameterPresent = optbit;

   /* decode root elements */
   /* decode nonStandardParameter */
   if (pvalue->m.nonStandardParameterPresent) {
      invokeStartElement (pctxt, "nonStandardParameter", -1);

      stat = asn1PD_H245NonStandardParameter (pctxt, &pvalue->nonStandardParameter);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "nonStandardParameter", -1);

   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245ServicePriority (OOCTXT* pctxt, H245ServicePriority* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.nonStandardDataPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.servicePriorityValuePresent = optbit;

   /* decode root elements */
   /* decode nonStandardData */
   if (pvalue->m.nonStandardDataPresent) {
      invokeStartElement (pctxt, "nonStandardData", -1);

      stat = asn1PD_H245NonStandardParameter (pctxt, &pvalue->nonStandardData);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "nonStandardData", -1);

   }

   /* decode servicePrioritySignalled */
   invokeStartElement (pctxt, "servicePrioritySignalled", -1);

   stat = DECODEBIT (pctxt, &pvalue->servicePrioritySignalled);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->servicePrioritySignalled);
   invokeEndElement (pctxt, "servicePrioritySignalled", -1);

   /* decode servicePriorityValue */
   if (pvalue->m.servicePriorityValuePresent) {
      invokeStartElement (pctxt, "servicePriorityValue", -1);

      stat = asn1PD_H245ServicePriorityValue (pctxt, &pvalue->servicePriorityValue);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "servicePriorityValue", -1);

   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245AuthorizationParameters (OOCTXT* pctxt, H245AuthorizationParameters* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.nonStandardDataPresent = optbit;

   /* decode root elements */
   /* decode nonStandardData */
   if (pvalue->m.nonStandardDataPresent) {
      invokeStartElement (pctxt, "nonStandardData", -1);

      stat = asn1PD_H245NonStandardParameter (pctxt, &pvalue->nonStandardData);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "nonStandardData", -1);

   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245QOSType (OOCTXT* pctxt, H245QOSType* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* desired */
         case 0:
            invokeStartElement (pctxt, "desired", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "desired", -1);

            break;

         /* required */
         case 1:
            invokeStartElement (pctxt, "required", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "required", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245QOSClass (OOCTXT* pctxt, H245QOSClass* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 5);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* class0 */
         case 0:
            invokeStartElement (pctxt, "class0", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "class0", -1);

            break;

         /* class1 */
         case 1:
            invokeStartElement (pctxt, "class1", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "class1", -1);

            break;

         /* class2 */
         case 2:
            invokeStartElement (pctxt, "class2", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "class2", -1);

            break;

         /* class3 */
         case 3:
            invokeStartElement (pctxt, "class3", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "class3", -1);

            break;

         /* class4 */
         case 4:
            invokeStartElement (pctxt, "class4", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "class4", -1);

            break;

         /* class5 */
         case 5:
            invokeStartElement (pctxt, "class5", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "class5", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 7;

      if (pvalue->t < 7) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245QOSDescriptor (OOCTXT* pctxt, H245QOSDescriptor* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.nonStandardDataPresent = optbit;

   /* decode root elements */
   /* decode nonStandardData */
   if (pvalue->m.nonStandardDataPresent) {
      invokeStartElement (pctxt, "nonStandardData", -1);

      stat = asn1PD_H245NonStandardParameter (pctxt, &pvalue->nonStandardData);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "nonStandardData", -1);

   }

   /* decode qosType */
   invokeStartElement (pctxt, "qosType", -1);

   stat = asn1PD_H245QOSType (pctxt, &pvalue->qosType);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "qosType", -1);

   /* decode qosClass */
   invokeStartElement (pctxt, "qosClass", -1);

   stat = asn1PD_H245QOSClass (pctxt, &pvalue->qosClass);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "qosClass", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245QOSCapability (OOCTXT* pctxt, H245QOSCapability* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;
   OOUINT32 j = 0;
   OOBOOL optbits[3];

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   for (i = 0; i < 3; i++) {
      stat = DECODEBIT (pctxt, &optbits[i]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i = 0; i < 3; i++) {
      switch (i) {
         case 0:
         /* decode nonStandardData */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "nonStandardData", -1);

            stat = asn1PD_H245NonStandardParameter (pctxt, &pvalue->nonStandardData);

            pvalue->m.nonStandardDataPresent = 1;
            invokeEndElement (pctxt, "nonStandardData", -1);

         }
         break;

         case 1:
         /* decode rsvpParameters */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "rsvpParameters", -1);

            stat = asn1PD_H245RSVPParameters (pctxt, &pvalue->rsvpParameters);

            pvalue->m.rsvpParametersPresent = 1;
            invokeEndElement (pctxt, "rsvpParameters", -1);

         }
         break;

         case 2:
         /* decode atmParameters */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "atmParameters", -1);

            stat = asn1PD_H245ATMParameters (pctxt, &pvalue->atmParameters);

            pvalue->m.atmParametersPresent = 1;
            invokeEndElement (pctxt, "atmParameters", -1);

         }
         break;

         default: j++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return stat;

            if (i < 6) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt,
                  (ASN1OCTET*)openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     if (openType.numocts == 0) break;

                     pvalue->m.localQoSPresent = 1;

                     invokeStartElement (pctxt, "localQoS", -1);

                     stat = DECODEBIT (pctxt, &pvalue->localQoS);
                     if (stat != 0) return stat;

                     invokeBoolValue (pctxt, pvalue->localQoS);
                     invokeEndElement (pctxt, "localQoS", -1);

                     break;

                  case 1:
                     if (openType.numocts == 0) break;

                     pvalue->m.genericTransportParametersPresent = 1;

                     invokeStartElement (pctxt, "genericTransportParameters", -1);

                     stat = asn1PD_H245GenericTransportParameters (pctxt, &pvalue->genericTransportParameters);
                     if (stat != 0) return stat;

                     invokeEndElement (pctxt, "genericTransportParameters", -1);

                     break;

                  case 2:
                     if (openType.numocts == 0) break;

                     pvalue->m.servicePriorityPresent = 1;

                     invokeStartElement (pctxt, "servicePriority", -1);

                     stat = asn1PD_H245ServicePriority (pctxt, &pvalue->servicePriority);
                     if (stat != 0) return stat;

                     invokeEndElement (pctxt, "servicePriority", -1);

                     break;

                  case 3:
                     if (openType.numocts == 0) break;

                     pvalue->m.authorizationParameterPresent = 1;

                     invokeStartElement (pctxt, "authorizationParameter", -1);

                     stat = asn1PD_H245AuthorizationParameters (pctxt, &pvalue->authorizationParameter);
                     if (stat != 0) return stat;

                     invokeEndElement (pctxt, "authorizationParameter", -1);

                     break;

                  case 4:
                     if (openType.numocts == 0) break;

                     pvalue->m.qosDescriptorPresent = 1;

                     invokeStartElement (pctxt, "qosDescriptor", -1);

                     stat = asn1PD_H245QOSDescriptor (pctxt, &pvalue->qosDescriptor);
                     if (stat != 0) return stat;

                     invokeEndElement (pctxt, "qosDescriptor", -1);

                     break;

                  case 5:
                     if (openType.numocts == 0) break;

                     pvalue->m.dscpValuePresent = 1;

                     invokeStartElement (pctxt, "dscpValue", -1);

                     stat = decodeConsUInt8 (pctxt, &pvalue->dscpValue, 0, 63);
                     if (stat != 0) return stat;

                     invokeUIntValue (pctxt, pvalue->dscpValue);
                     invokeEndElement (pctxt, "dscpValue", -1);

                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245SequenceNumber (OOCTXT* pctxt, H245SequenceNumber* pvalue)
{
   int stat = 0;

   stat = decodeConsUInt8 (pctxt, pvalue, 0, 255);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, *pvalue);

   return (stat);
}

EXTERN int asn1PD_H245CapabilityIdentifier_uuid (OOCTXT* pctxt, H245CapabilityIdentifier_uuid* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 16, 16, 0 };
   int stat = 0;

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return stat;

   invokeOctStrValue (pctxt, pvalue->numocts, pvalue->data);

   return (stat);
}

EXTERN int asn1PD_H245CapabilityIdentifier (OOCTXT* pctxt, H245CapabilityIdentifier* pvalue)
{
   static Asn1SizeCnst domainBased_lsize1 = { 0, 1, 64, 0 };
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 3);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* standard */
         case 0:
            invokeStartElement (pctxt, "standard", -1);

            pvalue->u.standard = memAllocTypeZ (pctxt, ASN1OBJID);

            stat = decodeObjectIdentifier (pctxt, pvalue->u.standard);
            if (stat != 0) return stat;

            invokeOidValue (pctxt, pvalue->u.standard->numids, pvalue->u.standard->subid);
            invokeEndElement (pctxt, "standard", -1);

            break;

         /* h221NonStandard */
         case 1:
            invokeStartElement (pctxt, "h221NonStandard", -1);

            pvalue->u.h221NonStandard = memAllocTypeZ (pctxt,
               H245NonStandardParameter);

            stat = asn1PD_H245NonStandardParameter (pctxt, pvalue->u.h221NonStandard);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "h221NonStandard", -1);

            break;

         /* uuid */
         case 2:
            invokeStartElement (pctxt, "uuid", -1);

            pvalue->u.uuid = memAllocTypeZ (pctxt,
               H245CapabilityIdentifier_uuid);

            stat = asn1PD_H245CapabilityIdentifier_uuid (pctxt, pvalue->u.uuid);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "uuid", -1);

            break;

         /* domainBased */
         case 3:
            invokeStartElement (pctxt, "domainBased", -1);

            addSizeConstraint (pctxt, &domainBased_lsize1);

            stat = decodeConstrainedStringEx (pctxt, &pvalue->u.domainBased, 0, 8, 7, 7);
            if (stat != 0) return stat;

            invokeCharStrValue (pctxt, pvalue->u.domainBased);
            invokeEndElement (pctxt, "domainBased", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 5;

      if (pvalue->t < 5) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245ParameterIdentifier_uuid (OOCTXT* pctxt, H245ParameterIdentifier_uuid* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 16, 16, 0 };
   int stat = 0;

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return stat;

   invokeOctStrValue (pctxt, pvalue->numocts, pvalue->data);

   return (stat);
}

EXTERN int asn1PD_H245ParameterIdentifier (OOCTXT* pctxt, H245ParameterIdentifier* pvalue)
{
   static Asn1SizeCnst domainBased_lsize1 = { 0, 1, 64, 0 };
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 3);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* standard */
         case 0:
            invokeStartElement (pctxt, "standard", -1);

            stat = decodeConsUInt8 (pctxt, &pvalue->u.standard, 0, 127);
            if (stat != 0) return stat;

            invokeUIntValue (pctxt, pvalue->u.standard);
            invokeEndElement (pctxt, "standard", -1);

            break;

         /* h221NonStandard */
         case 1:
            invokeStartElement (pctxt, "h221NonStandard", -1);

            pvalue->u.h221NonStandard = memAllocTypeZ (pctxt,
               H245NonStandardParameter);

            stat = asn1PD_H245NonStandardParameter (pctxt, pvalue->u.h221NonStandard);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "h221NonStandard", -1);

            break;

         /* uuid */
         case 2:
            invokeStartElement (pctxt, "uuid", -1);

            pvalue->u.uuid = memAllocTypeZ (pctxt,
               H245ParameterIdentifier_uuid);

            stat = asn1PD_H245ParameterIdentifier_uuid (pctxt, pvalue->u.uuid);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "uuid", -1);

            break;

         /* domainBased */
         case 3:
            invokeStartElement (pctxt, "domainBased", -1);

            addSizeConstraint (pctxt, &domainBased_lsize1);

            stat = decodeConstrainedStringEx (pctxt, &pvalue->u.domainBased, 0, 8, 7, 7);
            if (stat != 0) return stat;

            invokeCharStrValue (pctxt, pvalue->u.domainBased);
            invokeEndElement (pctxt, "domainBased", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 5;

      if (pvalue->t < 5) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245ParameterValue (OOCTXT* pctxt, H245ParameterValue* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 7);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* logical */
         case 0:
            invokeStartElement (pctxt, "logical", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "logical", -1);

            break;

         /* booleanArray */
         case 1:
            invokeStartElement (pctxt, "booleanArray", -1);

            stat = decodeConsUInt8 (pctxt, &pvalue->u.booleanArray, 0, 255);
            if (stat != 0) return stat;

            invokeUIntValue (pctxt, pvalue->u.booleanArray);
            invokeEndElement (pctxt, "booleanArray", -1);

            break;

         /* unsignedMin */
         case 2:
            invokeStartElement (pctxt, "unsignedMin", -1);

            stat = decodeConsUInt16 (pctxt, &pvalue->u.unsignedMin, 0, 65535);
            if (stat != 0) return stat;

            invokeUIntValue (pctxt, pvalue->u.unsignedMin);
            invokeEndElement (pctxt, "unsignedMin", -1);

            break;

         /* unsignedMax */
         case 3:
            invokeStartElement (pctxt, "unsignedMax", -1);

            stat = decodeConsUInt16 (pctxt, &pvalue->u.unsignedMax, 0, 65535);
            if (stat != 0) return stat;

            invokeUIntValue (pctxt, pvalue->u.unsignedMax);
            invokeEndElement (pctxt, "unsignedMax", -1);

            break;

         /* unsigned32Min */
         case 4:
            invokeStartElement (pctxt, "unsigned32Min", -1);

            stat = decodeConsUnsigned (pctxt, &pvalue->u.unsigned32Min, 0, OOUINT32_MAX);
            if (stat != 0) return stat;

            invokeUIntValue (pctxt, pvalue->u.unsigned32Min);
            invokeEndElement (pctxt, "unsigned32Min", -1);

            break;

         /* unsigned32Max */
         case 5:
            invokeStartElement (pctxt, "unsigned32Max", -1);

            stat = decodeConsUnsigned (pctxt, &pvalue->u.unsigned32Max, 0, OOUINT32_MAX);
            if (stat != 0) return stat;

            invokeUIntValue (pctxt, pvalue->u.unsigned32Max);
            invokeEndElement (pctxt, "unsigned32Max", -1);

            break;

         /* octetString */
         case 6:
            invokeStartElement (pctxt, "octetString", -1);

            pvalue->u.octetString = memAllocTypeZ (pctxt, ASN1DynOctStr);

            stat = decodeDynOctetString (pctxt, (ASN1DynOctStr*)pvalue->u.octetString);
            if (stat != 0) return stat;

            invokeOctStrValue (pctxt, pvalue->u.octetString->numocts, pvalue->u.octetString->data);
            invokeEndElement (pctxt, "octetString", -1);

            break;

         /* genericParameter */
         case 7:
            invokeStartElement (pctxt, "genericParameter", -1);

            pvalue->u.genericParameter = memAllocTypeZ (pctxt,
               H245_SeqOfH245GenericParameter);

            stat = asn1PD_H245_SeqOfH245GenericParameter (pctxt, (H245_SeqOfH245GenericParameter*)pvalue->u.genericParameter);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "genericParameter", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 9;

      if (pvalue->t < 9) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245_SeqOfH245ParameterIdentifier (OOCTXT* pctxt, H245_SeqOfH245ParameterIdentifier* pvalue)
{
   int stat = 0;
   H245ParameterIdentifier* pdata;
   DListNode* pnode;
   OOUINT32 count = 0;
   OOUINT32 xx1 = 0;
   int lstat;
   OOUINT32 total = 0;

   dListInit (pvalue);

   for (;;) {
      /* decode length determinant */

      lstat = decodeLength (pctxt, &count);
      if (lstat != 0 && lstat != ASN_OK_FRAG) {
         return lstat;
      }
      else if (count == 0) break;
      total += count;

      /* decode elements */

      for (; xx1 < total; xx1++) {
         invokeStartElement (pctxt, "elem", xx1);

         dListAllocNodeAndData (pctxt, H245ParameterIdentifier, &pnode, &pdata);

         stat = asn1PD_H245ParameterIdentifier (pctxt, pdata);
         if (stat != 0) return stat;

         invokeEndElement (pctxt, "elem", xx1);

         dListAppendNode2 (pvalue, pnode);
      }

      if (lstat == 0) break;
   }

   return (stat);
}

EXTERN int asn1PD_H245GenericParameter (OOCTXT* pctxt, H245GenericParameter* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.supersedesPresent = optbit;

   /* decode root elements */
   /* decode parameterIdentifier */
   invokeStartElement (pctxt, "parameterIdentifier", -1);

   stat = asn1PD_H245ParameterIdentifier (pctxt, &pvalue->parameterIdentifier);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "parameterIdentifier", -1);

   /* decode parameterValue */
   invokeStartElement (pctxt, "parameterValue", -1);

   stat = asn1PD_H245ParameterValue (pctxt, &pvalue->parameterValue);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "parameterValue", -1);

   /* decode supersedes */
   if (pvalue->m.supersedesPresent) {
      invokeStartElement (pctxt, "supersedes", -1);

      stat = asn1PD_H245_SeqOfH245ParameterIdentifier (pctxt, &pvalue->supersedes);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "supersedes", -1);

   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245_SeqOfH245GenericParameter (OOCTXT* pctxt, H245_SeqOfH245GenericParameter* pvalue)
{
   int stat = 0;
   H245GenericParameter* pdata;
   DListNode* pnode;
   OOUINT32 count = 0;
   OOUINT32 xx1 = 0;
   int lstat;
   OOUINT32 total = 0;

   dListInit (pvalue);

   for (;;) {
      /* decode length determinant */

      lstat = decodeLength (pctxt, &count);
      if (lstat != 0 && lstat != ASN_OK_FRAG) {
         return lstat;
      }
      else if (count == 0) break;
      total += count;

      /* decode elements */

      for (; xx1 < total; xx1++) {
         invokeStartElement (pctxt, "elem", xx1);

         dListAllocNodeAndData (pctxt, H245GenericParameter, &pnode, &pdata);

         stat = asn1PD_H245GenericParameter (pctxt, pdata);
         if (stat != 0) return stat;

         invokeEndElement (pctxt, "elem", xx1);

         dListAppendNode2 (pvalue, pnode);
      }

      if (lstat == 0) break;
   }

   return (stat);
}

EXTERN int asn1PD_H245GenericMessage (OOCTXT* pctxt, H245GenericMessage* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.subMessageIdentifierPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.messageContentPresent = optbit;

   /* decode root elements */
   /* decode messageIdentifier */
   invokeStartElement (pctxt, "messageIdentifier", -1);

   stat = asn1PD_H245CapabilityIdentifier (pctxt, &pvalue->messageIdentifier);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "messageIdentifier", -1);

   /* decode subMessageIdentifier */
   if (pvalue->m.subMessageIdentifierPresent) {
      invokeStartElement (pctxt, "subMessageIdentifier", -1);

      stat = decodeConsUInt8 (pctxt, &pvalue->subMessageIdentifier, 0, 127);
      if (stat != 0) return stat;

      invokeUIntValue (pctxt, pvalue->subMessageIdentifier);
      invokeEndElement (pctxt, "subMessageIdentifier", -1);

   }

   /* decode messageContent */
   if (pvalue->m.messageContentPresent) {
      invokeStartElement (pctxt, "messageContent", -1);

      stat = asn1PD_H245_SeqOfH245GenericParameter (pctxt, &pvalue->messageContent);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "messageContent", -1);

   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245GenericInformation (OOCTXT* pctxt, H245GenericInformation* pvalue)
{
   int stat = 0;

   stat = asn1PD_H245GenericMessage (pctxt, pvalue);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PD_H245CapabilityTableEntryNumber (OOCTXT* pctxt, H245CapabilityTableEntryNumber* pvalue)
{
   int stat = 0;

   stat = decodeConsUInt16 (pctxt, pvalue, 1, 65535);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, *pvalue);

   return (stat);
}

EXTERN int asn1PD_H245CapabilityDescriptorNumber (OOCTXT* pctxt, H245CapabilityDescriptorNumber* pvalue)
{
   int stat = 0;

   stat = decodeConsUInt8 (pctxt, pvalue, 0, 255);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, *pvalue);

   return (stat);
}

EXTERN int asn1PD_H245MaxRedundancy (OOCTXT* pctxt, H245MaxRedundancy* pvalue)
{
   int stat = 0;

   stat = decodeSemiConsUnsigned (pctxt, pvalue, 1);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, *pvalue);

   return (stat);
}

EXTERN int asn1PD_H245LogicalChannelNumber (OOCTXT* pctxt, H245LogicalChannelNumber* pvalue)
{
   int stat = 0;

   stat = decodeConsUInt16 (pctxt, pvalue, 1, 65535);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, *pvalue);

   return (stat);
}

EXTERN int asn1PD_H245MultiplexTableEntryNumber (OOCTXT* pctxt, H245MultiplexTableEntryNumber* pvalue)
{
   int stat = 0;

   stat = decodeConsUInt8 (pctxt, pvalue, 1, 15);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, *pvalue);

   return (stat);
}

EXTERN int asn1PD_H245McuNumber (OOCTXT* pctxt, H245McuNumber* pvalue)
{
   int stat = 0;

   stat = decodeConsUInt8 (pctxt, pvalue, 0, 192);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, *pvalue);

   return (stat);
}

EXTERN int asn1PD_H245TerminalNumber (OOCTXT* pctxt, H245TerminalNumber* pvalue)
{
   int stat = 0;

   stat = decodeConsUInt8 (pctxt, pvalue, 0, 192);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, *pvalue);

   return (stat);
}

EXTERN int asn1PD_H245TerminalID (OOCTXT* pctxt, H245TerminalID* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 128, 0 };
   int stat = 0;

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return stat;

   invokeOctStrValue (pctxt, pvalue->numocts, pvalue->data);

   return (stat);
}

EXTERN int asn1PD_H245ConferenceID (OOCTXT* pctxt, H245ConferenceID* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 32, 0 };
   int stat = 0;

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return stat;

   invokeOctStrValue (pctxt, pvalue->numocts, pvalue->data);

   return (stat);
}

EXTERN int asn1PD_H245Password (OOCTXT* pctxt, H245Password* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 32, 0 };
   int stat = 0;

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return stat;

   invokeOctStrValue (pctxt, pvalue->numocts, pvalue->data);

   return (stat);
}

EXTERN int asn1PD_H245MaximumBitRate (OOCTXT* pctxt, H245MaximumBitRate* pvalue)
{
   int stat = 0;

   stat = decodeConsUnsigned (pctxt, pvalue, 0, OOUINT32_MAX);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, *pvalue);

   return (stat);
}

EXTERN int asn1PD_H245IV8 (OOCTXT* pctxt, H245IV8* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 8, 8, 0 };
   int stat = 0;

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return stat;

   invokeOctStrValue (pctxt, pvalue->numocts, pvalue->data);

   return (stat);
}

EXTERN int asn1PD_H245IV16 (OOCTXT* pctxt, H245IV16* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 16, 16, 0 };
   int stat = 0;

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return stat;

   invokeOctStrValue (pctxt, pvalue->numocts, pvalue->data);

   return (stat);
}

EXTERN int asn1PD_H245NetworkAccessParameters_externalReference (OOCTXT* pctxt, H245NetworkAccessParameters_externalReference* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 255, 0 };
   int stat = 0;

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return stat;

   invokeOctStrValue (pctxt, pvalue->numocts, pvalue->data);

   return (stat);
}

EXTERN int asn1PD_H245Q2931Address_address_nsapAddress (OOCTXT* pctxt, H245Q2931Address_address_nsapAddress* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 20, 0 };
   int stat = 0;

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return stat;

   invokeOctStrValue (pctxt, pvalue->numocts, pvalue->data);

   return (stat);
}

EXTERN int asn1PD_H245Q2931Address_subaddress (OOCTXT* pctxt, H245Q2931Address_subaddress* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 20, 0 };
   int stat = 0;

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return stat;

   invokeOctStrValue (pctxt, pvalue->numocts, pvalue->data);

   return (stat);
}

EXTERN int asn1PD_H245UnicastAddress_iPAddress_network (OOCTXT* pctxt, H245UnicastAddress_iPAddress_network* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 4, 4, 0 };
   int stat = 0;

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return stat;

   invokeOctStrValue (pctxt, pvalue->numocts, pvalue->data);

   return (stat);
}

EXTERN int asn1PD_H245UnicastAddress_iPXAddress_node (OOCTXT* pctxt, H245UnicastAddress_iPXAddress_node* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 6, 6, 0 };
   int stat = 0;

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return stat;

   invokeOctStrValue (pctxt, pvalue->numocts, pvalue->data);

   return (stat);
}

EXTERN int asn1PD_H245UnicastAddress_iPXAddress_netnum (OOCTXT* pctxt, H245UnicastAddress_iPXAddress_netnum* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 4, 4, 0 };
   int stat = 0;

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return stat;

   invokeOctStrValue (pctxt, pvalue->numocts, pvalue->data);

   return (stat);
}

EXTERN int asn1PD_H245UnicastAddress_iPXAddress_tsapIdentifier (OOCTXT* pctxt, H245UnicastAddress_iPXAddress_tsapIdentifier* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 2, 2, 0 };
   int stat = 0;

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return stat;

   invokeOctStrValue (pctxt, pvalue->numocts, pvalue->data);

   return (stat);
}

EXTERN int asn1PD_H245UnicastAddress_iP6Address_network (OOCTXT* pctxt, H245UnicastAddress_iP6Address_network* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 16, 16, 0 };
   int stat = 0;

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return stat;

   invokeOctStrValue (pctxt, pvalue->numocts, pvalue->data);

   return (stat);
}

EXTERN int asn1PD_H245UnicastAddress_netBios (OOCTXT* pctxt, H245UnicastAddress_netBios* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 16, 16, 0 };
   int stat = 0;

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return stat;

   invokeOctStrValue (pctxt, pvalue->numocts, pvalue->data);

   return (stat);
}

EXTERN int asn1PD_H245UnicastAddress_iPSourceRouteAddress_network (OOCTXT* pctxt, H245UnicastAddress_iPSourceRouteAddress_network* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 4, 4, 0 };
   int stat = 0;

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return stat;

   invokeOctStrValue (pctxt, pvalue->numocts, pvalue->data);

   return (stat);
}

EXTERN int asn1PD_H245UnicastAddress_iPSourceRouteAddress_route_element (OOCTXT* pctxt, H245UnicastAddress_iPSourceRouteAddress_route_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 4, 4, 0 };
   int stat = 0;

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return stat;

   invokeOctStrValue (pctxt, pvalue->numocts, pvalue->data);

   return (stat);
}

EXTERN int asn1PD_H245UnicastAddress_nsap (OOCTXT* pctxt, H245UnicastAddress_nsap* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 20, 0 };
   int stat = 0;

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return stat;

   invokeOctStrValue (pctxt, pvalue->numocts, pvalue->data);

   return (stat);
}

EXTERN int asn1PD_H245MulticastAddress_iPAddress_network (OOCTXT* pctxt, H245MulticastAddress_iPAddress_network* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 4, 4, 0 };
   int stat = 0;

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return stat;

   invokeOctStrValue (pctxt, pvalue->numocts, pvalue->data);

   return (stat);
}

EXTERN int asn1PD_H245MulticastAddress_iP6Address_network (OOCTXT* pctxt, H245MulticastAddress_iP6Address_network* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 16, 16, 0 };
   int stat = 0;

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return stat;

   invokeOctStrValue (pctxt, pvalue->numocts, pvalue->data);

   return (stat);
}

EXTERN int asn1PD_H245MulticastAddress_nsap (OOCTXT* pctxt, H245MulticastAddress_nsap* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 20, 0 };
   int stat = 0;

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return stat;

   invokeOctStrValue (pctxt, pvalue->numocts, pvalue->data);

   return (stat);
}

EXTERN int asn1PD_H245EscrowData_escrowValue (OOCTXT* pctxt, H245EscrowData_escrowValue* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 65535, 0 };
   int stat = 0;

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeBitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->
      data));
   if (stat != 0) return stat;

   invokeBitStrValue (pctxt, pvalue->numbits, pvalue->data);

   return (stat);
}

EXTERN int asn1PD_H245SubstituteConferenceIDCommand_conferenceIdentifier (OOCTXT* pctxt, H245SubstituteConferenceIDCommand_conferenceIdentifier* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 16, 16, 0 };
   int stat = 0;

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return stat;

   invokeOctStrValue (pctxt, pvalue->numocts, pvalue->data);

   return (stat);
}

EXTERN int asn1PD_H245VendorIdentification_productNumber (OOCTXT* pctxt, H245VendorIdentification_productNumber* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 256, 0 };
   int stat = 0;

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return stat;

   invokeOctStrValue (pctxt, pvalue->numocts, pvalue->data);

   return (stat);
}

EXTERN int asn1PD_H245VendorIdentification_versionNumber (OOCTXT* pctxt, H245VendorIdentification_versionNumber* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 256, 0 };
   int stat = 0;

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return stat;

   invokeOctStrValue (pctxt, pvalue->numocts, pvalue->data);

   return (stat);
}

EXTERN int asn1PD_H245UserInputIndication_signal_encryptedSignalType (OOCTXT* pctxt, H245UserInputIndication_signal_encryptedSignalType* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 1, 0 };
   int stat = 0;

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return stat;

   invokeOctStrValue (pctxt, pvalue->numocts, pvalue->data);

   return (stat);
}

EXTERN int asn1PD_H245NonStandardMessage (OOCTXT* pctxt, H245NonStandardMessage* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode nonStandardData */
   invokeStartElement (pctxt, "nonStandardData", -1);

   stat = asn1PD_H245NonStandardParameter (pctxt, &pvalue->nonStandardData);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "nonStandardData", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245MasterSlaveDetermination (OOCTXT* pctxt, H245MasterSlaveDetermination* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode terminalType */
   invokeStartElement (pctxt, "terminalType", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->terminalType, 0, 255);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->terminalType);
   invokeEndElement (pctxt, "terminalType", -1);

   /* decode statusDeterminationNumber */
   invokeStartElement (pctxt, "statusDeterminationNumber", -1);

   stat = decodeConsUnsigned (pctxt, &pvalue->statusDeterminationNumber, 0, 16777215);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->statusDeterminationNumber);
   invokeEndElement (pctxt, "statusDeterminationNumber", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245VCCapability_aal1 (OOCTXT* pctxt, H245VCCapability_aal1* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode nullClockRecovery */
   invokeStartElement (pctxt, "nullClockRecovery", -1);

   stat = DECODEBIT (pctxt, &pvalue->nullClockRecovery);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->nullClockRecovery);
   invokeEndElement (pctxt, "nullClockRecovery", -1);

   /* decode srtsClockRecovery */
   invokeStartElement (pctxt, "srtsClockRecovery", -1);

   stat = DECODEBIT (pctxt, &pvalue->srtsClockRecovery);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->srtsClockRecovery);
   invokeEndElement (pctxt, "srtsClockRecovery", -1);

   /* decode adaptiveClockRecovery */
   invokeStartElement (pctxt, "adaptiveClockRecovery", -1);

   stat = DECODEBIT (pctxt, &pvalue->adaptiveClockRecovery);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->adaptiveClockRecovery);
   invokeEndElement (pctxt, "adaptiveClockRecovery", -1);

   /* decode nullErrorCorrection */
   invokeStartElement (pctxt, "nullErrorCorrection", -1);

   stat = DECODEBIT (pctxt, &pvalue->nullErrorCorrection);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->nullErrorCorrection);
   invokeEndElement (pctxt, "nullErrorCorrection", -1);

   /* decode longInterleaver */
   invokeStartElement (pctxt, "longInterleaver", -1);

   stat = DECODEBIT (pctxt, &pvalue->longInterleaver);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->longInterleaver);
   invokeEndElement (pctxt, "longInterleaver", -1);

   /* decode shortInterleaver */
   invokeStartElement (pctxt, "shortInterleaver", -1);

   stat = DECODEBIT (pctxt, &pvalue->shortInterleaver);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->shortInterleaver);
   invokeEndElement (pctxt, "shortInterleaver", -1);

   /* decode errorCorrectionOnly */
   invokeStartElement (pctxt, "errorCorrectionOnly", -1);

   stat = DECODEBIT (pctxt, &pvalue->errorCorrectionOnly);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->errorCorrectionOnly);
   invokeEndElement (pctxt, "errorCorrectionOnly", -1);

   /* decode structuredDataTransfer */
   invokeStartElement (pctxt, "structuredDataTransfer", -1);

   stat = DECODEBIT (pctxt, &pvalue->structuredDataTransfer);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->structuredDataTransfer);
   invokeEndElement (pctxt, "structuredDataTransfer", -1);

   /* decode partiallyFilledCells */
   invokeStartElement (pctxt, "partiallyFilledCells", -1);

   stat = DECODEBIT (pctxt, &pvalue->partiallyFilledCells);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->partiallyFilledCells);
   invokeEndElement (pctxt, "partiallyFilledCells", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245VCCapability_aal5 (OOCTXT* pctxt, H245VCCapability_aal5* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode forwardMaximumSDUSize */
   invokeStartElement (pctxt, "forwardMaximumSDUSize", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->forwardMaximumSDUSize, 0, 65535);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->forwardMaximumSDUSize);
   invokeEndElement (pctxt, "forwardMaximumSDUSize", -1);

   /* decode backwardMaximumSDUSize */
   invokeStartElement (pctxt, "backwardMaximumSDUSize", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->backwardMaximumSDUSize, 0, 65535);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->backwardMaximumSDUSize);
   invokeEndElement (pctxt, "backwardMaximumSDUSize", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245VCCapability_availableBitRates_type_rangeOfBitRates (OOCTXT* pctxt, H245VCCapability_availableBitRates_type_rangeOfBitRates* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode lowerBitRate */
   invokeStartElement (pctxt, "lowerBitRate", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->lowerBitRate, 1, 65535);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->lowerBitRate);
   invokeEndElement (pctxt, "lowerBitRate", -1);

   /* decode higherBitRate */
   invokeStartElement (pctxt, "higherBitRate", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->higherBitRate, 1, 65535);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->higherBitRate);
   invokeEndElement (pctxt, "higherBitRate", -1);

   return (stat);
}

EXTERN int asn1PD_H245VCCapability_availableBitRates_type (OOCTXT* pctxt, H245VCCapability_availableBitRates_type* pvalue)
{
   int stat = 0;
   OOUINT32 ui;

   stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
   if (stat != 0) return stat;
   else pvalue->t = ui + 1;

   switch (ui) {
      /* singleBitRate */
      case 0:
         invokeStartElement (pctxt, "singleBitRate", -1);

         stat = decodeConsUInt16 (pctxt, &pvalue->u.singleBitRate, 1, 65535);
         if (stat != 0) return stat;

         invokeUIntValue (pctxt, pvalue->u.singleBitRate);
         invokeEndElement (pctxt, "singleBitRate", -1);

         break;

      /* rangeOfBitRates */
      case 1:
         invokeStartElement (pctxt, "rangeOfBitRates", -1);

         pvalue->u.rangeOfBitRates = memAllocTypeZ (pctxt,
            H245VCCapability_availableBitRates_type_rangeOfBitRates);

         stat = asn1PD_H245VCCapability_availableBitRates_type_rangeOfBitRates (pctxt, pvalue->u.rangeOfBitRates);
         if (stat != 0) return stat;

         invokeEndElement (pctxt, "rangeOfBitRates", -1);

         break;

      default:
         return ASN_E_INVOPT;
   }

   return (stat);
}

EXTERN int asn1PD_H245VCCapability_availableBitRates (OOCTXT* pctxt, H245VCCapability_availableBitRates* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode type */
   invokeStartElement (pctxt, "type", -1);

   stat = asn1PD_H245VCCapability_availableBitRates_type (pctxt, &pvalue->type);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "type", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245Q2931Address_address (OOCTXT* pctxt, H245Q2931Address_address* pvalue)
{
   static Asn1SizeCnst internationalNumber_lsize1 = { 0, 1, 16, 0 };
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* internationalNumber */
         case 0:
            invokeStartElement (pctxt, "internationalNumber", -1);

            addSizeConstraint (pctxt, &internationalNumber_lsize1);

            stat = decodeConstrainedStringEx (pctxt, &pvalue->u.internationalNumber, NUM_CANSET, 4, 4, 4);
            if (stat != 0) return stat;

            invokeCharStrValue (pctxt, pvalue->u.internationalNumber);
            invokeEndElement (pctxt, "internationalNumber", -1);

            break;

         /* nsapAddress */
         case 1:
            invokeStartElement (pctxt, "nsapAddress", -1);

            pvalue->u.nsapAddress = memAllocTypeZ (pctxt,
               H245Q2931Address_address_nsapAddress);

            stat = asn1PD_H245Q2931Address_address_nsapAddress (pctxt, pvalue->u.nsapAddress);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "nsapAddress", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245Q2931Address (OOCTXT* pctxt, H245Q2931Address* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.subaddressPresent = optbit;

   /* decode root elements */
   /* decode address */
   invokeStartElement (pctxt, "address", -1);

   stat = asn1PD_H245Q2931Address_address (pctxt, &pvalue->address);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "address", -1);

   /* decode subaddress */
   if (pvalue->m.subaddressPresent) {
      invokeStartElement (pctxt, "subaddress", -1);

      stat = asn1PD_H245Q2931Address_subaddress (pctxt, &pvalue->subaddress);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "subaddress", -1);

   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245VCCapability_aal1ViaGateway_gatewayAddress (OOCTXT* pctxt, H245VCCapability_aal1ViaGateway_gatewayAddress* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 256, 0 };
   int stat = 0;
   H245Q2931Address* pdata;
   DListNode* pnode;
   OOUINT32 count = 0;
   OOUINT32 xx1 = 0;

   /* decode length determinant */

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeLength (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      invokeStartElement (pctxt, "elem", xx1);

      dListAllocNodeAndData (pctxt, H245Q2931Address, &pnode, &pdata);

      stat = asn1PD_H245Q2931Address (pctxt, pdata);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "elem", xx1);

      dListAppendNode2 (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1PD_H245VCCapability_aal1ViaGateway (OOCTXT* pctxt, H245VCCapability_aal1ViaGateway* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode gatewayAddress */
   invokeStartElement (pctxt, "gatewayAddress", -1);

   stat = asn1PD_H245VCCapability_aal1ViaGateway_gatewayAddress (pctxt, &pvalue->gatewayAddress);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "gatewayAddress", -1);

   /* decode nullClockRecovery */
   invokeStartElement (pctxt, "nullClockRecovery", -1);

   stat = DECODEBIT (pctxt, &pvalue->nullClockRecovery);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->nullClockRecovery);
   invokeEndElement (pctxt, "nullClockRecovery", -1);

   /* decode srtsClockRecovery */
   invokeStartElement (pctxt, "srtsClockRecovery", -1);

   stat = DECODEBIT (pctxt, &pvalue->srtsClockRecovery);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->srtsClockRecovery);
   invokeEndElement (pctxt, "srtsClockRecovery", -1);

   /* decode adaptiveClockRecovery */
   invokeStartElement (pctxt, "adaptiveClockRecovery", -1);

   stat = DECODEBIT (pctxt, &pvalue->adaptiveClockRecovery);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->adaptiveClockRecovery);
   invokeEndElement (pctxt, "adaptiveClockRecovery", -1);

   /* decode nullErrorCorrection */
   invokeStartElement (pctxt, "nullErrorCorrection", -1);

   stat = DECODEBIT (pctxt, &pvalue->nullErrorCorrection);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->nullErrorCorrection);
   invokeEndElement (pctxt, "nullErrorCorrection", -1);

   /* decode longInterleaver */
   invokeStartElement (pctxt, "longInterleaver", -1);

   stat = DECODEBIT (pctxt, &pvalue->longInterleaver);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->longInterleaver);
   invokeEndElement (pctxt, "longInterleaver", -1);

   /* decode shortInterleaver */
   invokeStartElement (pctxt, "shortInterleaver", -1);

   stat = DECODEBIT (pctxt, &pvalue->shortInterleaver);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->shortInterleaver);
   invokeEndElement (pctxt, "shortInterleaver", -1);

   /* decode errorCorrectionOnly */
   invokeStartElement (pctxt, "errorCorrectionOnly", -1);

   stat = DECODEBIT (pctxt, &pvalue->errorCorrectionOnly);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->errorCorrectionOnly);
   invokeEndElement (pctxt, "errorCorrectionOnly", -1);

   /* decode structuredDataTransfer */
   invokeStartElement (pctxt, "structuredDataTransfer", -1);

   stat = DECODEBIT (pctxt, &pvalue->structuredDataTransfer);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->structuredDataTransfer);
   invokeEndElement (pctxt, "structuredDataTransfer", -1);

   /* decode partiallyFilledCells */
   invokeStartElement (pctxt, "partiallyFilledCells", -1);

   stat = DECODEBIT (pctxt, &pvalue->partiallyFilledCells);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->partiallyFilledCells);
   invokeEndElement (pctxt, "partiallyFilledCells", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245VCCapability (OOCTXT* pctxt, H245VCCapability* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.aal1Present = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.aal5Present = optbit;

   /* decode root elements */
   /* decode aal1 */
   if (pvalue->m.aal1Present) {
      invokeStartElement (pctxt, "aal1", -1);

      stat = asn1PD_H245VCCapability_aal1 (pctxt, &pvalue->aal1);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "aal1", -1);

   }

   /* decode aal5 */
   if (pvalue->m.aal5Present) {
      invokeStartElement (pctxt, "aal5", -1);

      stat = asn1PD_H245VCCapability_aal5 (pctxt, &pvalue->aal5);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "aal5", -1);

   }

   /* decode transportStream */
   invokeStartElement (pctxt, "transportStream", -1);

   stat = DECODEBIT (pctxt, &pvalue->transportStream);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->transportStream);
   invokeEndElement (pctxt, "transportStream", -1);

   /* decode programStream */
   invokeStartElement (pctxt, "programStream", -1);

   stat = DECODEBIT (pctxt, &pvalue->programStream);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->programStream);
   invokeEndElement (pctxt, "programStream", -1);

   /* decode availableBitRates */
   invokeStartElement (pctxt, "availableBitRates", -1);

   stat = asn1PD_H245VCCapability_availableBitRates (pctxt, &pvalue->availableBitRates);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "availableBitRates", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return stat;

            if (i < 1) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt,
                  (ASN1OCTET*)openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     if (openType.numocts == 0) break;

                     pvalue->m.aal1ViaGatewayPresent = 1;

                     invokeStartElement (pctxt, "aal1ViaGateway", -1);

                     stat = asn1PD_H245VCCapability_aal1ViaGateway (pctxt, &pvalue->aal1ViaGateway);
                     if (stat != 0) return stat;

                     invokeEndElement (pctxt, "aal1ViaGateway", -1);

                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245_SetOfH245VCCapability (OOCTXT* pctxt, H245_SetOfH245VCCapability* pvalue)
{
   int stat = 0;
   H245VCCapability* pdata;
   DListNode* pnode;
   OOUINT32 count = 0;
   OOUINT32 xx1 = 0;
   int lstat;
   OOUINT32 total = 0;

   dListInit (pvalue);

   for (;;) {
      /* decode length determinant */

      lstat = decodeLength (pctxt, &count);
      if (lstat != 0 && lstat != ASN_OK_FRAG) {
         return lstat;
      }
      else if (count == 0) break;
      total += count;

      /* decode elements */

      for (; xx1 < total; xx1++) {
         invokeStartElement (pctxt, "elem", xx1);

         dListAllocNodeAndData (pctxt, H245VCCapability, &pnode, &pdata);

         stat = asn1PD_H245VCCapability (pctxt, pdata);
         if (stat != 0) return stat;

         invokeEndElement (pctxt, "elem", xx1);

         dListAppendNode2 (pvalue, pnode);
      }

      if (lstat == 0) break;
   }

   return (stat);
}

EXTERN int asn1PD_H245H222Capability (OOCTXT* pctxt, H245H222Capability* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode numberOfVCs */
   invokeStartElement (pctxt, "numberOfVCs", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->numberOfVCs, 1, 256);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->numberOfVCs);
   invokeEndElement (pctxt, "numberOfVCs", -1);

   /* decode vcCapability */
   invokeStartElement (pctxt, "vcCapability", -1);

   stat = asn1PD_H245_SetOfH245VCCapability (pctxt, &pvalue->vcCapability);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "vcCapability", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245H223Capability_h223MultiplexTableCapability_enhanced (OOCTXT* pctxt, H245H223Capability_h223MultiplexTableCapability_enhanced* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode maximumNestingDepth */
   invokeStartElement (pctxt, "maximumNestingDepth", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->maximumNestingDepth, 1, 15);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->maximumNestingDepth);
   invokeEndElement (pctxt, "maximumNestingDepth", -1);

   /* decode maximumElementListSize */
   invokeStartElement (pctxt, "maximumElementListSize", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->maximumElementListSize, 2, 255);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->maximumElementListSize);
   invokeEndElement (pctxt, "maximumElementListSize", -1);

   /* decode maximumSubElementListSize */
   invokeStartElement (pctxt, "maximumSubElementListSize", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->maximumSubElementListSize, 2, 255);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->maximumSubElementListSize);
   invokeEndElement (pctxt, "maximumSubElementListSize", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245H223Capability_h223MultiplexTableCapability (OOCTXT* pctxt, H245H223Capability_h223MultiplexTableCapability* pvalue)
{
   int stat = 0;
   OOUINT32 ui;

   stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
   if (stat != 0) return stat;
   else pvalue->t = ui + 1;

   switch (ui) {
      /* basic */
      case 0:
         invokeStartElement (pctxt, "basic", -1);

         /* NULL */

         invokeNullValue (pctxt);
         invokeEndElement (pctxt, "basic", -1);

         break;

      /* enhanced */
      case 1:
         invokeStartElement (pctxt, "enhanced", -1);

         pvalue->u.enhanced = memAllocTypeZ (pctxt,
            H245H223Capability_h223MultiplexTableCapability_enhanced);

         stat = asn1PD_H245H223Capability_h223MultiplexTableCapability_enhanced (pctxt, pvalue->u.enhanced);
         if (stat != 0) return stat;

         invokeEndElement (pctxt, "enhanced", -1);

         break;

      default:
         return ASN_E_INVOPT;
   }

   return (stat);
}

EXTERN int asn1PD_H245H223Capability_mobileOperationTransmitCapability (OOCTXT* pctxt, H245H223Capability_mobileOperationTransmitCapability* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode modeChangeCapability */
   invokeStartElement (pctxt, "modeChangeCapability", -1);

   stat = DECODEBIT (pctxt, &pvalue->modeChangeCapability);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->modeChangeCapability);
   invokeEndElement (pctxt, "modeChangeCapability", -1);

   /* decode h223AnnexA */
   invokeStartElement (pctxt, "h223AnnexA", -1);

   stat = DECODEBIT (pctxt, &pvalue->h223AnnexA);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->h223AnnexA);
   invokeEndElement (pctxt, "h223AnnexA", -1);

   /* decode h223AnnexADoubleFlag */
   invokeStartElement (pctxt, "h223AnnexADoubleFlag", -1);

   stat = DECODEBIT (pctxt, &pvalue->h223AnnexADoubleFlag);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->h223AnnexADoubleFlag);
   invokeEndElement (pctxt, "h223AnnexADoubleFlag", -1);

   /* decode h223AnnexB */
   invokeStartElement (pctxt, "h223AnnexB", -1);

   stat = DECODEBIT (pctxt, &pvalue->h223AnnexB);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->h223AnnexB);
   invokeEndElement (pctxt, "h223AnnexB", -1);

   /* decode h223AnnexBwithHeader */
   invokeStartElement (pctxt, "h223AnnexBwithHeader", -1);

   stat = DECODEBIT (pctxt, &pvalue->h223AnnexBwithHeader);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->h223AnnexBwithHeader);
   invokeEndElement (pctxt, "h223AnnexBwithHeader", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245H223AnnexCCapability (OOCTXT* pctxt, H245H223AnnexCCapability* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   /* decode root elements */
   /* decode videoWithAL1M */
   invokeStartElement (pctxt, "videoWithAL1M", -1);

   stat = DECODEBIT (pctxt, &pvalue->videoWithAL1M);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->videoWithAL1M);
   invokeEndElement (pctxt, "videoWithAL1M", -1);

   /* decode videoWithAL2M */
   invokeStartElement (pctxt, "videoWithAL2M", -1);

   stat = DECODEBIT (pctxt, &pvalue->videoWithAL2M);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->videoWithAL2M);
   invokeEndElement (pctxt, "videoWithAL2M", -1);

   /* decode videoWithAL3M */
   invokeStartElement (pctxt, "videoWithAL3M", -1);

   stat = DECODEBIT (pctxt, &pvalue->videoWithAL3M);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->videoWithAL3M);
   invokeEndElement (pctxt, "videoWithAL3M", -1);

   /* decode audioWithAL1M */
   invokeStartElement (pctxt, "audioWithAL1M", -1);

   stat = DECODEBIT (pctxt, &pvalue->audioWithAL1M);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->audioWithAL1M);
   invokeEndElement (pctxt, "audioWithAL1M", -1);

   /* decode audioWithAL2M */
   invokeStartElement (pctxt, "audioWithAL2M", -1);

   stat = DECODEBIT (pctxt, &pvalue->audioWithAL2M);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->audioWithAL2M);
   invokeEndElement (pctxt, "audioWithAL2M", -1);

   /* decode audioWithAL3M */
   invokeStartElement (pctxt, "audioWithAL3M", -1);

   stat = DECODEBIT (pctxt, &pvalue->audioWithAL3M);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->audioWithAL3M);
   invokeEndElement (pctxt, "audioWithAL3M", -1);

   /* decode dataWithAL1M */
   invokeStartElement (pctxt, "dataWithAL1M", -1);

   stat = DECODEBIT (pctxt, &pvalue->dataWithAL1M);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->dataWithAL1M);
   invokeEndElement (pctxt, "dataWithAL1M", -1);

   /* decode dataWithAL2M */
   invokeStartElement (pctxt, "dataWithAL2M", -1);

   stat = DECODEBIT (pctxt, &pvalue->dataWithAL2M);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->dataWithAL2M);
   invokeEndElement (pctxt, "dataWithAL2M", -1);

   /* decode dataWithAL3M */
   invokeStartElement (pctxt, "dataWithAL3M", -1);

   stat = DECODEBIT (pctxt, &pvalue->dataWithAL3M);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->dataWithAL3M);
   invokeEndElement (pctxt, "dataWithAL3M", -1);

   /* decode alpduInterleaving */
   invokeStartElement (pctxt, "alpduInterleaving", -1);

   stat = DECODEBIT (pctxt, &pvalue->alpduInterleaving);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->alpduInterleaving);
   invokeEndElement (pctxt, "alpduInterleaving", -1);

   /* decode maximumAL1MPDUSize */
   invokeStartElement (pctxt, "maximumAL1MPDUSize", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->maximumAL1MPDUSize, 0, 65535);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->maximumAL1MPDUSize);
   invokeEndElement (pctxt, "maximumAL1MPDUSize", -1);

   /* decode maximumAL2MSDUSize */
   invokeStartElement (pctxt, "maximumAL2MSDUSize", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->maximumAL2MSDUSize, 0, 65535);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->maximumAL2MSDUSize);
   invokeEndElement (pctxt, "maximumAL2MSDUSize", -1);

   /* decode maximumAL3MSDUSize */
   invokeStartElement (pctxt, "maximumAL3MSDUSize", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->maximumAL3MSDUSize, 0, 65535);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->maximumAL3MSDUSize);
   invokeEndElement (pctxt, "maximumAL3MSDUSize", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return stat;

            if (i < 1) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt,
                  (ASN1OCTET*)openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     if (openType.numocts == 0) break;

                     pvalue->m.rsCodeCapabilityPresent = 1;

                     invokeStartElement (pctxt, "rsCodeCapability", -1);

                     stat = DECODEBIT (pctxt, &pvalue->rsCodeCapability);
                     if (stat != 0) return stat;

                     invokeBoolValue (pctxt, pvalue->rsCodeCapability);
                     invokeEndElement (pctxt, "rsCodeCapability", -1);

                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245H223Capability_mobileMultilinkFrameCapability (OOCTXT* pctxt, H245H223Capability_mobileMultilinkFrameCapability* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode maximumSampleSize */
   invokeStartElement (pctxt, "maximumSampleSize", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->maximumSampleSize, 1, 255);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->maximumSampleSize);
   invokeEndElement (pctxt, "maximumSampleSize", -1);

   /* decode maximumPayloadLength */
   invokeStartElement (pctxt, "maximumPayloadLength", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->maximumPayloadLength, 1, 65025);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->maximumPayloadLength);
   invokeEndElement (pctxt, "maximumPayloadLength", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245H223Capability (OOCTXT* pctxt, H245H223Capability* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   /* decode root elements */
   /* decode transportWithI_frames */
   invokeStartElement (pctxt, "transportWithI_frames", -1);

   stat = DECODEBIT (pctxt, &pvalue->transportWithI_frames);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->transportWithI_frames);
   invokeEndElement (pctxt, "transportWithI_frames", -1);

   /* decode videoWithAL1 */
   invokeStartElement (pctxt, "videoWithAL1", -1);

   stat = DECODEBIT (pctxt, &pvalue->videoWithAL1);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->videoWithAL1);
   invokeEndElement (pctxt, "videoWithAL1", -1);

   /* decode videoWithAL2 */
   invokeStartElement (pctxt, "videoWithAL2", -1);

   stat = DECODEBIT (pctxt, &pvalue->videoWithAL2);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->videoWithAL2);
   invokeEndElement (pctxt, "videoWithAL2", -1);

   /* decode videoWithAL3 */
   invokeStartElement (pctxt, "videoWithAL3", -1);

   stat = DECODEBIT (pctxt, &pvalue->videoWithAL3);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->videoWithAL3);
   invokeEndElement (pctxt, "videoWithAL3", -1);

   /* decode audioWithAL1 */
   invokeStartElement (pctxt, "audioWithAL1", -1);

   stat = DECODEBIT (pctxt, &pvalue->audioWithAL1);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->audioWithAL1);
   invokeEndElement (pctxt, "audioWithAL1", -1);

   /* decode audioWithAL2 */
   invokeStartElement (pctxt, "audioWithAL2", -1);

   stat = DECODEBIT (pctxt, &pvalue->audioWithAL2);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->audioWithAL2);
   invokeEndElement (pctxt, "audioWithAL2", -1);

   /* decode audioWithAL3 */
   invokeStartElement (pctxt, "audioWithAL3", -1);

   stat = DECODEBIT (pctxt, &pvalue->audioWithAL3);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->audioWithAL3);
   invokeEndElement (pctxt, "audioWithAL3", -1);

   /* decode dataWithAL1 */
   invokeStartElement (pctxt, "dataWithAL1", -1);

   stat = DECODEBIT (pctxt, &pvalue->dataWithAL1);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->dataWithAL1);
   invokeEndElement (pctxt, "dataWithAL1", -1);

   /* decode dataWithAL2 */
   invokeStartElement (pctxt, "dataWithAL2", -1);

   stat = DECODEBIT (pctxt, &pvalue->dataWithAL2);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->dataWithAL2);
   invokeEndElement (pctxt, "dataWithAL2", -1);

   /* decode dataWithAL3 */
   invokeStartElement (pctxt, "dataWithAL3", -1);

   stat = DECODEBIT (pctxt, &pvalue->dataWithAL3);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->dataWithAL3);
   invokeEndElement (pctxt, "dataWithAL3", -1);

   /* decode maximumAl2SDUSize */
   invokeStartElement (pctxt, "maximumAl2SDUSize", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->maximumAl2SDUSize, 0, 65535);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->maximumAl2SDUSize);
   invokeEndElement (pctxt, "maximumAl2SDUSize", -1);

   /* decode maximumAl3SDUSize */
   invokeStartElement (pctxt, "maximumAl3SDUSize", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->maximumAl3SDUSize, 0, 65535);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->maximumAl3SDUSize);
   invokeEndElement (pctxt, "maximumAl3SDUSize", -1);

   /* decode maximumDelayJitter */
   invokeStartElement (pctxt, "maximumDelayJitter", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->maximumDelayJitter, 0, 1023);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->maximumDelayJitter);
   invokeEndElement (pctxt, "maximumDelayJitter", -1);

   /* decode h223MultiplexTableCapability */
   invokeStartElement (pctxt, "h223MultiplexTableCapability", -1);

   stat = asn1PD_H245H223Capability_h223MultiplexTableCapability (pctxt, &pvalue->h223MultiplexTableCapability);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "h223MultiplexTableCapability", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return stat;

            if (i < 6) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt,
                  (ASN1OCTET*)openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     if (openType.numocts == 0) break;

                     pvalue->m.maxMUXPDUSizeCapabilityPresent = 1;

                     invokeStartElement (pctxt, "maxMUXPDUSizeCapability", -1);

                     stat = DECODEBIT (pctxt, &pvalue->maxMUXPDUSizeCapability);
                     if (stat != 0) return stat;

                     invokeBoolValue (pctxt, pvalue->maxMUXPDUSizeCapability);
                     invokeEndElement (pctxt, "maxMUXPDUSizeCapability", -1);

                     break;

                  case 1:
                     if (openType.numocts == 0) break;

                     pvalue->m.nsrpSupportPresent = 1;

                     invokeStartElement (pctxt, "nsrpSupport", -1);

                     stat = DECODEBIT (pctxt, &pvalue->nsrpSupport);
                     if (stat != 0) return stat;

                     invokeBoolValue (pctxt, pvalue->nsrpSupport);
                     invokeEndElement (pctxt, "nsrpSupport", -1);

                     break;

                  case 2:
                     if (openType.numocts == 0) break;

                     pvalue->m.mobileOperationTransmitCapabilityPresent = 1;

                     invokeStartElement (pctxt, "mobileOperationTransmitCapability", -1);

                     stat = asn1PD_H245H223Capability_mobileOperationTransmitCapability (pctxt, &pvalue->mobileOperationTransmitCapability);
                     if (stat != 0) return stat;

                     invokeEndElement (pctxt, "mobileOperationTransmitCapability", -1);

                     break;

                  case 3:
                     if (openType.numocts == 0) break;

                     pvalue->m.h223AnnexCCapabilityPresent = 1;

                     invokeStartElement (pctxt, "h223AnnexCCapability", -1);

                     stat = asn1PD_H245H223AnnexCCapability (pctxt, &pvalue->h223AnnexCCapability);
                     if (stat != 0) return stat;

                     invokeEndElement (pctxt, "h223AnnexCCapability", -1);

                     break;

                  case 4:
                     if (openType.numocts == 0) break;

                     pvalue->m.bitRatePresent = 1;

                     invokeStartElement (pctxt, "bitRate", -1);

                     stat = decodeConsUInt16 (pctxt, &pvalue->bitRate, 1, 19200);
                     if (stat != 0) return stat;

                     invokeUIntValue (pctxt, pvalue->bitRate);
                     invokeEndElement (pctxt, "bitRate", -1);

                     break;

                  case 5:
                     if (openType.numocts == 0) break;

                     pvalue->m.mobileMultilinkFrameCapabilityPresent = 1;

                     invokeStartElement (pctxt, "mobileMultilinkFrameCapability", -1);

                     stat = asn1PD_H245H223Capability_mobileMultilinkFrameCapability (pctxt, &pvalue->mobileMultilinkFrameCapability);
                     if (stat != 0) return stat;

                     invokeEndElement (pctxt, "mobileMultilinkFrameCapability", -1);

                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245V75Capability (OOCTXT* pctxt, H245V75Capability* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode audioHeader */
   invokeStartElement (pctxt, "audioHeader", -1);

   stat = DECODEBIT (pctxt, &pvalue->audioHeader);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->audioHeader);
   invokeEndElement (pctxt, "audioHeader", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245V76Capability (OOCTXT* pctxt, H245V76Capability* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode suspendResumeCapabilitywAddress */
   invokeStartElement (pctxt, "suspendResumeCapabilitywAddress", -1);

   stat = DECODEBIT (pctxt, &pvalue->suspendResumeCapabilitywAddress);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->suspendResumeCapabilitywAddress);
   invokeEndElement (pctxt, "suspendResumeCapabilitywAddress", -1);

   /* decode suspendResumeCapabilitywoAddress */
   invokeStartElement (pctxt, "suspendResumeCapabilitywoAddress", -1);

   stat = DECODEBIT (pctxt, &pvalue->suspendResumeCapabilitywoAddress);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->suspendResumeCapabilitywoAddress);
   invokeEndElement (pctxt, "suspendResumeCapabilitywoAddress", -1);

   /* decode rejCapability */
   invokeStartElement (pctxt, "rejCapability", -1);

   stat = DECODEBIT (pctxt, &pvalue->rejCapability);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->rejCapability);
   invokeEndElement (pctxt, "rejCapability", -1);

   /* decode sREJCapability */
   invokeStartElement (pctxt, "sREJCapability", -1);

   stat = DECODEBIT (pctxt, &pvalue->sREJCapability);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->sREJCapability);
   invokeEndElement (pctxt, "sREJCapability", -1);

   /* decode mREJCapability */
   invokeStartElement (pctxt, "mREJCapability", -1);

   stat = DECODEBIT (pctxt, &pvalue->mREJCapability);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->mREJCapability);
   invokeEndElement (pctxt, "mREJCapability", -1);

   /* decode crc8bitCapability */
   invokeStartElement (pctxt, "crc8bitCapability", -1);

   stat = DECODEBIT (pctxt, &pvalue->crc8bitCapability);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->crc8bitCapability);
   invokeEndElement (pctxt, "crc8bitCapability", -1);

   /* decode crc16bitCapability */
   invokeStartElement (pctxt, "crc16bitCapability", -1);

   stat = DECODEBIT (pctxt, &pvalue->crc16bitCapability);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->crc16bitCapability);
   invokeEndElement (pctxt, "crc16bitCapability", -1);

   /* decode crc32bitCapability */
   invokeStartElement (pctxt, "crc32bitCapability", -1);

   stat = DECODEBIT (pctxt, &pvalue->crc32bitCapability);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->crc32bitCapability);
   invokeEndElement (pctxt, "crc32bitCapability", -1);

   /* decode uihCapability */
   invokeStartElement (pctxt, "uihCapability", -1);

   stat = DECODEBIT (pctxt, &pvalue->uihCapability);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->uihCapability);
   invokeEndElement (pctxt, "uihCapability", -1);

   /* decode numOfDLCS */
   invokeStartElement (pctxt, "numOfDLCS", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->numOfDLCS, 2, 8191);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->numOfDLCS);
   invokeEndElement (pctxt, "numOfDLCS", -1);

   /* decode twoOctetAddressFieldCapability */
   invokeStartElement (pctxt, "twoOctetAddressFieldCapability", -1);

   stat = DECODEBIT (pctxt, &pvalue->twoOctetAddressFieldCapability);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->twoOctetAddressFieldCapability);
   invokeEndElement (pctxt, "twoOctetAddressFieldCapability", -1);

   /* decode loopBackTestCapability */
   invokeStartElement (pctxt, "loopBackTestCapability", -1);

   stat = DECODEBIT (pctxt, &pvalue->loopBackTestCapability);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->loopBackTestCapability);
   invokeEndElement (pctxt, "loopBackTestCapability", -1);

   /* decode n401Capability */
   invokeStartElement (pctxt, "n401Capability", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->n401Capability, 1, 4095);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->n401Capability);
   invokeEndElement (pctxt, "n401Capability", -1);

   /* decode maxWindowSizeCapability */
   invokeStartElement (pctxt, "maxWindowSizeCapability", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->maxWindowSizeCapability, 1, 127);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->maxWindowSizeCapability);
   invokeEndElement (pctxt, "maxWindowSizeCapability", -1);

   /* decode v75Capability */
   invokeStartElement (pctxt, "v75Capability", -1);

   stat = asn1PD_H245V75Capability (pctxt, &pvalue->v75Capability);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "v75Capability", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245T84Profile_t84Restricted (OOCTXT* pctxt, H245T84Profile_t84Restricted* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode qcif */
   invokeStartElement (pctxt, "qcif", -1);

   stat = DECODEBIT (pctxt, &pvalue->qcif);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->qcif);
   invokeEndElement (pctxt, "qcif", -1);

   /* decode cif */
   invokeStartElement (pctxt, "cif", -1);

   stat = DECODEBIT (pctxt, &pvalue->cif);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->cif);
   invokeEndElement (pctxt, "cif", -1);

   /* decode ccir601Seq */
   invokeStartElement (pctxt, "ccir601Seq", -1);

   stat = DECODEBIT (pctxt, &pvalue->ccir601Seq);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->ccir601Seq);
   invokeEndElement (pctxt, "ccir601Seq", -1);

   /* decode ccir601Prog */
   invokeStartElement (pctxt, "ccir601Prog", -1);

   stat = DECODEBIT (pctxt, &pvalue->ccir601Prog);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->ccir601Prog);
   invokeEndElement (pctxt, "ccir601Prog", -1);

   /* decode hdtvSeq */
   invokeStartElement (pctxt, "hdtvSeq", -1);

   stat = DECODEBIT (pctxt, &pvalue->hdtvSeq);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->hdtvSeq);
   invokeEndElement (pctxt, "hdtvSeq", -1);

   /* decode hdtvProg */
   invokeStartElement (pctxt, "hdtvProg", -1);

   stat = DECODEBIT (pctxt, &pvalue->hdtvProg);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->hdtvProg);
   invokeEndElement (pctxt, "hdtvProg", -1);

   /* decode g3FacsMH200x100 */
   invokeStartElement (pctxt, "g3FacsMH200x100", -1);

   stat = DECODEBIT (pctxt, &pvalue->g3FacsMH200x100);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->g3FacsMH200x100);
   invokeEndElement (pctxt, "g3FacsMH200x100", -1);

   /* decode g3FacsMH200x200 */
   invokeStartElement (pctxt, "g3FacsMH200x200", -1);

   stat = DECODEBIT (pctxt, &pvalue->g3FacsMH200x200);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->g3FacsMH200x200);
   invokeEndElement (pctxt, "g3FacsMH200x200", -1);

   /* decode g4FacsMMR200x100 */
   invokeStartElement (pctxt, "g4FacsMMR200x100", -1);

   stat = DECODEBIT (pctxt, &pvalue->g4FacsMMR200x100);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->g4FacsMMR200x100);
   invokeEndElement (pctxt, "g4FacsMMR200x100", -1);

   /* decode g4FacsMMR200x200 */
   invokeStartElement (pctxt, "g4FacsMMR200x200", -1);

   stat = DECODEBIT (pctxt, &pvalue->g4FacsMMR200x200);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->g4FacsMMR200x200);
   invokeEndElement (pctxt, "g4FacsMMR200x200", -1);

   /* decode jbig200x200Seq */
   invokeStartElement (pctxt, "jbig200x200Seq", -1);

   stat = DECODEBIT (pctxt, &pvalue->jbig200x200Seq);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->jbig200x200Seq);
   invokeEndElement (pctxt, "jbig200x200Seq", -1);

   /* decode jbig200x200Prog */
   invokeStartElement (pctxt, "jbig200x200Prog", -1);

   stat = DECODEBIT (pctxt, &pvalue->jbig200x200Prog);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->jbig200x200Prog);
   invokeEndElement (pctxt, "jbig200x200Prog", -1);

   /* decode jbig300x300Seq */
   invokeStartElement (pctxt, "jbig300x300Seq", -1);

   stat = DECODEBIT (pctxt, &pvalue->jbig300x300Seq);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->jbig300x300Seq);
   invokeEndElement (pctxt, "jbig300x300Seq", -1);

   /* decode jbig300x300Prog */
   invokeStartElement (pctxt, "jbig300x300Prog", -1);

   stat = DECODEBIT (pctxt, &pvalue->jbig300x300Prog);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->jbig300x300Prog);
   invokeEndElement (pctxt, "jbig300x300Prog", -1);

   /* decode digPhotoLow */
   invokeStartElement (pctxt, "digPhotoLow", -1);

   stat = DECODEBIT (pctxt, &pvalue->digPhotoLow);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->digPhotoLow);
   invokeEndElement (pctxt, "digPhotoLow", -1);

   /* decode digPhotoMedSeq */
   invokeStartElement (pctxt, "digPhotoMedSeq", -1);

   stat = DECODEBIT (pctxt, &pvalue->digPhotoMedSeq);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->digPhotoMedSeq);
   invokeEndElement (pctxt, "digPhotoMedSeq", -1);

   /* decode digPhotoMedProg */
   invokeStartElement (pctxt, "digPhotoMedProg", -1);

   stat = DECODEBIT (pctxt, &pvalue->digPhotoMedProg);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->digPhotoMedProg);
   invokeEndElement (pctxt, "digPhotoMedProg", -1);

   /* decode digPhotoHighSeq */
   invokeStartElement (pctxt, "digPhotoHighSeq", -1);

   stat = DECODEBIT (pctxt, &pvalue->digPhotoHighSeq);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->digPhotoHighSeq);
   invokeEndElement (pctxt, "digPhotoHighSeq", -1);

   /* decode digPhotoHighProg */
   invokeStartElement (pctxt, "digPhotoHighProg", -1);

   stat = DECODEBIT (pctxt, &pvalue->digPhotoHighProg);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->digPhotoHighProg);
   invokeEndElement (pctxt, "digPhotoHighProg", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245T84Profile (OOCTXT* pctxt, H245T84Profile* pvalue)
{
   int stat = 0;
   OOUINT32 ui;

   stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
   if (stat != 0) return stat;
   else pvalue->t = ui + 1;

   switch (ui) {
      /* t84Unrestricted */
      case 0:
         invokeStartElement (pctxt, "t84Unrestricted", -1);

         /* NULL */

         invokeNullValue (pctxt);
         invokeEndElement (pctxt, "t84Unrestricted", -1);

         break;

      /* t84Restricted */
      case 1:
         invokeStartElement (pctxt, "t84Restricted", -1);

         pvalue->u.t84Restricted = memAllocTypeZ (pctxt,
            H245T84Profile_t84Restricted);

         stat = asn1PD_H245T84Profile_t84Restricted (pctxt, pvalue->u.t84Restricted);
         if (stat != 0) return stat;

         invokeEndElement (pctxt, "t84Restricted", -1);

         break;

      default:
         return ASN_E_INVOPT;
   }

   return (stat);
}

EXTERN int asn1PD_H245DataApplicationCapability_application_t84 (OOCTXT* pctxt, H245DataApplicationCapability_application_t84* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode t84Protocol */
   invokeStartElement (pctxt, "t84Protocol", -1);

   stat = asn1PD_H245DataProtocolCapability (pctxt, &pvalue->t84Protocol);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "t84Protocol", -1);

   /* decode t84Profile */
   invokeStartElement (pctxt, "t84Profile", -1);

   stat = asn1PD_H245T84Profile (pctxt, &pvalue->t84Profile);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "t84Profile", -1);

   return (stat);
}

EXTERN int asn1PD_H245DataApplicationCapability_application_nlpid (OOCTXT* pctxt, H245DataApplicationCapability_application_nlpid* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode nlpidProtocol */
   invokeStartElement (pctxt, "nlpidProtocol", -1);

   stat = asn1PD_H245DataProtocolCapability (pctxt, &pvalue->nlpidProtocol);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "nlpidProtocol", -1);

   /* decode nlpidData */
   invokeStartElement (pctxt, "nlpidData", -1);

   stat = decodeDynOctetString (pctxt, (ASN1DynOctStr*)&pvalue->nlpidData);
   if (stat != 0) return stat;

   invokeOctStrValue (pctxt, pvalue->nlpidData.numocts, pvalue->nlpidData.data);
   invokeEndElement (pctxt, "nlpidData", -1);

   return (stat);
}

EXTERN int asn1PD_H245DataApplicationCapability_application_t38fax (OOCTXT* pctxt, H245DataApplicationCapability_application_t38fax* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode t38FaxProtocol */
   invokeStartElement (pctxt, "t38FaxProtocol", -1);

   stat = asn1PD_H245DataProtocolCapability (pctxt, &pvalue->t38FaxProtocol);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "t38FaxProtocol", -1);

   /* decode t38FaxProfile */
   invokeStartElement (pctxt, "t38FaxProfile", -1);

   stat = asn1PD_H245T38FaxProfile (pctxt, &pvalue->t38FaxProfile);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "t38FaxProfile", -1);

   return (stat);
}

EXTERN int asn1PD_H245GenericCapability (OOCTXT* pctxt, H245GenericCapability* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;
   OOUINT32 j = 0;
   OOBOOL optbits[5];

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   for (i = 0; i < 5; i++) {
      stat = DECODEBIT (pctxt, &optbits[i]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i = 0; i < 6; i++) {
      switch (i) {
         case 0:
         /* decode capabilityIdentifier */
         invokeStartElement (pctxt, "capabilityIdentifier", -1);

         stat = asn1PD_H245CapabilityIdentifier (pctxt, &pvalue->capabilityIdentifier);

         invokeEndElement (pctxt, "capabilityIdentifier", -1);

         break;

         case 1:
         /* decode maxBitRate */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "maxBitRate", -1);

            stat = decodeConsUnsigned (pctxt, &pvalue->maxBitRate, 0, OOUINT32_MAX);

            invokeUIntValue (pctxt, pvalue->maxBitRate);
            pvalue->m.maxBitRatePresent = 1;
            invokeEndElement (pctxt, "maxBitRate", -1);

         }
         break;

         case 2:
         /* decode collapsing */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "collapsing", -1);

            stat = asn1PD_H245_SeqOfH245GenericParameter (pctxt, &pvalue->collapsing);

            pvalue->m.collapsingPresent = 1;
            invokeEndElement (pctxt, "collapsing", -1);

         }
         break;

         case 3:
         /* decode nonCollapsing */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "nonCollapsing", -1);

            stat = asn1PD_H245_SeqOfH245GenericParameter (pctxt, &pvalue->nonCollapsing);

            pvalue->m.nonCollapsingPresent = 1;
            invokeEndElement (pctxt, "nonCollapsing", -1);

         }
         break;

         case 4:
         /* decode nonCollapsingRaw */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "nonCollapsingRaw", -1);

            stat = decodeDynOctetString (pctxt, (ASN1DynOctStr*)&pvalue->nonCollapsingRaw);

            invokeOctStrValue (pctxt, pvalue->nonCollapsingRaw.numocts, pvalue->nonCollapsingRaw.data);
            pvalue->m.nonCollapsingRawPresent = 1;
            invokeEndElement (pctxt, "nonCollapsingRaw", -1);

         }
         break;

         case 5:
         /* decode transport */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "transport", -1);

            stat = asn1PD_H245DataProtocolCapability (pctxt, &pvalue->transport);

            pvalue->m.transportPresent = 1;
            invokeEndElement (pctxt, "transport", -1);

         }
         break;

         default: j++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245DataApplicationCapability_application (OOCTXT* pctxt, H245DataApplicationCapability_application* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 9);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            invokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = memAllocTypeZ (pctxt,
               H245NonStandardParameter);

            stat = asn1PD_H245NonStandardParameter (pctxt, pvalue->u.nonStandard);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* t120 */
         case 1:
            invokeStartElement (pctxt, "t120", -1);

            pvalue->u.t120 = memAllocTypeZ (pctxt,
               H245DataProtocolCapability);

            stat = asn1PD_H245DataProtocolCapability (pctxt, pvalue->u.t120);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "t120", -1);

            break;

         /* dsm_cc */
         case 2:
            invokeStartElement (pctxt, "dsm_cc", -1);

            pvalue->u.dsm_cc = memAllocTypeZ (pctxt,
               H245DataProtocolCapability);

            stat = asn1PD_H245DataProtocolCapability (pctxt, pvalue->u.dsm_cc);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "dsm_cc", -1);

            break;

         /* userData */
         case 3:
            invokeStartElement (pctxt, "userData", -1);

            pvalue->u.userData = memAllocTypeZ (pctxt,
               H245DataProtocolCapability);

            stat = asn1PD_H245DataProtocolCapability (pctxt, pvalue->u.userData);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "userData", -1);

            break;

         /* t84 */
         case 4:
            invokeStartElement (pctxt, "t84", -1);

            pvalue->u.t84 = memAllocTypeZ (pctxt,
               H245DataApplicationCapability_application_t84);

            stat = asn1PD_H245DataApplicationCapability_application_t84 (pctxt, pvalue->u.t84);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "t84", -1);

            break;

         /* t434 */
         case 5:
            invokeStartElement (pctxt, "t434", -1);

            pvalue->u.t434 = memAllocTypeZ (pctxt,
               H245DataProtocolCapability);

            stat = asn1PD_H245DataProtocolCapability (pctxt, pvalue->u.t434);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "t434", -1);

            break;

         /* h224 */
         case 6:
            invokeStartElement (pctxt, "h224", -1);

            pvalue->u.h224 = memAllocTypeZ (pctxt,
               H245DataProtocolCapability);

            stat = asn1PD_H245DataProtocolCapability (pctxt, pvalue->u.h224);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "h224", -1);

            break;

         /* nlpid */
         case 7:
            invokeStartElement (pctxt, "nlpid", -1);

            pvalue->u.nlpid = memAllocTypeZ (pctxt,
               H245DataApplicationCapability_application_nlpid);

            stat = asn1PD_H245DataApplicationCapability_application_nlpid (pctxt, pvalue->u.nlpid);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "nlpid", -1);

            break;

         /* dsvdControl */
         case 8:
            invokeStartElement (pctxt, "dsvdControl", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "dsvdControl", -1);

            break;

         /* h222DataPartitioning */
         case 9:
            invokeStartElement (pctxt, "h222DataPartitioning", -1);

            pvalue->u.h222DataPartitioning = memAllocTypeZ (pctxt,
               H245DataProtocolCapability);

            stat = asn1PD_H245DataProtocolCapability (pctxt, pvalue->u.h222DataPartitioning);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "h222DataPartitioning", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 11;

      if (pvalue->t < 11) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt,
         (ASN1OCTET*)openType.data, openType.numocts);

      switch (pvalue->t) {
         /* t30fax */
         case 11:
            invokeStartElement (pctxt, "t30fax", -1);

            pvalue->u.t30fax = memAllocTypeZ (pctxt,
               H245DataProtocolCapability);

            stat = asn1PD_H245DataProtocolCapability (pctxt, pvalue->u.t30fax);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "t30fax", -1);

            break;

         /* t140 */
         case 12:
            invokeStartElement (pctxt, "t140", -1);

            pvalue->u.t140 = memAllocTypeZ (pctxt,
               H245DataProtocolCapability);

            stat = asn1PD_H245DataProtocolCapability (pctxt, pvalue->u.t140);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "t140", -1);

            break;

         /* t38fax */
         case 13:
            invokeStartElement (pctxt, "t38fax", -1);

            pvalue->u.t38fax = memAllocTypeZ (pctxt,
               H245DataApplicationCapability_application_t38fax);

            stat = asn1PD_H245DataApplicationCapability_application_t38fax (pctxt, pvalue->u.t38fax);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "t38fax", -1);

            break;

         /* genericDataCapability */
         case 14:
            invokeStartElement (pctxt, "genericDataCapability", -1);

            pvalue->u.genericDataCapability = memAllocTypeZ (pctxt,
               H245GenericCapability);

            stat = asn1PD_H245GenericCapability (pctxt, pvalue->u.genericDataCapability);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "genericDataCapability", -1);

            break;

         default:;
      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

EXTERN int asn1PD_H245DataApplicationCapability (OOCTXT* pctxt, H245DataApplicationCapability* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode application */
   invokeStartElement (pctxt, "application", -1);

   stat = asn1PD_H245DataApplicationCapability_application (pctxt, &pvalue->application);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "application", -1);

   /* decode maxBitRate */
   invokeStartElement (pctxt, "maxBitRate", -1);

   stat = decodeConsUnsigned (pctxt, &pvalue->maxBitRate, 0, OOUINT32_MAX);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->maxBitRate);
   invokeEndElement (pctxt, "maxBitRate", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245_SeqOfH245DataApplicationCapability (OOCTXT* pctxt, H245_SeqOfH245DataApplicationCapability* pvalue)
{
   int stat = 0;
   H245DataApplicationCapability* pdata;
   DListNode* pnode;
   OOUINT32 count = 0;
   OOUINT32 xx1 = 0;
   int lstat;
   OOUINT32 total = 0;

   dListInit (pvalue);

   for (;;) {
      /* decode length determinant */

      lstat = decodeLength (pctxt, &count);
      if (lstat != 0 && lstat != ASN_OK_FRAG) {
         return lstat;
      }
      else if (count == 0) break;
      total += count;

      /* decode elements */

      for (; xx1 < total; xx1++) {
         invokeStartElement (pctxt, "elem", xx1);

         dListAllocNodeAndData (pctxt, H245DataApplicationCapability, &pnode, &pdata);

         stat = asn1PD_H245DataApplicationCapability (pctxt, pdata);
         if (stat != 0) return stat;

         invokeEndElement (pctxt, "elem", xx1);

         dListAppendNode2 (pvalue, pnode);
      }

      if (lstat == 0) break;
   }

   return (stat);
}

EXTERN int asn1PD_H245MediaDistributionCapability (OOCTXT* pctxt, H245MediaDistributionCapability* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.centralizedDataPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.distributedDataPresent = optbit;

   /* decode root elements */
   /* decode centralizedControl */
   invokeStartElement (pctxt, "centralizedControl", -1);

   stat = DECODEBIT (pctxt, &pvalue->centralizedControl);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->centralizedControl);
   invokeEndElement (pctxt, "centralizedControl", -1);

   /* decode distributedControl */
   invokeStartElement (pctxt, "distributedControl", -1);

   stat = DECODEBIT (pctxt, &pvalue->distributedControl);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->distributedControl);
   invokeEndElement (pctxt, "distributedControl", -1);

   /* decode centralizedAudio */
   invokeStartElement (pctxt, "centralizedAudio", -1);

   stat = DECODEBIT (pctxt, &pvalue->centralizedAudio);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->centralizedAudio);
   invokeEndElement (pctxt, "centralizedAudio", -1);

   /* decode distributedAudio */
   invokeStartElement (pctxt, "distributedAudio", -1);

   stat = DECODEBIT (pctxt, &pvalue->distributedAudio);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->distributedAudio);
   invokeEndElement (pctxt, "distributedAudio", -1);

   /* decode centralizedVideo */
   invokeStartElement (pctxt, "centralizedVideo", -1);

   stat = DECODEBIT (pctxt, &pvalue->centralizedVideo);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->centralizedVideo);
   invokeEndElement (pctxt, "centralizedVideo", -1);

   /* decode distributedVideo */
   invokeStartElement (pctxt, "distributedVideo", -1);

   stat = DECODEBIT (pctxt, &pvalue->distributedVideo);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->distributedVideo);
   invokeEndElement (pctxt, "distributedVideo", -1);

   /* decode centralizedData */
   if (pvalue->m.centralizedDataPresent) {
      invokeStartElement (pctxt, "centralizedData", -1);

      stat = asn1PD_H245_SeqOfH245DataApplicationCapability (pctxt, &pvalue->centralizedData);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "centralizedData", -1);

   }

   /* decode distributedData */
   if (pvalue->m.distributedDataPresent) {
      invokeStartElement (pctxt, "distributedData", -1);

      stat = asn1PD_H245_SeqOfH245DataApplicationCapability (pctxt, &pvalue->distributedData);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "distributedData", -1);

   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245_SeqOfH245MediaDistributionCapability (OOCTXT* pctxt, H245_SeqOfH245MediaDistributionCapability* pvalue)
{
   int stat = 0;
   H245MediaDistributionCapability* pdata;
   DListNode* pnode;
   OOUINT32 count = 0;
   OOUINT32 xx1 = 0;
   int lstat;
   OOUINT32 total = 0;

   dListInit (pvalue);

   for (;;) {
      /* decode length determinant */

      lstat = decodeLength (pctxt, &count);
      if (lstat != 0 && lstat != ASN_OK_FRAG) {
         return lstat;
      }
      else if (count == 0) break;
      total += count;

      /* decode elements */

      for (; xx1 < total; xx1++) {
         invokeStartElement (pctxt, "elem", xx1);

         dListAllocNodeAndData (pctxt, H245MediaDistributionCapability, &pnode, &pdata);

         stat = asn1PD_H245MediaDistributionCapability (pctxt, pdata);
         if (stat != 0) return stat;

         invokeEndElement (pctxt, "elem", xx1);

         dListAppendNode2 (pvalue, pnode);
      }

      if (lstat == 0) break;
   }

   return (stat);
}

EXTERN int asn1PD_H245MultipointCapability (OOCTXT* pctxt, H245MultipointCapability* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode multicastCapability */
   invokeStartElement (pctxt, "multicastCapability", -1);

   stat = DECODEBIT (pctxt, &pvalue->multicastCapability);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->multicastCapability);
   invokeEndElement (pctxt, "multicastCapability", -1);

   /* decode multiUniCastConference */
   invokeStartElement (pctxt, "multiUniCastConference", -1);

   stat = DECODEBIT (pctxt, &pvalue->multiUniCastConference);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->multiUniCastConference);
   invokeEndElement (pctxt, "multiUniCastConference", -1);

   /* decode mediaDistributionCapability */
   invokeStartElement (pctxt, "mediaDistributionCapability", -1);

   stat = asn1PD_H245_SeqOfH245MediaDistributionCapability (pctxt, &pvalue->mediaDistributionCapability);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "mediaDistributionCapability", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245H2250Capability_mcCapability (OOCTXT* pctxt, H245H2250Capability_mcCapability* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode centralizedConferenceMC */
   invokeStartElement (pctxt, "centralizedConferenceMC", -1);

   stat = DECODEBIT (pctxt, &pvalue->centralizedConferenceMC);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->centralizedConferenceMC);
   invokeEndElement (pctxt, "centralizedConferenceMC", -1);

   /* decode decentralizedConferenceMC */
   invokeStartElement (pctxt, "decentralizedConferenceMC", -1);

   stat = DECODEBIT (pctxt, &pvalue->decentralizedConferenceMC);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->decentralizedConferenceMC);
   invokeEndElement (pctxt, "decentralizedConferenceMC", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245RTPPayloadType_payloadDescriptor (OOCTXT* pctxt, H245RTPPayloadType_payloadDescriptor* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandardIdentifier */
         case 0:
            invokeStartElement (pctxt, "nonStandardIdentifier", -1);

            pvalue->u.nonStandardIdentifier = memAllocTypeZ (pctxt,
               H245NonStandardParameter);

            stat = asn1PD_H245NonStandardParameter (pctxt, pvalue->u.nonStandardIdentifier);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "nonStandardIdentifier", -1);

            break;

         /* rfc_number */
         case 1:
            invokeStartElement (pctxt, "rfc_number", -1);

            /* extension bit */

            stat = DECODEBIT (pctxt, &extbit);
            if (stat != 0) return stat;

            if (extbit == 0) {
               stat = decodeConsUnsigned (pctxt, &pvalue->u.rfc_number, 1, 32768);
               if (stat != 0) return stat;
            }
            else {
               stat = decodeUnconsUnsigned (pctxt, &pvalue->u.rfc_number);
               if (stat != 0) return stat;
            }

            invokeUIntValue (pctxt, pvalue->u.rfc_number);
            invokeEndElement (pctxt, "rfc_number", -1);

            break;

         /* oid */
         case 2:
            invokeStartElement (pctxt, "oid", -1);

            pvalue->u.oid = memAllocTypeZ (pctxt, ASN1OBJID);

            stat = decodeObjectIdentifier (pctxt, pvalue->u.oid);
            if (stat != 0) return stat;

            invokeOidValue (pctxt, pvalue->u.oid->numids, pvalue->u.oid->subid);
            invokeEndElement (pctxt, "oid", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 4;

      if (pvalue->t < 4) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245RTPPayloadType (OOCTXT* pctxt, H245RTPPayloadType* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.payloadTypePresent = optbit;

   /* decode root elements */
   /* decode payloadDescriptor */
   invokeStartElement (pctxt, "payloadDescriptor", -1);

   stat = asn1PD_H245RTPPayloadType_payloadDescriptor (pctxt, &pvalue->payloadDescriptor);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "payloadDescriptor", -1);

   /* decode payloadType */
   if (pvalue->m.payloadTypePresent) {
      invokeStartElement (pctxt, "payloadType", -1);

      stat = decodeConsUInt8 (pctxt, &pvalue->payloadType, 0, 127);
      if (stat != 0) return stat;

      invokeUIntValue (pctxt, pvalue->payloadType);
      invokeEndElement (pctxt, "payloadType", -1);

   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245MediaPacketizationCapability_rtpPayloadType (OOCTXT* pctxt, H245MediaPacketizationCapability_rtpPayloadType* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 256, 0 };
   int stat = 0;
   H245RTPPayloadType* pdata;
   DListNode* pnode;
   OOUINT32 count = 0;
   OOUINT32 xx1 = 0;

   /* decode length determinant */

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeLength (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      invokeStartElement (pctxt, "elem", xx1);

      dListAllocNodeAndData (pctxt, H245RTPPayloadType, &pnode, &pdata);

      stat = asn1PD_H245RTPPayloadType (pctxt, pdata);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "elem", xx1);

      dListAppendNode2 (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1PD_H245MediaPacketizationCapability (OOCTXT* pctxt, H245MediaPacketizationCapability* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   /* decode root elements */
   /* decode h261aVideoPacketization */
   invokeStartElement (pctxt, "h261aVideoPacketization", -1);

   stat = DECODEBIT (pctxt, &pvalue->h261aVideoPacketization);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->h261aVideoPacketization);
   invokeEndElement (pctxt, "h261aVideoPacketization", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return stat;

            if (i < 1) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt,
                  (ASN1OCTET*)openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     if (openType.numocts == 0) break;

                     pvalue->m.rtpPayloadTypePresent = 1;

                     invokeStartElement (pctxt, "rtpPayloadType", -1);

                     stat = asn1PD_H245MediaPacketizationCapability_rtpPayloadType (pctxt, &pvalue->rtpPayloadType);
                     if (stat != 0) return stat;

                     invokeEndElement (pctxt, "rtpPayloadType", -1);

                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245TransportCapability_qOSCapabilities (OOCTXT* pctxt, H245TransportCapability_qOSCapabilities* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 256, 0 };
   int stat = 0;
   H245QOSCapability* pdata;
   DListNode* pnode;
   OOUINT32 count = 0;
   OOUINT32 xx1 = 0;

   /* decode length determinant */

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeLength (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      invokeStartElement (pctxt, "elem", xx1);

      dListAllocNodeAndData (pctxt, H245QOSCapability, &pnode, &pdata);

      stat = asn1PD_H245QOSCapability (pctxt, pdata);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "elem", xx1);

      dListAppendNode2 (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1PD_H245MediaTransportType_atm_AAL5_compressed (OOCTXT* pctxt, H245MediaTransportType_atm_AAL5_compressed* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode variable_delta */
   invokeStartElement (pctxt, "variable_delta", -1);

   stat = DECODEBIT (pctxt, &pvalue->variable_delta);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->variable_delta);
   invokeEndElement (pctxt, "variable_delta", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245MediaTransportType (OOCTXT* pctxt, H245MediaTransportType* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 3);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* ip_UDP */
         case 0:
            invokeStartElement (pctxt, "ip_UDP", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "ip_UDP", -1);

            break;

         /* ip_TCP */
         case 1:
            invokeStartElement (pctxt, "ip_TCP", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "ip_TCP", -1);

            break;

         /* atm_AAL5_UNIDIR */
         case 2:
            invokeStartElement (pctxt, "atm_AAL5_UNIDIR", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "atm_AAL5_UNIDIR", -1);

            break;

         /* atm_AAL5_BIDIR */
         case 3:
            invokeStartElement (pctxt, "atm_AAL5_BIDIR", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "atm_AAL5_BIDIR", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 5;

      if (pvalue->t < 5) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt,
         (ASN1OCTET*)openType.data, openType.numocts);

      switch (pvalue->t) {
         /* atm_AAL5_compressed */
         case 5:
            invokeStartElement (pctxt, "atm_AAL5_compressed", -1);

            pvalue->u.atm_AAL5_compressed = memAllocTypeZ (pctxt,
               H245MediaTransportType_atm_AAL5_compressed);

            stat = asn1PD_H245MediaTransportType_atm_AAL5_compressed (pctxt, pvalue->u.atm_AAL5_compressed);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "atm_AAL5_compressed", -1);

            break;

         default:;
      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

EXTERN int asn1PD_H245MediaChannelCapability (OOCTXT* pctxt, H245MediaChannelCapability* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.mediaTransportPresent = optbit;

   /* decode root elements */
   /* decode mediaTransport */
   if (pvalue->m.mediaTransportPresent) {
      invokeStartElement (pctxt, "mediaTransport", -1);

      stat = asn1PD_H245MediaTransportType (pctxt, &pvalue->mediaTransport);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "mediaTransport", -1);

   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245TransportCapability_mediaChannelCapabilities (OOCTXT* pctxt, H245TransportCapability_mediaChannelCapabilities* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 256, 0 };
   int stat = 0;
   H245MediaChannelCapability* pdata;
   DListNode* pnode;
   OOUINT32 count = 0;
   OOUINT32 xx1 = 0;

   /* decode length determinant */

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeLength (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      invokeStartElement (pctxt, "elem", xx1);

      dListAllocNodeAndData (pctxt, H245MediaChannelCapability, &pnode, &pdata);

      stat = asn1PD_H245MediaChannelCapability (pctxt, pdata);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "elem", xx1);

      dListAppendNode2 (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1PD_H245TransportCapability (OOCTXT* pctxt, H245TransportCapability* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;
   OOUINT32 j = 0;
   OOBOOL optbits[3];

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   for (i = 0; i < 3; i++) {
      stat = DECODEBIT (pctxt, &optbits[i]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i = 0; i < 3; i++) {
      switch (i) {
         case 0:
         /* decode nonStandard */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "nonStandard", -1);

            stat = asn1PD_H245NonStandardParameter (pctxt, &pvalue->nonStandard);

            pvalue->m.nonStandardPresent = 1;
            invokeEndElement (pctxt, "nonStandard", -1);

         }
         break;

         case 1:
         /* decode qOSCapabilities */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "qOSCapabilities", -1);

            stat = asn1PD_H245TransportCapability_qOSCapabilities (pctxt, &pvalue->qOSCapabilities);

            pvalue->m.qOSCapabilitiesPresent = 1;
            invokeEndElement (pctxt, "qOSCapabilities", -1);

         }
         break;

         case 2:
         /* decode mediaChannelCapabilities */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "mediaChannelCapabilities", -1);

            stat = asn1PD_H245TransportCapability_mediaChannelCapabilities (pctxt, &pvalue->mediaChannelCapabilities);

            pvalue->m.mediaChannelCapabilitiesPresent = 1;
            invokeEndElement (pctxt, "mediaChannelCapabilities", -1);

         }
         break;

         default: j++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245RTPH263VideoRedundancyFrameMapping_frameSequence (OOCTXT* pctxt, H245RTPH263VideoRedundancyFrameMapping_frameSequence* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 256, 0 };
   int stat = 0;
   OOUINT32 xx1 = 0;

   /* decode length determinant */

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeLength (pctxt, &pvalue->n);
   if (stat != 0) return stat;

   /* decode elements */

   if (256 < pvalue->n) {
      return stat;
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      invokeStartElement (pctxt, "elem", xx1);

      stat = decodeConsUInt8 (pctxt, &pvalue->elem[xx1], 0, 255);
      if (stat != 0) return stat;

      invokeUIntValue (pctxt, pvalue->elem[xx1]);
      invokeEndElement (pctxt, "elem", xx1);

   }

   return (stat);
}

EXTERN int asn1PD_H245RTPH263VideoRedundancyFrameMapping (OOCTXT* pctxt, H245RTPH263VideoRedundancyFrameMapping* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode threadNumber */
   invokeStartElement (pctxt, "threadNumber", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->threadNumber, 0, 15);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->threadNumber);
   invokeEndElement (pctxt, "threadNumber", -1);

   /* decode frameSequence */
   invokeStartElement (pctxt, "frameSequence", -1);

   stat = asn1PD_H245RTPH263VideoRedundancyFrameMapping_frameSequence (pctxt, &pvalue->frameSequence);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "frameSequence", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom (OOCTXT* pctxt, H245RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 256, 0 };
   int stat = 0;
   H245RTPH263VideoRedundancyFrameMapping* pdata;
   DListNode* pnode;
   OOUINT32 count = 0;
   OOUINT32 xx1 = 0;

   /* decode length determinant */

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeLength (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      invokeStartElement (pctxt, "elem", xx1);

      dListAllocNodeAndData (pctxt, H245RTPH263VideoRedundancyFrameMapping, &pnode, &pdata);

      stat = asn1PD_H245RTPH263VideoRedundancyFrameMapping (pctxt, pdata);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "elem", xx1);

      dListAppendNode2 (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1PD_H245RTPH263VideoRedundancyEncoding_frameToThreadMapping (OOCTXT* pctxt, H245RTPH263VideoRedundancyEncoding_frameToThreadMapping* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* roundrobin */
         case 0:
            invokeStartElement (pctxt, "roundrobin", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "roundrobin", -1);

            break;

         /* custom */
         case 1:
            invokeStartElement (pctxt, "custom", -1);

            pvalue->u.custom = memAllocTypeZ (pctxt,
               H245RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom);

            stat = asn1PD_H245RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom (pctxt, pvalue->u.custom);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "custom", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245RTPH263VideoRedundancyEncoding_containedThreads (OOCTXT* pctxt, H245RTPH263VideoRedundancyEncoding_containedThreads* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 256, 0 };
   int stat = 0;
   OOUINT32 xx1 = 0;

   /* decode length determinant */

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeLength (pctxt, &pvalue->n);
   if (stat != 0) return stat;

   /* decode elements */

   if (256 < pvalue->n) {
      return stat;
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      invokeStartElement (pctxt, "elem", xx1);

      stat = decodeConsUInt8 (pctxt, &pvalue->elem[xx1], 0, 15);
      if (stat != 0) return stat;

      invokeUIntValue (pctxt, pvalue->elem[xx1]);
      invokeEndElement (pctxt, "elem", xx1);

   }

   return (stat);
}

EXTERN int asn1PD_H245RTPH263VideoRedundancyEncoding (OOCTXT* pctxt, H245RTPH263VideoRedundancyEncoding* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.containedThreadsPresent = optbit;

   /* decode root elements */
   /* decode numberOfThreads */
   invokeStartElement (pctxt, "numberOfThreads", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->numberOfThreads, 1, 16);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->numberOfThreads);
   invokeEndElement (pctxt, "numberOfThreads", -1);

   /* decode framesBetweenSyncPoints */
   invokeStartElement (pctxt, "framesBetweenSyncPoints", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->framesBetweenSyncPoints, 1, 256);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->framesBetweenSyncPoints);
   invokeEndElement (pctxt, "framesBetweenSyncPoints", -1);

   /* decode frameToThreadMapping */
   invokeStartElement (pctxt, "frameToThreadMapping", -1);

   stat = asn1PD_H245RTPH263VideoRedundancyEncoding_frameToThreadMapping (pctxt, &pvalue->frameToThreadMapping);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "frameToThreadMapping", -1);

   /* decode containedThreads */
   if (pvalue->m.containedThreadsPresent) {
      invokeStartElement (pctxt, "containedThreads", -1);

      stat = asn1PD_H245RTPH263VideoRedundancyEncoding_containedThreads (pctxt, &pvalue->containedThreads);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "containedThreads", -1);

   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245RedundancyEncodingMethod (OOCTXT* pctxt, H245RedundancyEncodingMethod* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            invokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = memAllocTypeZ (pctxt,
               H245NonStandardParameter);

            stat = asn1PD_H245NonStandardParameter (pctxt, pvalue->u.nonStandard);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* rtpAudioRedundancyEncoding */
         case 1:
            invokeStartElement (pctxt, "rtpAudioRedundancyEncoding", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "rtpAudioRedundancyEncoding", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt,
         (ASN1OCTET*)openType.data, openType.numocts);

      switch (pvalue->t) {
         /* rtpH263VideoRedundancyEncoding */
         case 3:
            invokeStartElement (pctxt, "rtpH263VideoRedundancyEncoding", -1);

            pvalue->u.rtpH263VideoRedundancyEncoding
                = memAllocTypeZ (pctxt,
               H245RTPH263VideoRedundancyEncoding);

            stat = asn1PD_H245RTPH263VideoRedundancyEncoding (pctxt, pvalue->u.rtpH263VideoRedundancyEncoding);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "rtpH263VideoRedundancyEncoding", -1);

            break;

         default:;
      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

EXTERN int asn1PD_H245RedundancyEncodingCapability_secondaryEncoding (OOCTXT* pctxt, H245RedundancyEncodingCapability_secondaryEncoding* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 256, 0 };
   int stat = 0;
   OOUINT32 xx1 = 0;

   /* decode length determinant */

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeLength (pctxt, &pvalue->n);
   if (stat != 0) return stat;

   /* decode elements */

   if (256 < pvalue->n) {
      return stat;
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      invokeStartElement (pctxt, "elem", xx1);

      stat = asn1PD_H245CapabilityTableEntryNumber (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "elem", xx1);

   }

   return (stat);
}

EXTERN int asn1PD_H245RedundancyEncodingCapability (OOCTXT* pctxt, H245RedundancyEncodingCapability* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.secondaryEncodingPresent = optbit;

   /* decode root elements */
   /* decode redundancyEncodingMethod */
   invokeStartElement (pctxt, "redundancyEncodingMethod", -1);

   stat = asn1PD_H245RedundancyEncodingMethod (pctxt, &pvalue->redundancyEncodingMethod);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "redundancyEncodingMethod", -1);

   /* decode primaryEncoding */
   invokeStartElement (pctxt, "primaryEncoding", -1);

   stat = asn1PD_H245CapabilityTableEntryNumber (pctxt, &pvalue->primaryEncoding);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "primaryEncoding", -1);

   /* decode secondaryEncoding */
   if (pvalue->m.secondaryEncodingPresent) {
      invokeStartElement (pctxt, "secondaryEncoding", -1);

      stat = asn1PD_H245RedundancyEncodingCapability_secondaryEncoding (pctxt, &pvalue->secondaryEncoding);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "secondaryEncoding", -1);

   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245H2250Capability_redundancyEncodingCapability (OOCTXT* pctxt, H245H2250Capability_redundancyEncodingCapability* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 256, 0 };
   int stat = 0;
   H245RedundancyEncodingCapability* pdata;
   DListNode* pnode;
   OOUINT32 count = 0;
   OOUINT32 xx1 = 0;

   /* decode length determinant */

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeLength (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      invokeStartElement (pctxt, "elem", xx1);

      dListAllocNodeAndData (pctxt, H245RedundancyEncodingCapability, &pnode, &pdata);

      stat = asn1PD_H245RedundancyEncodingCapability (pctxt, pdata);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "elem", xx1);

      dListAppendNode2 (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1PD_H245H2250Capability (OOCTXT* pctxt, H245H2250Capability* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   /* decode root elements */
   /* decode maximumAudioDelayJitter */
   invokeStartElement (pctxt, "maximumAudioDelayJitter", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->maximumAudioDelayJitter, 0, 1023);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->maximumAudioDelayJitter);
   invokeEndElement (pctxt, "maximumAudioDelayJitter", -1);

   /* decode receiveMultipointCapability */
   invokeStartElement (pctxt, "receiveMultipointCapability", -1);

   stat = asn1PD_H245MultipointCapability (pctxt, &pvalue->receiveMultipointCapability);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "receiveMultipointCapability", -1);

   /* decode transmitMultipointCapability */
   invokeStartElement (pctxt, "transmitMultipointCapability", -1);

   stat = asn1PD_H245MultipointCapability (pctxt, &pvalue->transmitMultipointCapability);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "transmitMultipointCapability", -1);

   /* decode receiveAndTransmitMultipointCapability */
   invokeStartElement (pctxt, "receiveAndTransmitMultipointCapability", -1);

   stat = asn1PD_H245MultipointCapability (pctxt, &pvalue->receiveAndTransmitMultipointCapability);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "receiveAndTransmitMultipointCapability", -1);

   /* decode mcCapability */
   invokeStartElement (pctxt, "mcCapability", -1);

   stat = asn1PD_H245H2250Capability_mcCapability (pctxt, &pvalue->mcCapability);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "mcCapability", -1);

   /* decode rtcpVideoControlCapability */
   invokeStartElement (pctxt, "rtcpVideoControlCapability", -1);

   stat = DECODEBIT (pctxt, &pvalue->rtcpVideoControlCapability);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->rtcpVideoControlCapability);
   invokeEndElement (pctxt, "rtcpVideoControlCapability", -1);

   /* decode mediaPacketizationCapability */
   invokeStartElement (pctxt, "mediaPacketizationCapability", -1);

   stat = asn1PD_H245MediaPacketizationCapability (pctxt, &pvalue->mediaPacketizationCapability);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "mediaPacketizationCapability", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return stat;

            if (i < 4) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt,
                  (ASN1OCTET*)openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     if (openType.numocts == 0) break;

                     pvalue->m.transportCapabilityPresent = 1;

                     invokeStartElement (pctxt, "transportCapability", -1);

                     stat = asn1PD_H245TransportCapability (pctxt, &pvalue->transportCapability);
                     if (stat != 0) return stat;

                     invokeEndElement (pctxt, "transportCapability", -1);

                     break;

                  case 1:
                     if (openType.numocts == 0) break;

                     pvalue->m.redundancyEncodingCapabilityPresent = 1;

                     invokeStartElement (pctxt, "redundancyEncodingCapability", -1);

                     stat = asn1PD_H245H2250Capability_redundancyEncodingCapability (pctxt, &pvalue->redundancyEncodingCapability);
                     if (stat != 0) return stat;

                     invokeEndElement (pctxt, "redundancyEncodingCapability", -1);

                     break;

                  case 2:
                     if (openType.numocts == 0) break;

                     pvalue->m.logicalChannelSwitchingCapabilityPresent = 1;

                     invokeStartElement (pctxt, "logicalChannelSwitchingCapability", -1);

                     stat = DECODEBIT (pctxt, &pvalue->logicalChannelSwitchingCapability);
                     if (stat != 0) return stat;

                     invokeBoolValue (pctxt, pvalue->logicalChannelSwitchingCapability);
                     invokeEndElement (pctxt, "logicalChannelSwitchingCapability", -1);

                     break;

                  case 3:
                     if (openType.numocts == 0) break;

                     pvalue->m.t120DynamicPortCapabilityPresent = 1;

                     invokeStartElement (pctxt, "t120DynamicPortCapability", -1);

                     stat = DECODEBIT (pctxt, &pvalue->t120DynamicPortCapability);
                     if (stat != 0) return stat;

                     invokeBoolValue (pctxt, pvalue->t120DynamicPortCapability);
                     invokeEndElement (pctxt, "t120DynamicPortCapability", -1);

                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245MultiplexCapability (OOCTXT* pctxt, H245MultiplexCapability* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 3);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            invokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = memAllocTypeZ (pctxt,
               H245NonStandardParameter);

            stat = asn1PD_H245NonStandardParameter (pctxt, pvalue->u.nonStandard);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* h222Capability */
         case 1:
            invokeStartElement (pctxt, "h222Capability", -1);

            pvalue->u.h222Capability = memAllocTypeZ (pctxt,
               H245H222Capability);

            stat = asn1PD_H245H222Capability (pctxt, pvalue->u.h222Capability);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "h222Capability", -1);

            break;

         /* h223Capability */
         case 2:
            invokeStartElement (pctxt, "h223Capability", -1);

            pvalue->u.h223Capability = memAllocTypeZ (pctxt,
               H245H223Capability);

            stat = asn1PD_H245H223Capability (pctxt, pvalue->u.h223Capability);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "h223Capability", -1);

            break;

         /* v76Capability */
         case 3:
            invokeStartElement (pctxt, "v76Capability", -1);

            pvalue->u.v76Capability = memAllocTypeZ (pctxt,
               H245V76Capability);

            stat = asn1PD_H245V76Capability (pctxt, pvalue->u.v76Capability);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "v76Capability", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 5;

      if (pvalue->t < 5) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt,
         (ASN1OCTET*)openType.data, openType.numocts);

      switch (pvalue->t) {
         /* h2250Capability */
         case 5:
            invokeStartElement (pctxt, "h2250Capability", -1);

            pvalue->u.h2250Capability = memAllocTypeZ (pctxt,
               H245H2250Capability);

            stat = asn1PD_H245H2250Capability (pctxt, pvalue->u.h2250Capability);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "h2250Capability", -1);

            break;

         /* genericMultiplexCapability */
         case 6:
            invokeStartElement (pctxt, "genericMultiplexCapability", -1);

            pvalue->u.genericMultiplexCapability = memAllocTypeZ (pctxt,
               H245GenericCapability);

            stat = asn1PD_H245GenericCapability (pctxt, pvalue->u.genericMultiplexCapability);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "genericMultiplexCapability", -1);

            break;

         default:;
      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

EXTERN int asn1PD_H245H261VideoCapability (OOCTXT* pctxt, H245H261VideoCapability* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.qcifMPIPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.cifMPIPresent = optbit;

   /* decode root elements */
   /* decode qcifMPI */
   if (pvalue->m.qcifMPIPresent) {
      invokeStartElement (pctxt, "qcifMPI", -1);

      stat = decodeConsUInt8 (pctxt, &pvalue->qcifMPI, 1, 4);
      if (stat != 0) return stat;

      invokeUIntValue (pctxt, pvalue->qcifMPI);
      invokeEndElement (pctxt, "qcifMPI", -1);

   }

   /* decode cifMPI */
   if (pvalue->m.cifMPIPresent) {
      invokeStartElement (pctxt, "cifMPI", -1);

      stat = decodeConsUInt8 (pctxt, &pvalue->cifMPI, 1, 4);
      if (stat != 0) return stat;

      invokeUIntValue (pctxt, pvalue->cifMPI);
      invokeEndElement (pctxt, "cifMPI", -1);

   }

   /* decode temporalSpatialTradeOffCapability */
   invokeStartElement (pctxt, "temporalSpatialTradeOffCapability", -1);

   stat = DECODEBIT (pctxt, &pvalue->temporalSpatialTradeOffCapability);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->temporalSpatialTradeOffCapability);
   invokeEndElement (pctxt, "temporalSpatialTradeOffCapability", -1);

   /* decode maxBitRate */
   invokeStartElement (pctxt, "maxBitRate", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->maxBitRate, 1, 19200);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->maxBitRate);
   invokeEndElement (pctxt, "maxBitRate", -1);

   /* decode stillImageTransmission */
   invokeStartElement (pctxt, "stillImageTransmission", -1);

   stat = DECODEBIT (pctxt, &pvalue->stillImageTransmission);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->stillImageTransmission);
   invokeEndElement (pctxt, "stillImageTransmission", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return stat;

            if (i < 1) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt,
                  (ASN1OCTET*)openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     if (openType.numocts == 0) break;

                     pvalue->m.videoBadMBsCapPresent = 1;

                     invokeStartElement (pctxt, "videoBadMBsCap", -1);

                     stat = DECODEBIT (pctxt, &pvalue->videoBadMBsCap);
                     if (stat != 0) return stat;

                     invokeBoolValue (pctxt, pvalue->videoBadMBsCap);
                     invokeEndElement (pctxt, "videoBadMBsCap", -1);

                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245H262VideoCapability (OOCTXT* pctxt, H245H262VideoCapability* pvalue)
{
   int stat = 0;
   OOUINT32 i;
   OOUINT32 j = 0;
   OOBOOL optbits[6];

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   for (i = 0; i < 6; i++) {
      stat = DECODEBIT (pctxt, &optbits[i]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i = 0; i < 18; i++) {
      switch (i) {
         case 0:
         /* decode profileAndLevel_SPatML */
         invokeStartElement (pctxt, "profileAndLevel_SPatML", -1);

         stat = DECODEBIT (pctxt, &pvalue->profileAndLevel_SPatML);

         invokeBoolValue (pctxt, pvalue->profileAndLevel_SPatML);
         invokeEndElement (pctxt, "profileAndLevel_SPatML", -1);

         break;

         case 1:
         /* decode profileAndLevel_MPatLL */
         invokeStartElement (pctxt, "profileAndLevel_MPatLL", -1);

         stat = DECODEBIT (pctxt, &pvalue->profileAndLevel_MPatLL);

         invokeBoolValue (pctxt, pvalue->profileAndLevel_MPatLL);
         invokeEndElement (pctxt, "profileAndLevel_MPatLL", -1);

         break;

         case 2:
         /* decode profileAndLevel_MPatML */
         invokeStartElement (pctxt, "profileAndLevel_MPatML", -1);

         stat = DECODEBIT (pctxt, &pvalue->profileAndLevel_MPatML);

         invokeBoolValue (pctxt, pvalue->profileAndLevel_MPatML);
         invokeEndElement (pctxt, "profileAndLevel_MPatML", -1);

         break;

         case 3:
         /* decode profileAndLevel_MPatH_14 */
         invokeStartElement (pctxt, "profileAndLevel_MPatH_14", -1);

         stat = DECODEBIT (pctxt, &pvalue->profileAndLevel_MPatH_14);

         invokeBoolValue (pctxt, pvalue->profileAndLevel_MPatH_14);
         invokeEndElement (pctxt, "profileAndLevel_MPatH_14", -1);

         break;

         case 4:
         /* decode profileAndLevel_MPatHL */
         invokeStartElement (pctxt, "profileAndLevel_MPatHL", -1);

         stat = DECODEBIT (pctxt, &pvalue->profileAndLevel_MPatHL);

         invokeBoolValue (pctxt, pvalue->profileAndLevel_MPatHL);
         invokeEndElement (pctxt, "profileAndLevel_MPatHL", -1);

         break;

         case 5:
         /* decode profileAndLevel_SNRatLL */
         invokeStartElement (pctxt, "profileAndLevel_SNRatLL", -1);

         stat = DECODEBIT (pctxt, &pvalue->profileAndLevel_SNRatLL);

         invokeBoolValue (pctxt, pvalue->profileAndLevel_SNRatLL);
         invokeEndElement (pctxt, "profileAndLevel_SNRatLL", -1);

         break;

         case 6:
         /* decode profileAndLevel_SNRatML */
         invokeStartElement (pctxt, "profileAndLevel_SNRatML", -1);

         stat = DECODEBIT (pctxt, &pvalue->profileAndLevel_SNRatML);

         invokeBoolValue (pctxt, pvalue->profileAndLevel_SNRatML);
         invokeEndElement (pctxt, "profileAndLevel_SNRatML", -1);

         break;

         case 7:
         /* decode profileAndLevel_SpatialatH_14 */
         invokeStartElement (pctxt, "profileAndLevel_SpatialatH_14", -1);

         stat = DECODEBIT (pctxt, &pvalue->profileAndLevel_SpatialatH_14);

         invokeBoolValue (pctxt, pvalue->profileAndLevel_SpatialatH_14);
         invokeEndElement (pctxt, "profileAndLevel_SpatialatH_14", -1);

         break;

         case 8:
         /* decode profileAndLevel_HPatML */
         invokeStartElement (pctxt, "profileAndLevel_HPatML", -1);

         stat = DECODEBIT (pctxt, &pvalue->profileAndLevel_HPatML);

         invokeBoolValue (pctxt, pvalue->profileAndLevel_HPatML);
         invokeEndElement (pctxt, "profileAndLevel_HPatML", -1);

         break;

         case 9:
         /* decode profileAndLevel_HPatH_14 */
         invokeStartElement (pctxt, "profileAndLevel_HPatH_14", -1);

         stat = DECODEBIT (pctxt, &pvalue->profileAndLevel_HPatH_14);

         invokeBoolValue (pctxt, pvalue->profileAndLevel_HPatH_14);
         invokeEndElement (pctxt, "profileAndLevel_HPatH_14", -1);

         break;

         case 10:
         /* decode profileAndLevel_HPatHL */
         invokeStartElement (pctxt, "profileAndLevel_HPatHL", -1);

         stat = DECODEBIT (pctxt, &pvalue->profileAndLevel_HPatHL);

         invokeBoolValue (pctxt, pvalue->profileAndLevel_HPatHL);
         invokeEndElement (pctxt, "profileAndLevel_HPatHL", -1);

         break;

         case 11:
         /* decode videoBitRate */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "videoBitRate", -1);

            stat = decodeConsUnsigned (pctxt, &pvalue->videoBitRate, 0, 1073741823);

            invokeUIntValue (pctxt, pvalue->videoBitRate);
            pvalue->m.videoBitRatePresent = 1;
            invokeEndElement (pctxt, "videoBitRate", -1);

         }
         break;

         case 12:
         /* decode vbvBufferSize */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "vbvBufferSize", -1);

            stat = decodeConsUnsigned (pctxt, &pvalue->vbvBufferSize, 0, 262143);

            invokeUIntValue (pctxt, pvalue->vbvBufferSize);
            pvalue->m.vbvBufferSizePresent = 1;
            invokeEndElement (pctxt, "vbvBufferSize", -1);

         }
         break;

         case 13:
         /* decode samplesPerLine */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "samplesPerLine", -1);

            stat = decodeConsUInt16 (pctxt, &pvalue->samplesPerLine, 0, 16383);

            invokeUIntValue (pctxt, pvalue->samplesPerLine);
            pvalue->m.samplesPerLinePresent = 1;
            invokeEndElement (pctxt, "samplesPerLine", -1);

         }
         break;

         case 14:
         /* decode linesPerFrame */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "linesPerFrame", -1);

            stat = decodeConsUInt16 (pctxt, &pvalue->linesPerFrame, 0, 16383);

            invokeUIntValue (pctxt, pvalue->linesPerFrame);
            pvalue->m.linesPerFramePresent = 1;
            invokeEndElement (pctxt, "linesPerFrame", -1);

         }
         break;

         case 15:
         /* decode framesPerSecond */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "framesPerSecond", -1);

            stat = decodeConsUInt8 (pctxt, &pvalue->framesPerSecond, 0, 15);

            invokeUIntValue (pctxt, pvalue->framesPerSecond);
            pvalue->m.framesPerSecondPresent = 1;
            invokeEndElement (pctxt, "framesPerSecond", -1);

         }
         break;

         case 16:
         /* decode luminanceSampleRate */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "luminanceSampleRate", -1);

            stat = decodeConsUnsigned (pctxt, &pvalue->luminanceSampleRate, 0, OOUINT32_MAX);

            invokeUIntValue (pctxt, pvalue->luminanceSampleRate);
            pvalue->m.luminanceSampleRatePresent = 1;
            invokeEndElement (pctxt, "luminanceSampleRate", -1);

         }
         break;

         case 17:
         /* decode videoBadMBsCap */
         invokeStartElement (pctxt, "videoBadMBsCap", -1);

         stat = DECODEBIT (pctxt, &pvalue->videoBadMBsCap);

         invokeBoolValue (pctxt, pvalue->videoBadMBsCap);
         invokeEndElement (pctxt, "videoBadMBsCap", -1);

         break;

         default: j++;
      }
      if (0 != stat) return stat;
   }

   return (stat);
}

EXTERN int asn1PD_H245TransparencyParameters (OOCTXT* pctxt, H245TransparencyParameters* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode presentationOrder */
   invokeStartElement (pctxt, "presentationOrder", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->presentationOrder, 1, 256);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->presentationOrder);
   invokeEndElement (pctxt, "presentationOrder", -1);

   /* decode offset_x */
   invokeStartElement (pctxt, "offset_x", -1);

   stat = decodeConsInteger (pctxt, &pvalue->offset_x, -262144, 262143);
   if (stat != 0) return stat;

   invokeIntValue (pctxt, pvalue->offset_x);
   invokeEndElement (pctxt, "offset_x", -1);

   /* decode offset_y */
   invokeStartElement (pctxt, "offset_y", -1);

   stat = decodeConsInteger (pctxt, &pvalue->offset_y, -262144, 262143);
   if (stat != 0) return stat;

   invokeIntValue (pctxt, pvalue->offset_y);
   invokeEndElement (pctxt, "offset_y", -1);

   /* decode scale_x */
   invokeStartElement (pctxt, "scale_x", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->scale_x, 1, 255);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->scale_x);
   invokeEndElement (pctxt, "scale_x", -1);

   /* decode scale_y */
   invokeStartElement (pctxt, "scale_y", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->scale_y, 1, 255);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->scale_y);
   invokeEndElement (pctxt, "scale_y", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245RefPictureSelection_additionalPictureMemory (OOCTXT* pctxt, H245RefPictureSelection_additionalPictureMemory* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;
   OOUINT32 j = 0;
   OOBOOL optbits[6];

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   for (i = 0; i < 6; i++) {
      stat = DECODEBIT (pctxt, &optbits[i]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i = 0; i < 6; i++) {
      switch (i) {
         case 0:
         /* decode sqcifAdditionalPictureMemory */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "sqcifAdditionalPictureMemory", -1);

            stat = decodeConsUInt16 (pctxt, &pvalue->sqcifAdditionalPictureMemory, 1, 256);

            invokeUIntValue (pctxt, pvalue->sqcifAdditionalPictureMemory);
            pvalue->m.sqcifAdditionalPictureMemoryPresent = 1;
            invokeEndElement (pctxt, "sqcifAdditionalPictureMemory", -1);

         }
         break;

         case 1:
         /* decode qcifAdditionalPictureMemory */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "qcifAdditionalPictureMemory", -1);

            stat = decodeConsUInt16 (pctxt, &pvalue->qcifAdditionalPictureMemory, 1, 256);

            invokeUIntValue (pctxt, pvalue->qcifAdditionalPictureMemory);
            pvalue->m.qcifAdditionalPictureMemoryPresent = 1;
            invokeEndElement (pctxt, "qcifAdditionalPictureMemory", -1);

         }
         break;

         case 2:
         /* decode cifAdditionalPictureMemory */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "cifAdditionalPictureMemory", -1);

            stat = decodeConsUInt16 (pctxt, &pvalue->cifAdditionalPictureMemory, 1, 256);

            invokeUIntValue (pctxt, pvalue->cifAdditionalPictureMemory);
            pvalue->m.cifAdditionalPictureMemoryPresent = 1;
            invokeEndElement (pctxt, "cifAdditionalPictureMemory", -1);

         }
         break;

         case 3:
         /* decode cif4AdditionalPictureMemory */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "cif4AdditionalPictureMemory", -1);

            stat = decodeConsUInt16 (pctxt, &pvalue->cif4AdditionalPictureMemory, 1, 256);

            invokeUIntValue (pctxt, pvalue->cif4AdditionalPictureMemory);
            pvalue->m.cif4AdditionalPictureMemoryPresent = 1;
            invokeEndElement (pctxt, "cif4AdditionalPictureMemory", -1);

         }
         break;

         case 4:
         /* decode cif16AdditionalPictureMemory */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "cif16AdditionalPictureMemory", -1);

            stat = decodeConsUInt16 (pctxt, &pvalue->cif16AdditionalPictureMemory, 1, 256);

            invokeUIntValue (pctxt, pvalue->cif16AdditionalPictureMemory);
            pvalue->m.cif16AdditionalPictureMemoryPresent = 1;
            invokeEndElement (pctxt, "cif16AdditionalPictureMemory", -1);

         }
         break;

         case 5:
         /* decode bigCpfAdditionalPictureMemory */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "bigCpfAdditionalPictureMemory", -1);

            stat = decodeConsUInt16 (pctxt, &pvalue->bigCpfAdditionalPictureMemory, 1, 256);

            invokeUIntValue (pctxt, pvalue->bigCpfAdditionalPictureMemory);
            pvalue->m.bigCpfAdditionalPictureMemoryPresent = 1;
            invokeEndElement (pctxt, "bigCpfAdditionalPictureMemory", -1);

         }
         break;

         default: j++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245RefPictureSelection_videoBackChannelSend (OOCTXT* pctxt, H245RefPictureSelection_videoBackChannelSend* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 4);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* none */
         case 0:
            invokeStartElement (pctxt, "none", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "none", -1);

            break;

         /* ackMessageOnly */
         case 1:
            invokeStartElement (pctxt, "ackMessageOnly", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "ackMessageOnly", -1);

            break;

         /* nackMessageOnly */
         case 2:
            invokeStartElement (pctxt, "nackMessageOnly", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "nackMessageOnly", -1);

            break;

         /* ackOrNackMessageOnly */
         case 3:
            invokeStartElement (pctxt, "ackOrNackMessageOnly", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "ackOrNackMessageOnly", -1);

            break;

         /* ackAndNackMessage */
         case 4:
            invokeStartElement (pctxt, "ackAndNackMessage", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "ackAndNackMessage", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 6;

      if (pvalue->t < 6) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters (OOCTXT* pctxt, H245RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode mpuHorizMBs */
   invokeStartElement (pctxt, "mpuHorizMBs", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->mpuHorizMBs, 1, 128);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->mpuHorizMBs);
   invokeEndElement (pctxt, "mpuHorizMBs", -1);

   /* decode mpuVertMBs */
   invokeStartElement (pctxt, "mpuVertMBs", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->mpuVertMBs, 1, 72);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->mpuVertMBs);
   invokeEndElement (pctxt, "mpuVertMBs", -1);

   /* decode mpuTotalNumber */
   invokeStartElement (pctxt, "mpuTotalNumber", -1);

   stat = decodeConsUnsigned (pctxt, &pvalue->mpuTotalNumber, 1, 65536);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->mpuTotalNumber);
   invokeEndElement (pctxt, "mpuTotalNumber", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245RefPictureSelection_enhancedReferencePicSelect (OOCTXT* pctxt, H245RefPictureSelection_enhancedReferencePicSelect* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.subPictureRemovalParametersPresent = optbit;

   /* decode root elements */
   /* decode subPictureRemovalParameters */
   if (pvalue->m.subPictureRemovalParametersPresent) {
      invokeStartElement (pctxt, "subPictureRemovalParameters", -1);

      stat = asn1PD_H245RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters (pctxt, &pvalue->subPictureRemovalParameters);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "subPictureRemovalParameters", -1);

   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245RefPictureSelection (OOCTXT* pctxt, H245RefPictureSelection* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.additionalPictureMemoryPresent = optbit;

   /* decode root elements */
   /* decode additionalPictureMemory */
   if (pvalue->m.additionalPictureMemoryPresent) {
      invokeStartElement (pctxt, "additionalPictureMemory", -1);

      stat = asn1PD_H245RefPictureSelection_additionalPictureMemory (pctxt, &pvalue->additionalPictureMemory);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "additionalPictureMemory", -1);

   }

   /* decode videoMux */
   invokeStartElement (pctxt, "videoMux", -1);

   stat = DECODEBIT (pctxt, &pvalue->videoMux);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->videoMux);
   invokeEndElement (pctxt, "videoMux", -1);

   /* decode videoBackChannelSend */
   invokeStartElement (pctxt, "videoBackChannelSend", -1);

   stat = asn1PD_H245RefPictureSelection_videoBackChannelSend (pctxt, &pvalue->videoBackChannelSend);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "videoBackChannelSend", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return stat;

            if (i < 1) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt,
                  (ASN1OCTET*)openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     if (openType.numocts == 0) break;

                     pvalue->m.enhancedReferencePicSelectPresent = 1;

                     invokeStartElement (pctxt, "enhancedReferencePicSelect", -1);

                     stat = asn1PD_H245RefPictureSelection_enhancedReferencePicSelect (pctxt, &pvalue->enhancedReferencePicSelect);
                     if (stat != 0) return stat;

                     invokeEndElement (pctxt, "enhancedReferencePicSelect", -1);

                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245CustomPictureClockFrequency (OOCTXT* pctxt, H245CustomPictureClockFrequency* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;
   OOUINT32 j = 0;
   OOBOOL optbits[5];

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   for (i = 0; i < 5; i++) {
      stat = DECODEBIT (pctxt, &optbits[i]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i = 0; i < 7; i++) {
      switch (i) {
         case 0:
         /* decode clockConversionCode */
         invokeStartElement (pctxt, "clockConversionCode", -1);

         stat = decodeConsUInt16 (pctxt, &pvalue->clockConversionCode, 1000, 1001);

         invokeUIntValue (pctxt, pvalue->clockConversionCode);
         invokeEndElement (pctxt, "clockConversionCode", -1);

         break;

         case 1:
         /* decode clockDivisor */
         invokeStartElement (pctxt, "clockDivisor", -1);

         stat = decodeConsUInt8 (pctxt, &pvalue->clockDivisor, 1, 127);

         invokeUIntValue (pctxt, pvalue->clockDivisor);
         invokeEndElement (pctxt, "clockDivisor", -1);

         break;

         case 2:
         /* decode sqcifMPI */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "sqcifMPI", -1);

            stat = decodeConsUInt16 (pctxt, &pvalue->sqcifMPI, 1, 2048);

            invokeUIntValue (pctxt, pvalue->sqcifMPI);
            pvalue->m.sqcifMPIPresent = 1;
            invokeEndElement (pctxt, "sqcifMPI", -1);

         }
         break;

         case 3:
         /* decode qcifMPI */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "qcifMPI", -1);

            stat = decodeConsUInt16 (pctxt, &pvalue->qcifMPI, 1, 2048);

            invokeUIntValue (pctxt, pvalue->qcifMPI);
            pvalue->m.qcifMPIPresent = 1;
            invokeEndElement (pctxt, "qcifMPI", -1);

         }
         break;

         case 4:
         /* decode cifMPI */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "cifMPI", -1);

            stat = decodeConsUInt16 (pctxt, &pvalue->cifMPI, 1, 2048);

            invokeUIntValue (pctxt, pvalue->cifMPI);
            pvalue->m.cifMPIPresent = 1;
            invokeEndElement (pctxt, "cifMPI", -1);

         }
         break;

         case 5:
         /* decode cif4MPI */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "cif4MPI", -1);

            stat = decodeConsUInt16 (pctxt, &pvalue->cif4MPI, 1, 2048);

            invokeUIntValue (pctxt, pvalue->cif4MPI);
            pvalue->m.cif4MPIPresent = 1;
            invokeEndElement (pctxt, "cif4MPI", -1);

         }
         break;

         case 6:
         /* decode cif16MPI */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "cif16MPI", -1);

            stat = decodeConsUInt16 (pctxt, &pvalue->cif16MPI, 1, 2048);

            invokeUIntValue (pctxt, pvalue->cif16MPI);
            pvalue->m.cif16MPIPresent = 1;
            invokeEndElement (pctxt, "cif16MPI", -1);

         }
         break;

         default: j++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245H263Options_customPictureClockFrequency (OOCTXT* pctxt, H245H263Options_customPictureClockFrequency* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 16, 0 };
   int stat = 0;
   H245CustomPictureClockFrequency* pdata;
   DListNode* pnode;
   OOUINT32 count = 0;
   OOUINT32 xx1 = 0;

   /* decode length determinant */

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeLength (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      invokeStartElement (pctxt, "elem", xx1);

      dListAllocNodeAndData (pctxt, H245CustomPictureClockFrequency, &pnode, &pdata);

      stat = asn1PD_H245CustomPictureClockFrequency (pctxt, pdata);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "elem", xx1);

      dListAppendNode2 (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1PD_H245CustomPictureFormat_mPI_customPCF_element (OOCTXT* pctxt, H245CustomPictureFormat_mPI_customPCF_element* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode clockConversionCode */
   invokeStartElement (pctxt, "clockConversionCode", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->clockConversionCode, 1000, 1001);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->clockConversionCode);
   invokeEndElement (pctxt, "clockConversionCode", -1);

   /* decode clockDivisor */
   invokeStartElement (pctxt, "clockDivisor", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->clockDivisor, 1, 127);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->clockDivisor);
   invokeEndElement (pctxt, "clockDivisor", -1);

   /* decode customMPI */
   invokeStartElement (pctxt, "customMPI", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->customMPI, 1, 2048);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->customMPI);
   invokeEndElement (pctxt, "customMPI", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245CustomPictureFormat_mPI_customPCF (OOCTXT* pctxt, H245CustomPictureFormat_mPI_customPCF* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 16, 0 };
   int stat = 0;
   H245CustomPictureFormat_mPI_customPCF_element* pdata;
   DListNode* pnode;
   OOUINT32 count = 0;
   OOUINT32 xx1 = 0;

   /* decode length determinant */

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeLength (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      invokeStartElement (pctxt, "elem", xx1);

      dListAllocNodeAndData (pctxt, H245CustomPictureFormat_mPI_customPCF_element, &pnode, &pdata);

      stat = asn1PD_H245CustomPictureFormat_mPI_customPCF_element (pctxt, pdata);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "elem", xx1);

      dListAppendNode2 (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1PD_H245CustomPictureFormat_mPI (OOCTXT* pctxt, H245CustomPictureFormat_mPI* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.standardMPIPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.customPCFPresent = optbit;

   /* decode root elements */
   /* decode standardMPI */
   if (pvalue->m.standardMPIPresent) {
      invokeStartElement (pctxt, "standardMPI", -1);

      stat = decodeConsUInt8 (pctxt, &pvalue->standardMPI, 1, 31);
      if (stat != 0) return stat;

      invokeUIntValue (pctxt, pvalue->standardMPI);
      invokeEndElement (pctxt, "standardMPI", -1);

   }

   /* decode customPCF */
   if (pvalue->m.customPCFPresent) {
      invokeStartElement (pctxt, "customPCF", -1);

      stat = asn1PD_H245CustomPictureFormat_mPI_customPCF (pctxt, &pvalue->customPCF);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "customPCF", -1);

   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245CustomPictureFormat_pixelAspectInformation_pixelAspectCode (OOCTXT* pctxt, H245CustomPictureFormat_pixelAspectInformation_pixelAspectCode* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 14, 0 };
   int stat = 0;
   OOUINT32 xx1 = 0;

   /* decode length determinant */

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeLength (pctxt, &pvalue->n);
   if (stat != 0) return stat;

   /* decode elements */

   if (14 < pvalue->n) {
      return stat;
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      invokeStartElement (pctxt, "elem", xx1);

      stat = decodeConsUInt8 (pctxt, &pvalue->elem[xx1], 1, 14);
      if (stat != 0) return stat;

      invokeUIntValue (pctxt, pvalue->elem[xx1]);
      invokeEndElement (pctxt, "elem", xx1);

   }

   return (stat);
}

EXTERN int asn1PD_H245CustomPictureFormat_pixelAspectInformation_extendedPAR_element (OOCTXT* pctxt, H245CustomPictureFormat_pixelAspectInformation_extendedPAR_element* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode width */
   invokeStartElement (pctxt, "width", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->width, 1, 255);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->width);
   invokeEndElement (pctxt, "width", -1);

   /* decode height */
   invokeStartElement (pctxt, "height", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->height, 1, 255);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->height);
   invokeEndElement (pctxt, "height", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245CustomPictureFormat_pixelAspectInformation_extendedPAR (OOCTXT* pctxt, H245CustomPictureFormat_pixelAspectInformation_extendedPAR* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 256, 0 };
   int stat = 0;
   H245CustomPictureFormat_pixelAspectInformation_extendedPAR_element* pdata;
   DListNode* pnode;
   OOUINT32 count = 0;
   OOUINT32 xx1 = 0;

   /* decode length determinant */

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeLength (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      invokeStartElement (pctxt, "elem", xx1);

      dListAllocNodeAndData (pctxt, H245CustomPictureFormat_pixelAspectInformation_extendedPAR_element, &pnode, &pdata);

      stat = asn1PD_H245CustomPictureFormat_pixelAspectInformation_extendedPAR_element (pctxt, pdata);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "elem", xx1);

      dListAppendNode2 (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1PD_H245CustomPictureFormat_pixelAspectInformation (OOCTXT* pctxt, H245CustomPictureFormat_pixelAspectInformation* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* anyPixelAspectRatio */
         case 0:
            invokeStartElement (pctxt, "anyPixelAspectRatio", -1);

            stat = DECODEBIT (pctxt, &pvalue->u.anyPixelAspectRatio);
            if (stat != 0) return stat;

            invokeBoolValue (pctxt, pvalue->u.anyPixelAspectRatio);
            invokeEndElement (pctxt, "anyPixelAspectRatio", -1);

            break;

         /* pixelAspectCode */
         case 1:
            invokeStartElement (pctxt, "pixelAspectCode", -1);

            pvalue->u.pixelAspectCode = memAllocTypeZ (pctxt,
               H245CustomPictureFormat_pixelAspectInformation_pixelAspectCode);

            stat = asn1PD_H245CustomPictureFormat_pixelAspectInformation_pixelAspectCode (pctxt, pvalue->u.pixelAspectCode);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "pixelAspectCode", -1);

            break;

         /* extendedPAR */
         case 2:
            invokeStartElement (pctxt, "extendedPAR", -1);

            pvalue->u.extendedPAR = memAllocTypeZ (pctxt,
               H245CustomPictureFormat_pixelAspectInformation_extendedPAR);

            stat = asn1PD_H245CustomPictureFormat_pixelAspectInformation_extendedPAR (pctxt, pvalue->u.extendedPAR);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "extendedPAR", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 4;

      if (pvalue->t < 4) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245CustomPictureFormat (OOCTXT* pctxt, H245CustomPictureFormat* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode maxCustomPictureWidth */
   invokeStartElement (pctxt, "maxCustomPictureWidth", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->maxCustomPictureWidth, 1, 2048);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->maxCustomPictureWidth);
   invokeEndElement (pctxt, "maxCustomPictureWidth", -1);

   /* decode maxCustomPictureHeight */
   invokeStartElement (pctxt, "maxCustomPictureHeight", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->maxCustomPictureHeight, 1, 2048);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->maxCustomPictureHeight);
   invokeEndElement (pctxt, "maxCustomPictureHeight", -1);

   /* decode minCustomPictureWidth */
   invokeStartElement (pctxt, "minCustomPictureWidth", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->minCustomPictureWidth, 1, 2048);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->minCustomPictureWidth);
   invokeEndElement (pctxt, "minCustomPictureWidth", -1);

   /* decode minCustomPictureHeight */
   invokeStartElement (pctxt, "minCustomPictureHeight", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->minCustomPictureHeight, 1, 2048);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->minCustomPictureHeight);
   invokeEndElement (pctxt, "minCustomPictureHeight", -1);

   /* decode mPI */
   invokeStartElement (pctxt, "mPI", -1);

   stat = asn1PD_H245CustomPictureFormat_mPI (pctxt, &pvalue->mPI);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "mPI", -1);

   /* decode pixelAspectInformation */
   invokeStartElement (pctxt, "pixelAspectInformation", -1);

   stat = asn1PD_H245CustomPictureFormat_pixelAspectInformation (pctxt, &pvalue->pixelAspectInformation);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "pixelAspectInformation", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245H263Options_customPictureFormat (OOCTXT* pctxt, H245H263Options_customPictureFormat* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 16, 0 };
   int stat = 0;
   H245CustomPictureFormat* pdata;
   DListNode* pnode;
   OOUINT32 count = 0;
   OOUINT32 xx1 = 0;

   /* decode length determinant */

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeLength (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      invokeStartElement (pctxt, "elem", xx1);

      dListAllocNodeAndData (pctxt, H245CustomPictureFormat, &pnode, &pdata);

      stat = asn1PD_H245CustomPictureFormat (pctxt, pdata);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "elem", xx1);

      dListAppendNode2 (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1PD_H245H263Version3Options (OOCTXT* pctxt, H245H263Version3Options* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode dataPartitionedSlices */
   invokeStartElement (pctxt, "dataPartitionedSlices", -1);

   stat = DECODEBIT (pctxt, &pvalue->dataPartitionedSlices);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->dataPartitionedSlices);
   invokeEndElement (pctxt, "dataPartitionedSlices", -1);

   /* decode fixedPointIDCT0 */
   invokeStartElement (pctxt, "fixedPointIDCT0", -1);

   stat = DECODEBIT (pctxt, &pvalue->fixedPointIDCT0);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->fixedPointIDCT0);
   invokeEndElement (pctxt, "fixedPointIDCT0", -1);

   /* decode interlacedFields */
   invokeStartElement (pctxt, "interlacedFields", -1);

   stat = DECODEBIT (pctxt, &pvalue->interlacedFields);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->interlacedFields);
   invokeEndElement (pctxt, "interlacedFields", -1);

   /* decode currentPictureHeaderRepetition */
   invokeStartElement (pctxt, "currentPictureHeaderRepetition", -1);

   stat = DECODEBIT (pctxt, &pvalue->currentPictureHeaderRepetition);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->currentPictureHeaderRepetition);
   invokeEndElement (pctxt, "currentPictureHeaderRepetition", -1);

   /* decode previousPictureHeaderRepetition */
   invokeStartElement (pctxt, "previousPictureHeaderRepetition", -1);

   stat = DECODEBIT (pctxt, &pvalue->previousPictureHeaderRepetition);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->previousPictureHeaderRepetition);
   invokeEndElement (pctxt, "previousPictureHeaderRepetition", -1);

   /* decode nextPictureHeaderRepetition */
   invokeStartElement (pctxt, "nextPictureHeaderRepetition", -1);

   stat = DECODEBIT (pctxt, &pvalue->nextPictureHeaderRepetition);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->nextPictureHeaderRepetition);
   invokeEndElement (pctxt, "nextPictureHeaderRepetition", -1);

   /* decode pictureNumber */
   invokeStartElement (pctxt, "pictureNumber", -1);

   stat = DECODEBIT (pctxt, &pvalue->pictureNumber);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->pictureNumber);
   invokeEndElement (pctxt, "pictureNumber", -1);

   /* decode spareReferencePictures */
   invokeStartElement (pctxt, "spareReferencePictures", -1);

   stat = DECODEBIT (pctxt, &pvalue->spareReferencePictures);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->spareReferencePictures);
   invokeEndElement (pctxt, "spareReferencePictures", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245H263ModeComboFlags (OOCTXT* pctxt, H245H263ModeComboFlags* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode unrestrictedVector */
   invokeStartElement (pctxt, "unrestrictedVector", -1);

   stat = DECODEBIT (pctxt, &pvalue->unrestrictedVector);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->unrestrictedVector);
   invokeEndElement (pctxt, "unrestrictedVector", -1);

   /* decode arithmeticCoding */
   invokeStartElement (pctxt, "arithmeticCoding", -1);

   stat = DECODEBIT (pctxt, &pvalue->arithmeticCoding);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->arithmeticCoding);
   invokeEndElement (pctxt, "arithmeticCoding", -1);

   /* decode advancedPrediction */
   invokeStartElement (pctxt, "advancedPrediction", -1);

   stat = DECODEBIT (pctxt, &pvalue->advancedPrediction);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->advancedPrediction);
   invokeEndElement (pctxt, "advancedPrediction", -1);

   /* decode pbFrames */
   invokeStartElement (pctxt, "pbFrames", -1);

   stat = DECODEBIT (pctxt, &pvalue->pbFrames);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->pbFrames);
   invokeEndElement (pctxt, "pbFrames", -1);

   /* decode advancedIntraCodingMode */
   invokeStartElement (pctxt, "advancedIntraCodingMode", -1);

   stat = DECODEBIT (pctxt, &pvalue->advancedIntraCodingMode);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->advancedIntraCodingMode);
   invokeEndElement (pctxt, "advancedIntraCodingMode", -1);

   /* decode deblockingFilterMode */
   invokeStartElement (pctxt, "deblockingFilterMode", -1);

   stat = DECODEBIT (pctxt, &pvalue->deblockingFilterMode);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->deblockingFilterMode);
   invokeEndElement (pctxt, "deblockingFilterMode", -1);

   /* decode unlimitedMotionVectors */
   invokeStartElement (pctxt, "unlimitedMotionVectors", -1);

   stat = DECODEBIT (pctxt, &pvalue->unlimitedMotionVectors);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->unlimitedMotionVectors);
   invokeEndElement (pctxt, "unlimitedMotionVectors", -1);

   /* decode slicesInOrder_NonRect */
   invokeStartElement (pctxt, "slicesInOrder_NonRect", -1);

   stat = DECODEBIT (pctxt, &pvalue->slicesInOrder_NonRect);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->slicesInOrder_NonRect);
   invokeEndElement (pctxt, "slicesInOrder_NonRect", -1);

   /* decode slicesInOrder_Rect */
   invokeStartElement (pctxt, "slicesInOrder_Rect", -1);

   stat = DECODEBIT (pctxt, &pvalue->slicesInOrder_Rect);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->slicesInOrder_Rect);
   invokeEndElement (pctxt, "slicesInOrder_Rect", -1);

   /* decode slicesNoOrder_NonRect */
   invokeStartElement (pctxt, "slicesNoOrder_NonRect", -1);

   stat = DECODEBIT (pctxt, &pvalue->slicesNoOrder_NonRect);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->slicesNoOrder_NonRect);
   invokeEndElement (pctxt, "slicesNoOrder_NonRect", -1);

   /* decode slicesNoOrder_Rect */
   invokeStartElement (pctxt, "slicesNoOrder_Rect", -1);

   stat = DECODEBIT (pctxt, &pvalue->slicesNoOrder_Rect);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->slicesNoOrder_Rect);
   invokeEndElement (pctxt, "slicesNoOrder_Rect", -1);

   /* decode improvedPBFramesMode */
   invokeStartElement (pctxt, "improvedPBFramesMode", -1);

   stat = DECODEBIT (pctxt, &pvalue->improvedPBFramesMode);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->improvedPBFramesMode);
   invokeEndElement (pctxt, "improvedPBFramesMode", -1);

   /* decode referencePicSelect */
   invokeStartElement (pctxt, "referencePicSelect", -1);

   stat = DECODEBIT (pctxt, &pvalue->referencePicSelect);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->referencePicSelect);
   invokeEndElement (pctxt, "referencePicSelect", -1);

   /* decode dynamicPictureResizingByFour */
   invokeStartElement (pctxt, "dynamicPictureResizingByFour", -1);

   stat = DECODEBIT (pctxt, &pvalue->dynamicPictureResizingByFour);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->dynamicPictureResizingByFour);
   invokeEndElement (pctxt, "dynamicPictureResizingByFour", -1);

   /* decode dynamicPictureResizingSixteenthPel */
   invokeStartElement (pctxt, "dynamicPictureResizingSixteenthPel", -1);

   stat = DECODEBIT (pctxt, &pvalue->dynamicPictureResizingSixteenthPel);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->dynamicPictureResizingSixteenthPel);
   invokeEndElement (pctxt, "dynamicPictureResizingSixteenthPel", -1);

   /* decode dynamicWarpingHalfPel */
   invokeStartElement (pctxt, "dynamicWarpingHalfPel", -1);

   stat = DECODEBIT (pctxt, &pvalue->dynamicWarpingHalfPel);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->dynamicWarpingHalfPel);
   invokeEndElement (pctxt, "dynamicWarpingHalfPel", -1);

   /* decode dynamicWarpingSixteenthPel */
   invokeStartElement (pctxt, "dynamicWarpingSixteenthPel", -1);

   stat = DECODEBIT (pctxt, &pvalue->dynamicWarpingSixteenthPel);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->dynamicWarpingSixteenthPel);
   invokeEndElement (pctxt, "dynamicWarpingSixteenthPel", -1);

   /* decode reducedResolutionUpdate */
   invokeStartElement (pctxt, "reducedResolutionUpdate", -1);

   stat = DECODEBIT (pctxt, &pvalue->reducedResolutionUpdate);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->reducedResolutionUpdate);
   invokeEndElement (pctxt, "reducedResolutionUpdate", -1);

   /* decode independentSegmentDecoding */
   invokeStartElement (pctxt, "independentSegmentDecoding", -1);

   stat = DECODEBIT (pctxt, &pvalue->independentSegmentDecoding);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->independentSegmentDecoding);
   invokeEndElement (pctxt, "independentSegmentDecoding", -1);

   /* decode alternateInterVLCMode */
   invokeStartElement (pctxt, "alternateInterVLCMode", -1);

   stat = DECODEBIT (pctxt, &pvalue->alternateInterVLCMode);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->alternateInterVLCMode);
   invokeEndElement (pctxt, "alternateInterVLCMode", -1);

   /* decode modifiedQuantizationMode */
   invokeStartElement (pctxt, "modifiedQuantizationMode", -1);

   stat = DECODEBIT (pctxt, &pvalue->modifiedQuantizationMode);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->modifiedQuantizationMode);
   invokeEndElement (pctxt, "modifiedQuantizationMode", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return stat;

            if (i < 2) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt,
                  (ASN1OCTET*)openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     if (openType.numocts == 0) break;

                     pvalue->m.enhancedReferencePicSelectPresent = 1;

                     invokeStartElement (pctxt, "enhancedReferencePicSelect", -1);

                     stat = DECODEBIT (pctxt, &pvalue->enhancedReferencePicSelect);
                     if (stat != 0) return stat;

                     invokeBoolValue (pctxt, pvalue->enhancedReferencePicSelect);
                     invokeEndElement (pctxt, "enhancedReferencePicSelect", -1);

                     break;

                  case 1:
                     if (openType.numocts == 0) break;

                     pvalue->m.h263Version3OptionsPresent = 1;

                     invokeStartElement (pctxt, "h263Version3Options", -1);

                     stat = asn1PD_H245H263Version3Options (pctxt, &pvalue->h263Version3Options);
                     if (stat != 0) return stat;

                     invokeEndElement (pctxt, "h263Version3Options", -1);

                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245H263VideoModeCombos_h263VideoCoupledModes (OOCTXT* pctxt, H245H263VideoModeCombos_h263VideoCoupledModes* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 16, 0 };
   int stat = 0;
   H245H263ModeComboFlags* pdata;
   DListNode* pnode;
   OOUINT32 count = 0;
   OOUINT32 xx1 = 0;

   /* decode length determinant */

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeLength (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      invokeStartElement (pctxt, "elem", xx1);

      dListAllocNodeAndData (pctxt, H245H263ModeComboFlags, &pnode, &pdata);

      stat = asn1PD_H245H263ModeComboFlags (pctxt, pdata);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "elem", xx1);

      dListAppendNode2 (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1PD_H245H263VideoModeCombos (OOCTXT* pctxt, H245H263VideoModeCombos* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode h263VideoUncoupledModes */
   invokeStartElement (pctxt, "h263VideoUncoupledModes", -1);

   stat = asn1PD_H245H263ModeComboFlags (pctxt, &pvalue->h263VideoUncoupledModes);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "h263VideoUncoupledModes", -1);

   /* decode h263VideoCoupledModes */
   invokeStartElement (pctxt, "h263VideoCoupledModes", -1);

   stat = asn1PD_H245H263VideoModeCombos_h263VideoCoupledModes (pctxt, &pvalue->h263VideoCoupledModes);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "h263VideoCoupledModes", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245H263Options_modeCombos (OOCTXT* pctxt, H245H263Options_modeCombos* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 16, 0 };
   int stat = 0;
   H245H263VideoModeCombos* pdata;
   DListNode* pnode;
   OOUINT32 count = 0;
   OOUINT32 xx1 = 0;

   /* decode length determinant */

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeLength (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      invokeStartElement (pctxt, "elem", xx1);

      dListAllocNodeAndData (pctxt, H245H263VideoModeCombos, &pnode, &pdata);

      stat = asn1PD_H245H263VideoModeCombos (pctxt, pdata);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "elem", xx1);

      dListAppendNode2 (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1PD_H245H263Options (OOCTXT* pctxt, H245H263Options* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;
   OOUINT32 j = 0;
   OOBOOL optbits[5];

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   for (i = 0; i < 5; i++) {
      stat = DECODEBIT (pctxt, &optbits[i]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i = 0; i < 29; i++) {
      switch (i) {
         case 0:
         /* decode advancedIntraCodingMode */
         invokeStartElement (pctxt, "advancedIntraCodingMode", -1);

         stat = DECODEBIT (pctxt, &pvalue->advancedIntraCodingMode);

         invokeBoolValue (pctxt, pvalue->advancedIntraCodingMode);
         invokeEndElement (pctxt, "advancedIntraCodingMode", -1);

         break;

         case 1:
         /* decode deblockingFilterMode */
         invokeStartElement (pctxt, "deblockingFilterMode", -1);

         stat = DECODEBIT (pctxt, &pvalue->deblockingFilterMode);

         invokeBoolValue (pctxt, pvalue->deblockingFilterMode);
         invokeEndElement (pctxt, "deblockingFilterMode", -1);

         break;

         case 2:
         /* decode improvedPBFramesMode */
         invokeStartElement (pctxt, "improvedPBFramesMode", -1);

         stat = DECODEBIT (pctxt, &pvalue->improvedPBFramesMode);

         invokeBoolValue (pctxt, pvalue->improvedPBFramesMode);
         invokeEndElement (pctxt, "improvedPBFramesMode", -1);

         break;

         case 3:
         /* decode unlimitedMotionVectors */
         invokeStartElement (pctxt, "unlimitedMotionVectors", -1);

         stat = DECODEBIT (pctxt, &pvalue->unlimitedMotionVectors);

         invokeBoolValue (pctxt, pvalue->unlimitedMotionVectors);
         invokeEndElement (pctxt, "unlimitedMotionVectors", -1);

         break;

         case 4:
         /* decode fullPictureFreeze */
         invokeStartElement (pctxt, "fullPictureFreeze", -1);

         stat = DECODEBIT (pctxt, &pvalue->fullPictureFreeze);

         invokeBoolValue (pctxt, pvalue->fullPictureFreeze);
         invokeEndElement (pctxt, "fullPictureFreeze", -1);

         break;

         case 5:
         /* decode partialPictureFreezeAndRelease */
         invokeStartElement (pctxt, "partialPictureFreezeAndRelease", -1);

         stat = DECODEBIT (pctxt, &pvalue->partialPictureFreezeAndRelease);

         invokeBoolValue (pctxt, pvalue->partialPictureFreezeAndRelease);
         invokeEndElement (pctxt, "partialPictureFreezeAndRelease", -1);

         break;

         case 6:
         /* decode resizingPartPicFreezeAndRelease */
         invokeStartElement (pctxt, "resizingPartPicFreezeAndRelease", -1);

         stat = DECODEBIT (pctxt, &pvalue->resizingPartPicFreezeAndRelease);

         invokeBoolValue (pctxt, pvalue->resizingPartPicFreezeAndRelease);
         invokeEndElement (pctxt, "resizingPartPicFreezeAndRelease", -1);

         break;

         case 7:
         /* decode fullPictureSnapshot */
         invokeStartElement (pctxt, "fullPictureSnapshot", -1);

         stat = DECODEBIT (pctxt, &pvalue->fullPictureSnapshot);

         invokeBoolValue (pctxt, pvalue->fullPictureSnapshot);
         invokeEndElement (pctxt, "fullPictureSnapshot", -1);

         break;

         case 8:
         /* decode partialPictureSnapshot */
         invokeStartElement (pctxt, "partialPictureSnapshot", -1);

         stat = DECODEBIT (pctxt, &pvalue->partialPictureSnapshot);

         invokeBoolValue (pctxt, pvalue->partialPictureSnapshot);
         invokeEndElement (pctxt, "partialPictureSnapshot", -1);

         break;

         case 9:
         /* decode videoSegmentTagging */
         invokeStartElement (pctxt, "videoSegmentTagging", -1);

         stat = DECODEBIT (pctxt, &pvalue->videoSegmentTagging);

         invokeBoolValue (pctxt, pvalue->videoSegmentTagging);
         invokeEndElement (pctxt, "videoSegmentTagging", -1);

         break;

         case 10:
         /* decode progressiveRefinement */
         invokeStartElement (pctxt, "progressiveRefinement", -1);

         stat = DECODEBIT (pctxt, &pvalue->progressiveRefinement);

         invokeBoolValue (pctxt, pvalue->progressiveRefinement);
         invokeEndElement (pctxt, "progressiveRefinement", -1);

         break;

         case 11:
         /* decode dynamicPictureResizingByFour */
         invokeStartElement (pctxt, "dynamicPictureResizingByFour", -1);

         stat = DECODEBIT (pctxt, &pvalue->dynamicPictureResizingByFour);

         invokeBoolValue (pctxt, pvalue->dynamicPictureResizingByFour);
         invokeEndElement (pctxt, "dynamicPictureResizingByFour", -1);

         break;

         case 12:
         /* decode dynamicPictureResizingSixteenthPel */
         invokeStartElement (pctxt, "dynamicPictureResizingSixteenthPel", -1);

         stat = DECODEBIT (pctxt, &pvalue->dynamicPictureResizingSixteenthPel);

         invokeBoolValue (pctxt, pvalue->dynamicPictureResizingSixteenthPel);
         invokeEndElement (pctxt, "dynamicPictureResizingSixteenthPel", -1);

         break;

         case 13:
         /* decode dynamicWarpingHalfPel */
         invokeStartElement (pctxt, "dynamicWarpingHalfPel", -1);

         stat = DECODEBIT (pctxt, &pvalue->dynamicWarpingHalfPel);

         invokeBoolValue (pctxt, pvalue->dynamicWarpingHalfPel);
         invokeEndElement (pctxt, "dynamicWarpingHalfPel", -1);

         break;

         case 14:
         /* decode dynamicWarpingSixteenthPel */
         invokeStartElement (pctxt, "dynamicWarpingSixteenthPel", -1);

         stat = DECODEBIT (pctxt, &pvalue->dynamicWarpingSixteenthPel);

         invokeBoolValue (pctxt, pvalue->dynamicWarpingSixteenthPel);
         invokeEndElement (pctxt, "dynamicWarpingSixteenthPel", -1);

         break;

         case 15:
         /* decode independentSegmentDecoding */
         invokeStartElement (pctxt, "independentSegmentDecoding", -1);

         stat = DECODEBIT (pctxt, &pvalue->independentSegmentDecoding);

         invokeBoolValue (pctxt, pvalue->independentSegmentDecoding);
         invokeEndElement (pctxt, "independentSegmentDecoding", -1);

         break;

         case 16:
         /* decode slicesInOrder_NonRect */
         invokeStartElement (pctxt, "slicesInOrder_NonRect", -1);

         stat = DECODEBIT (pctxt, &pvalue->slicesInOrder_NonRect);

         invokeBoolValue (pctxt, pvalue->slicesInOrder_NonRect);
         invokeEndElement (pctxt, "slicesInOrder_NonRect", -1);

         break;

         case 17:
         /* decode slicesInOrder_Rect */
         invokeStartElement (pctxt, "slicesInOrder_Rect", -1);

         stat = DECODEBIT (pctxt, &pvalue->slicesInOrder_Rect);

         invokeBoolValue (pctxt, pvalue->slicesInOrder_Rect);
         invokeEndElement (pctxt, "slicesInOrder_Rect", -1);

         break;

         case 18:
         /* decode slicesNoOrder_NonRect */
         invokeStartElement (pctxt, "slicesNoOrder_NonRect", -1);

         stat = DECODEBIT (pctxt, &pvalue->slicesNoOrder_NonRect);

         invokeBoolValue (pctxt, pvalue->slicesNoOrder_NonRect);
         invokeEndElement (pctxt, "slicesNoOrder_NonRect", -1);

         break;

         case 19:
         /* decode slicesNoOrder_Rect */
         invokeStartElement (pctxt, "slicesNoOrder_Rect", -1);

         stat = DECODEBIT (pctxt, &pvalue->slicesNoOrder_Rect);

         invokeBoolValue (pctxt, pvalue->slicesNoOrder_Rect);
         invokeEndElement (pctxt, "slicesNoOrder_Rect", -1);

         break;

         case 20:
         /* decode alternateInterVLCMode */
         invokeStartElement (pctxt, "alternateInterVLCMode", -1);

         stat = DECODEBIT (pctxt, &pvalue->alternateInterVLCMode);

         invokeBoolValue (pctxt, pvalue->alternateInterVLCMode);
         invokeEndElement (pctxt, "alternateInterVLCMode", -1);

         break;

         case 21:
         /* decode modifiedQuantizationMode */
         invokeStartElement (pctxt, "modifiedQuantizationMode", -1);

         stat = DECODEBIT (pctxt, &pvalue->modifiedQuantizationMode);

         invokeBoolValue (pctxt, pvalue->modifiedQuantizationMode);
         invokeEndElement (pctxt, "modifiedQuantizationMode", -1);

         break;

         case 22:
         /* decode reducedResolutionUpdate */
         invokeStartElement (pctxt, "reducedResolutionUpdate", -1);

         stat = DECODEBIT (pctxt, &pvalue->reducedResolutionUpdate);

         invokeBoolValue (pctxt, pvalue->reducedResolutionUpdate);
         invokeEndElement (pctxt, "reducedResolutionUpdate", -1);

         break;

         case 23:
         /* decode transparencyParameters */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "transparencyParameters", -1);

            stat = asn1PD_H245TransparencyParameters (pctxt, &pvalue->transparencyParameters);

            pvalue->m.transparencyParametersPresent = 1;
            invokeEndElement (pctxt, "transparencyParameters", -1);

         }
         break;

         case 24:
         /* decode separateVideoBackChannel */
         invokeStartElement (pctxt, "separateVideoBackChannel", -1);

         stat = DECODEBIT (pctxt, &pvalue->separateVideoBackChannel);

         invokeBoolValue (pctxt, pvalue->separateVideoBackChannel);
         invokeEndElement (pctxt, "separateVideoBackChannel", -1);

         break;

         case 25:
         /* decode refPictureSelection */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "refPictureSelection", -1);

            stat = asn1PD_H245RefPictureSelection (pctxt, &pvalue->refPictureSelection);

            pvalue->m.refPictureSelectionPresent = 1;
            invokeEndElement (pctxt, "refPictureSelection", -1);

         }
         break;

         case 26:
         /* decode customPictureClockFrequency */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "customPictureClockFrequency", -1);

            stat = asn1PD_H245H263Options_customPictureClockFrequency (pctxt, &pvalue->customPictureClockFrequency);

            pvalue->m.customPictureClockFrequencyPresent = 1;
            invokeEndElement (pctxt, "customPictureClockFrequency", -1);

         }
         break;

         case 27:
         /* decode customPictureFormat */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "customPictureFormat", -1);

            stat = asn1PD_H245H263Options_customPictureFormat (pctxt, &pvalue->customPictureFormat);

            pvalue->m.customPictureFormatPresent = 1;
            invokeEndElement (pctxt, "customPictureFormat", -1);

         }
         break;

         case 28:
         /* decode modeCombos */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "modeCombos", -1);

            stat = asn1PD_H245H263Options_modeCombos (pctxt, &pvalue->modeCombos);

            pvalue->m.modeCombosPresent = 1;
            invokeEndElement (pctxt, "modeCombos", -1);

         }
         break;

         default: j++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return stat;

            if (i < 2) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt,
                  (ASN1OCTET*)openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     if (openType.numocts == 0) break;

                     pvalue->m.videoBadMBsCapPresent = 1;

                     invokeStartElement (pctxt, "videoBadMBsCap", -1);

                     stat = DECODEBIT (pctxt, &pvalue->videoBadMBsCap);
                     if (stat != 0) return stat;

                     invokeBoolValue (pctxt, pvalue->videoBadMBsCap);
                     invokeEndElement (pctxt, "videoBadMBsCap", -1);

                     break;

                  case 1:
                     if (openType.numocts == 0) break;

                     pvalue->m.h263Version3OptionsPresent = 1;

                     invokeStartElement (pctxt, "h263Version3Options", -1);

                     stat = asn1PD_H245H263Version3Options (pctxt, &pvalue->h263Version3Options);
                     if (stat != 0) return stat;

                     invokeEndElement (pctxt, "h263Version3Options", -1);

                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245EnhancementOptions (OOCTXT* pctxt, H245EnhancementOptions* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;
   OOUINT32 j = 0;
   OOBOOL optbits[11];

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   for (i = 0; i < 11; i++) {
      stat = DECODEBIT (pctxt, &optbits[i]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i = 0; i < 16; i++) {
      switch (i) {
         case 0:
         /* decode sqcifMPI */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "sqcifMPI", -1);

            stat = decodeConsUInt8 (pctxt, &pvalue->sqcifMPI, 1, 32);

            invokeUIntValue (pctxt, pvalue->sqcifMPI);
            pvalue->m.sqcifMPIPresent = 1;
            invokeEndElement (pctxt, "sqcifMPI", -1);

         }
         break;

         case 1:
         /* decode qcifMPI */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "qcifMPI", -1);

            stat = decodeConsUInt8 (pctxt, &pvalue->qcifMPI, 1, 32);

            invokeUIntValue (pctxt, pvalue->qcifMPI);
            pvalue->m.qcifMPIPresent = 1;
            invokeEndElement (pctxt, "qcifMPI", -1);

         }
         break;

         case 2:
         /* decode cifMPI */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "cifMPI", -1);

            stat = decodeConsUInt8 (pctxt, &pvalue->cifMPI, 1, 32);

            invokeUIntValue (pctxt, pvalue->cifMPI);
            pvalue->m.cifMPIPresent = 1;
            invokeEndElement (pctxt, "cifMPI", -1);

         }
         break;

         case 3:
         /* decode cif4MPI */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "cif4MPI", -1);

            stat = decodeConsUInt8 (pctxt, &pvalue->cif4MPI, 1, 32);

            invokeUIntValue (pctxt, pvalue->cif4MPI);
            pvalue->m.cif4MPIPresent = 1;
            invokeEndElement (pctxt, "cif4MPI", -1);

         }
         break;

         case 4:
         /* decode cif16MPI */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "cif16MPI", -1);

            stat = decodeConsUInt8 (pctxt, &pvalue->cif16MPI, 1, 32);

            invokeUIntValue (pctxt, pvalue->cif16MPI);
            pvalue->m.cif16MPIPresent = 1;
            invokeEndElement (pctxt, "cif16MPI", -1);

         }
         break;

         case 5:
         /* decode maxBitRate */
         invokeStartElement (pctxt, "maxBitRate", -1);

         stat = decodeConsUnsigned (pctxt, &pvalue->maxBitRate, 1, 192400);

         invokeUIntValue (pctxt, pvalue->maxBitRate);
         invokeEndElement (pctxt, "maxBitRate", -1);

         break;

         case 6:
         /* decode unrestrictedVector */
         invokeStartElement (pctxt, "unrestrictedVector", -1);

         stat = DECODEBIT (pctxt, &pvalue->unrestrictedVector);

         invokeBoolValue (pctxt, pvalue->unrestrictedVector);
         invokeEndElement (pctxt, "unrestrictedVector", -1);

         break;

         case 7:
         /* decode arithmeticCoding */
         invokeStartElement (pctxt, "arithmeticCoding", -1);

         stat = DECODEBIT (pctxt, &pvalue->arithmeticCoding);

         invokeBoolValue (pctxt, pvalue->arithmeticCoding);
         invokeEndElement (pctxt, "arithmeticCoding", -1);

         break;

         case 8:
         /* decode temporalSpatialTradeOffCapability */
         invokeStartElement (pctxt, "temporalSpatialTradeOffCapability", -1);

         stat = DECODEBIT (pctxt, &pvalue->temporalSpatialTradeOffCapability);

         invokeBoolValue (pctxt, pvalue->temporalSpatialTradeOffCapability);
         invokeEndElement (pctxt, "temporalSpatialTradeOffCapability", -1);

         break;

         case 9:
         /* decode slowSqcifMPI */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "slowSqcifMPI", -1);

            stat = decodeConsUInt16 (pctxt, &pvalue->slowSqcifMPI, 1, 3600);

            invokeUIntValue (pctxt, pvalue->slowSqcifMPI);
            pvalue->m.slowSqcifMPIPresent = 1;
            invokeEndElement (pctxt, "slowSqcifMPI", -1);

         }
         break;

         case 10:
         /* decode slowQcifMPI */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "slowQcifMPI", -1);

            stat = decodeConsUInt16 (pctxt, &pvalue->slowQcifMPI, 1, 3600);

            invokeUIntValue (pctxt, pvalue->slowQcifMPI);
            pvalue->m.slowQcifMPIPresent = 1;
            invokeEndElement (pctxt, "slowQcifMPI", -1);

         }
         break;

         case 11:
         /* decode slowCifMPI */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "slowCifMPI", -1);

            stat = decodeConsUInt16 (pctxt, &pvalue->slowCifMPI, 1, 3600);

            invokeUIntValue (pctxt, pvalue->slowCifMPI);
            pvalue->m.slowCifMPIPresent = 1;
            invokeEndElement (pctxt, "slowCifMPI", -1);

         }
         break;

         case 12:
         /* decode slowCif4MPI */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "slowCif4MPI", -1);

            stat = decodeConsUInt16 (pctxt, &pvalue->slowCif4MPI, 1, 3600);

            invokeUIntValue (pctxt, pvalue->slowCif4MPI);
            pvalue->m.slowCif4MPIPresent = 1;
            invokeEndElement (pctxt, "slowCif4MPI", -1);

         }
         break;

         case 13:
         /* decode slowCif16MPI */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "slowCif16MPI", -1);

            stat = decodeConsUInt16 (pctxt, &pvalue->slowCif16MPI, 1, 3600);

            invokeUIntValue (pctxt, pvalue->slowCif16MPI);
            pvalue->m.slowCif16MPIPresent = 1;
            invokeEndElement (pctxt, "slowCif16MPI", -1);

         }
         break;

         case 14:
         /* decode errorCompensation */
         invokeStartElement (pctxt, "errorCompensation", -1);

         stat = DECODEBIT (pctxt, &pvalue->errorCompensation);

         invokeBoolValue (pctxt, pvalue->errorCompensation);
         invokeEndElement (pctxt, "errorCompensation", -1);

         break;

         case 15:
         /* decode h263Options */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "h263Options", -1);

            stat = asn1PD_H245H263Options (pctxt, &pvalue->h263Options);

            pvalue->m.h263OptionsPresent = 1;
            invokeEndElement (pctxt, "h263Options", -1);

         }
         break;

         default: j++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245EnhancementLayerInfo_snrEnhancement (OOCTXT* pctxt, H245EnhancementLayerInfo_snrEnhancement* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 14, 0 };
   int stat = 0;
   H245EnhancementOptions* pdata;
   DListNode* pnode;
   OOUINT32 count = 0;
   OOUINT32 xx1 = 0;

   /* decode length determinant */

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeLength (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      invokeStartElement (pctxt, "elem", xx1);

      dListAllocNodeAndData (pctxt, H245EnhancementOptions, &pnode, &pdata);

      stat = asn1PD_H245EnhancementOptions (pctxt, pdata);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "elem", xx1);

      dListAppendNode2 (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1PD_H245EnhancementLayerInfo_spatialEnhancement (OOCTXT* pctxt, H245EnhancementLayerInfo_spatialEnhancement* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 14, 0 };
   int stat = 0;
   H245EnhancementOptions* pdata;
   DListNode* pnode;
   OOUINT32 count = 0;
   OOUINT32 xx1 = 0;

   /* decode length determinant */

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeLength (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      invokeStartElement (pctxt, "elem", xx1);

      dListAllocNodeAndData (pctxt, H245EnhancementOptions, &pnode, &pdata);

      stat = asn1PD_H245EnhancementOptions (pctxt, pdata);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "elem", xx1);

      dListAppendNode2 (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1PD_H245BEnhancementParameters (OOCTXT* pctxt, H245BEnhancementParameters* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode enhancementOptions */
   invokeStartElement (pctxt, "enhancementOptions", -1);

   stat = asn1PD_H245EnhancementOptions (pctxt, &pvalue->enhancementOptions);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "enhancementOptions", -1);

   /* decode numberOfBPictures */
   invokeStartElement (pctxt, "numberOfBPictures", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->numberOfBPictures, 1, 64);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->numberOfBPictures);
   invokeEndElement (pctxt, "numberOfBPictures", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245EnhancementLayerInfo_bPictureEnhancement (OOCTXT* pctxt, H245EnhancementLayerInfo_bPictureEnhancement* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 14, 0 };
   int stat = 0;
   H245BEnhancementParameters* pdata;
   DListNode* pnode;
   OOUINT32 count = 0;
   OOUINT32 xx1 = 0;

   /* decode length determinant */

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeLength (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      invokeStartElement (pctxt, "elem", xx1);

      dListAllocNodeAndData (pctxt, H245BEnhancementParameters, &pnode, &pdata);

      stat = asn1PD_H245BEnhancementParameters (pctxt, pdata);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "elem", xx1);

      dListAppendNode2 (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1PD_H245EnhancementLayerInfo (OOCTXT* pctxt, H245EnhancementLayerInfo* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;
   OOUINT32 j = 0;
   OOBOOL optbits[3];

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   for (i = 0; i < 3; i++) {
      stat = DECODEBIT (pctxt, &optbits[i]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i = 0; i < 4; i++) {
      switch (i) {
         case 0:
         /* decode baseBitRateConstrained */
         invokeStartElement (pctxt, "baseBitRateConstrained", -1);

         stat = DECODEBIT (pctxt, &pvalue->baseBitRateConstrained);

         invokeBoolValue (pctxt, pvalue->baseBitRateConstrained);
         invokeEndElement (pctxt, "baseBitRateConstrained", -1);

         break;

         case 1:
         /* decode snrEnhancement */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "snrEnhancement", -1);

            stat = asn1PD_H245EnhancementLayerInfo_snrEnhancement (pctxt, &pvalue->snrEnhancement);

            pvalue->m.snrEnhancementPresent = 1;
            invokeEndElement (pctxt, "snrEnhancement", -1);

         }
         break;

         case 2:
         /* decode spatialEnhancement */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "spatialEnhancement", -1);

            stat = asn1PD_H245EnhancementLayerInfo_spatialEnhancement (pctxt, &pvalue->spatialEnhancement);

            pvalue->m.spatialEnhancementPresent = 1;
            invokeEndElement (pctxt, "spatialEnhancement", -1);

         }
         break;

         case 3:
         /* decode bPictureEnhancement */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "bPictureEnhancement", -1);

            stat = asn1PD_H245EnhancementLayerInfo_bPictureEnhancement (pctxt, &pvalue->bPictureEnhancement);

            pvalue->m.bPictureEnhancementPresent = 1;
            invokeEndElement (pctxt, "bPictureEnhancement", -1);

         }
         break;

         default: j++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245H263VideoCapability (OOCTXT* pctxt, H245H263VideoCapability* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;
   OOUINT32 j = 0;
   OOBOOL optbits[7];

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   for (i = 0; i < 7; i++) {
      stat = DECODEBIT (pctxt, &optbits[i]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i = 0; i < 13; i++) {
      switch (i) {
         case 0:
         /* decode sqcifMPI */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "sqcifMPI", -1);

            stat = decodeConsUInt8 (pctxt, &pvalue->sqcifMPI, 1, 32);

            invokeUIntValue (pctxt, pvalue->sqcifMPI);
            pvalue->m.sqcifMPIPresent = 1;
            invokeEndElement (pctxt, "sqcifMPI", -1);

         }
         break;

         case 1:
         /* decode qcifMPI */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "qcifMPI", -1);

            stat = decodeConsUInt8 (pctxt, &pvalue->qcifMPI, 1, 32);

            invokeUIntValue (pctxt, pvalue->qcifMPI);
            pvalue->m.qcifMPIPresent = 1;
            invokeEndElement (pctxt, "qcifMPI", -1);

         }
         break;

         case 2:
         /* decode cifMPI */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "cifMPI", -1);

            stat = decodeConsUInt8 (pctxt, &pvalue->cifMPI, 1, 32);

            invokeUIntValue (pctxt, pvalue->cifMPI);
            pvalue->m.cifMPIPresent = 1;
            invokeEndElement (pctxt, "cifMPI", -1);

         }
         break;

         case 3:
         /* decode cif4MPI */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "cif4MPI", -1);

            stat = decodeConsUInt8 (pctxt, &pvalue->cif4MPI, 1, 32);

            invokeUIntValue (pctxt, pvalue->cif4MPI);
            pvalue->m.cif4MPIPresent = 1;
            invokeEndElement (pctxt, "cif4MPI", -1);

         }
         break;

         case 4:
         /* decode cif16MPI */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "cif16MPI", -1);

            stat = decodeConsUInt8 (pctxt, &pvalue->cif16MPI, 1, 32);

            invokeUIntValue (pctxt, pvalue->cif16MPI);
            pvalue->m.cif16MPIPresent = 1;
            invokeEndElement (pctxt, "cif16MPI", -1);

         }
         break;

         case 5:
         /* decode maxBitRate */
         invokeStartElement (pctxt, "maxBitRate", -1);

         stat = decodeConsUnsigned (pctxt, &pvalue->maxBitRate, 1, 192400);

         invokeUIntValue (pctxt, pvalue->maxBitRate);
         invokeEndElement (pctxt, "maxBitRate", -1);

         break;

         case 6:
         /* decode unrestrictedVector */
         invokeStartElement (pctxt, "unrestrictedVector", -1);

         stat = DECODEBIT (pctxt, &pvalue->unrestrictedVector);

         invokeBoolValue (pctxt, pvalue->unrestrictedVector);
         invokeEndElement (pctxt, "unrestrictedVector", -1);

         break;

         case 7:
         /* decode arithmeticCoding */
         invokeStartElement (pctxt, "arithmeticCoding", -1);

         stat = DECODEBIT (pctxt, &pvalue->arithmeticCoding);

         invokeBoolValue (pctxt, pvalue->arithmeticCoding);
         invokeEndElement (pctxt, "arithmeticCoding", -1);

         break;

         case 8:
         /* decode advancedPrediction */
         invokeStartElement (pctxt, "advancedPrediction", -1);

         stat = DECODEBIT (pctxt, &pvalue->advancedPrediction);

         invokeBoolValue (pctxt, pvalue->advancedPrediction);
         invokeEndElement (pctxt, "advancedPrediction", -1);

         break;

         case 9:
         /* decode pbFrames */
         invokeStartElement (pctxt, "pbFrames", -1);

         stat = DECODEBIT (pctxt, &pvalue->pbFrames);

         invokeBoolValue (pctxt, pvalue->pbFrames);
         invokeEndElement (pctxt, "pbFrames", -1);

         break;

         case 10:
         /* decode temporalSpatialTradeOffCapability */
         invokeStartElement (pctxt, "temporalSpatialTradeOffCapability", -1);

         stat = DECODEBIT (pctxt, &pvalue->temporalSpatialTradeOffCapability);

         invokeBoolValue (pctxt, pvalue->temporalSpatialTradeOffCapability);
         invokeEndElement (pctxt, "temporalSpatialTradeOffCapability", -1);

         break;

         case 11:
         /* decode hrd_B */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "hrd_B", -1);

            stat = decodeConsUnsigned (pctxt, &pvalue->hrd_B, 0, 524287);

            invokeUIntValue (pctxt, pvalue->hrd_B);
            pvalue->m.hrd_BPresent = 1;
            invokeEndElement (pctxt, "hrd_B", -1);

         }
         break;

         case 12:
         /* decode bppMaxKb */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "bppMaxKb", -1);

            stat = decodeConsUInt16 (pctxt, &pvalue->bppMaxKb, 0, 65535);

            invokeUIntValue (pctxt, pvalue->bppMaxKb);
            pvalue->m.bppMaxKbPresent = 1;
            invokeEndElement (pctxt, "bppMaxKb", -1);

         }
         break;

         default: j++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return stat;

            if (i < 8) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt,
                  (ASN1OCTET*)openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     if (openType.numocts == 0) break;

                     pvalue->m.slowSqcifMPIPresent = 1;

                     invokeStartElement (pctxt, "slowSqcifMPI", -1);

                     stat = decodeConsUInt16 (pctxt, &pvalue->slowSqcifMPI, 1, 3600);
                     if (stat != 0) return stat;

                     invokeUIntValue (pctxt, pvalue->slowSqcifMPI);
                     invokeEndElement (pctxt, "slowSqcifMPI", -1);

                     break;

                  case 1:
                     if (openType.numocts == 0) break;

                     pvalue->m.slowQcifMPIPresent = 1;

                     invokeStartElement (pctxt, "slowQcifMPI", -1);

                     stat = decodeConsUInt16 (pctxt, &pvalue->slowQcifMPI, 1, 3600);
                     if (stat != 0) return stat;

                     invokeUIntValue (pctxt, pvalue->slowQcifMPI);
                     invokeEndElement (pctxt, "slowQcifMPI", -1);

                     break;

                  case 2:
                     if (openType.numocts == 0) break;

                     pvalue->m.slowCifMPIPresent = 1;

                     invokeStartElement (pctxt, "slowCifMPI", -1);

                     stat = decodeConsUInt16 (pctxt, &pvalue->slowCifMPI, 1, 3600);
                     if (stat != 0) return stat;

                     invokeUIntValue (pctxt, pvalue->slowCifMPI);
                     invokeEndElement (pctxt, "slowCifMPI", -1);

                     break;

                  case 3:
                     if (openType.numocts == 0) break;

                     pvalue->m.slowCif4MPIPresent = 1;

                     invokeStartElement (pctxt, "slowCif4MPI", -1);

                     stat = decodeConsUInt16 (pctxt, &pvalue->slowCif4MPI, 1, 3600);
                     if (stat != 0) return stat;

                     invokeUIntValue (pctxt, pvalue->slowCif4MPI);
                     invokeEndElement (pctxt, "slowCif4MPI", -1);

                     break;

                  case 4:
                     if (openType.numocts == 0) break;

                     pvalue->m.slowCif16MPIPresent = 1;

                     invokeStartElement (pctxt, "slowCif16MPI", -1);

                     stat = decodeConsUInt16 (pctxt, &pvalue->slowCif16MPI, 1, 3600);
                     if (stat != 0) return stat;

                     invokeUIntValue (pctxt, pvalue->slowCif16MPI);
                     invokeEndElement (pctxt, "slowCif16MPI", -1);

                     break;

                  case 5:
                     if (openType.numocts == 0) break;

                     pvalue->m.errorCompensationPresent = 1;

                     invokeStartElement (pctxt, "errorCompensation", -1);

                     stat = DECODEBIT (pctxt, &pvalue->errorCompensation);
                     if (stat != 0) return stat;

                     invokeBoolValue (pctxt, pvalue->errorCompensation);
                     invokeEndElement (pctxt, "errorCompensation", -1);

                     break;

                  case 6:
                     if (openType.numocts == 0) break;

                     pvalue->m.enhancementLayerInfoPresent = 1;

                     invokeStartElement (pctxt, "enhancementLayerInfo", -1);

                     stat = asn1PD_H245EnhancementLayerInfo (pctxt, &pvalue->enhancementLayerInfo);
                     if (stat != 0) return stat;

                     invokeEndElement (pctxt, "enhancementLayerInfo", -1);

                     break;

                  case 7:
                     if (openType.numocts == 0) break;

                     pvalue->m.h263OptionsPresent = 1;

                     invokeStartElement (pctxt, "h263Options", -1);

                     stat = asn1PD_H245H263Options (pctxt, &pvalue->h263Options);
                     if (stat != 0) return stat;

                     invokeEndElement (pctxt, "h263Options", -1);

                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245IS11172VideoCapability (OOCTXT* pctxt, H245IS11172VideoCapability* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;
   OOUINT32 j = 0;
   OOBOOL optbits[6];

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   for (i = 0; i < 6; i++) {
      stat = DECODEBIT (pctxt, &optbits[i]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i = 0; i < 7; i++) {
      switch (i) {
         case 0:
         /* decode constrainedBitstream */
         invokeStartElement (pctxt, "constrainedBitstream", -1);

         stat = DECODEBIT (pctxt, &pvalue->constrainedBitstream);

         invokeBoolValue (pctxt, pvalue->constrainedBitstream);
         invokeEndElement (pctxt, "constrainedBitstream", -1);

         break;

         case 1:
         /* decode videoBitRate */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "videoBitRate", -1);

            stat = decodeConsUnsigned (pctxt, &pvalue->videoBitRate, 0, 1073741823);

            invokeUIntValue (pctxt, pvalue->videoBitRate);
            pvalue->m.videoBitRatePresent = 1;
            invokeEndElement (pctxt, "videoBitRate", -1);

         }
         break;

         case 2:
         /* decode vbvBufferSize */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "vbvBufferSize", -1);

            stat = decodeConsUnsigned (pctxt, &pvalue->vbvBufferSize, 0, 262143);

            invokeUIntValue (pctxt, pvalue->vbvBufferSize);
            pvalue->m.vbvBufferSizePresent = 1;
            invokeEndElement (pctxt, "vbvBufferSize", -1);

         }
         break;

         case 3:
         /* decode samplesPerLine */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "samplesPerLine", -1);

            stat = decodeConsUInt16 (pctxt, &pvalue->samplesPerLine, 0, 16383);

            invokeUIntValue (pctxt, pvalue->samplesPerLine);
            pvalue->m.samplesPerLinePresent = 1;
            invokeEndElement (pctxt, "samplesPerLine", -1);

         }
         break;

         case 4:
         /* decode linesPerFrame */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "linesPerFrame", -1);

            stat = decodeConsUInt16 (pctxt, &pvalue->linesPerFrame, 0, 16383);

            invokeUIntValue (pctxt, pvalue->linesPerFrame);
            pvalue->m.linesPerFramePresent = 1;
            invokeEndElement (pctxt, "linesPerFrame", -1);

         }
         break;

         case 5:
         /* decode pictureRate */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "pictureRate", -1);

            stat = decodeConsUInt8 (pctxt, &pvalue->pictureRate, 0, 15);

            invokeUIntValue (pctxt, pvalue->pictureRate);
            pvalue->m.pictureRatePresent = 1;
            invokeEndElement (pctxt, "pictureRate", -1);

         }
         break;

         case 6:
         /* decode luminanceSampleRate */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "luminanceSampleRate", -1);

            stat = decodeConsUnsigned (pctxt, &pvalue->luminanceSampleRate, 0, OOUINT32_MAX);

            invokeUIntValue (pctxt, pvalue->luminanceSampleRate);
            pvalue->m.luminanceSampleRatePresent = 1;
            invokeEndElement (pctxt, "luminanceSampleRate", -1);

         }
         break;

         default: j++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return stat;

            if (i < 1) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt,
                  (ASN1OCTET*)openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     if (openType.numocts == 0) break;

                     pvalue->m.videoBadMBsCapPresent = 1;

                     invokeStartElement (pctxt, "videoBadMBsCap", -1);

                     stat = DECODEBIT (pctxt, &pvalue->videoBadMBsCap);
                     if (stat != 0) return stat;

                     invokeBoolValue (pctxt, pvalue->videoBadMBsCap);
                     invokeEndElement (pctxt, "videoBadMBsCap", -1);

                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245_SeqOfH245VideoCapability (OOCTXT* pctxt, H245_SeqOfH245VideoCapability* pvalue)
{
   int stat = 0;
   H245VideoCapability* pdata;
   DListNode* pnode;
   OOUINT32 count = 0;
   OOUINT32 xx1 = 0;
   int lstat;
   OOUINT32 total = 0;

   dListInit (pvalue);

   for (;;) {
      /* decode length determinant */

      lstat = decodeLength (pctxt, &count);
      if (lstat != 0 && lstat != ASN_OK_FRAG) {
         return lstat;
      }
      else if (count == 0) break;
      total += count;

      /* decode elements */

      for (; xx1 < total; xx1++) {
         invokeStartElement (pctxt, "elem", xx1);

         dListAllocNodeAndData (pctxt, H245VideoCapability, &pnode, &pdata);

         stat = asn1PD_H245VideoCapability (pctxt, (H245VideoCapability*)pdata);
         if (stat != 0) return stat;

         invokeEndElement (pctxt, "elem", xx1);

         dListAppendNode2 (pvalue, pnode);
      }

      if (lstat == 0) break;
   }

   return (stat);
}

EXTERN int asn1PD_H245_SeqOfH245GenericCapability (OOCTXT* pctxt, H245_SeqOfH245GenericCapability* pvalue)
{
   int stat = 0;
   H245GenericCapability* pdata;
   DListNode* pnode;
   OOUINT32 count = 0;
   OOUINT32 xx1 = 0;
   int lstat;
   OOUINT32 total = 0;

   dListInit (pvalue);

   for (;;) {
      /* decode length determinant */

      lstat = decodeLength (pctxt, &count);
      if (lstat != 0 && lstat != ASN_OK_FRAG) {
         return lstat;
      }
      else if (count == 0) break;
      total += count;

      /* decode elements */

      for (; xx1 < total; xx1++) {
         invokeStartElement (pctxt, "elem", xx1);

         dListAllocNodeAndData (pctxt, H245GenericCapability, &pnode, &pdata);

         stat = asn1PD_H245GenericCapability (pctxt, pdata);
         if (stat != 0) return stat;

         invokeEndElement (pctxt, "elem", xx1);

         dListAppendNode2 (pvalue, pnode);
      }

      if (lstat == 0) break;
   }

   return (stat);
}

EXTERN int asn1PD_H245ExtendedVideoCapability (OOCTXT* pctxt, H245ExtendedVideoCapability* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.videoCapabilityExtensionPresent = optbit;

   /* decode root elements */
   /* decode videoCapability */
   invokeStartElement (pctxt, "videoCapability", -1);

   stat = asn1PD_H245_SeqOfH245VideoCapability (pctxt, &pvalue->videoCapability);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "videoCapability", -1);

   /* decode videoCapabilityExtension */
   if (pvalue->m.videoCapabilityExtensionPresent) {
      invokeStartElement (pctxt, "videoCapabilityExtension", -1);

      stat = asn1PD_H245_SeqOfH245GenericCapability (pctxt, &pvalue->videoCapabilityExtension);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "videoCapabilityExtension", -1);

   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245VideoCapability (OOCTXT* pctxt, H245VideoCapability* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 4);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            invokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = memAllocTypeZ (pctxt,
               H245NonStandardParameter);

            stat = asn1PD_H245NonStandardParameter (pctxt, pvalue->u.nonStandard);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* h261VideoCapability */
         case 1:
            invokeStartElement (pctxt, "h261VideoCapability", -1);

            pvalue->u.h261VideoCapability = memAllocTypeZ (pctxt,
               H245H261VideoCapability);

            stat = asn1PD_H245H261VideoCapability (pctxt, pvalue->u.h261VideoCapability);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "h261VideoCapability", -1);

            break;

         /* h262VideoCapability */
         case 2:
            invokeStartElement (pctxt, "h262VideoCapability", -1);

            pvalue->u.h262VideoCapability = memAllocTypeZ (pctxt,
               H245H262VideoCapability);

            stat = asn1PD_H245H262VideoCapability (pctxt, pvalue->u.h262VideoCapability);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "h262VideoCapability", -1);

            break;

         /* h263VideoCapability */
         case 3:
            invokeStartElement (pctxt, "h263VideoCapability", -1);

            pvalue->u.h263VideoCapability = memAllocTypeZ (pctxt,
               H245H263VideoCapability);

            stat = asn1PD_H245H263VideoCapability (pctxt, pvalue->u.h263VideoCapability);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "h263VideoCapability", -1);

            break;

         /* is11172VideoCapability */
         case 4:
            invokeStartElement (pctxt, "is11172VideoCapability", -1);

            pvalue->u.is11172VideoCapability = memAllocTypeZ (pctxt,
               H245IS11172VideoCapability);

            stat = asn1PD_H245IS11172VideoCapability (pctxt, pvalue->u.is11172VideoCapability);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "is11172VideoCapability", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 6;

      if (pvalue->t < 6) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt,
         (ASN1OCTET*)openType.data, openType.numocts);

      switch (pvalue->t) {
         /* genericVideoCapability */
         case 6:
            invokeStartElement (pctxt, "genericVideoCapability", -1);

            pvalue->u.genericVideoCapability = memAllocTypeZ (pctxt,
               H245GenericCapability);

            stat = asn1PD_H245GenericCapability (pctxt, pvalue->u.genericVideoCapability);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "genericVideoCapability", -1);

            break;

         /* extendedVideoCapability */
         case 7:
            invokeStartElement (pctxt, "extendedVideoCapability", -1);

            pvalue->u.extendedVideoCapability = memAllocTypeZ (pctxt,
               H245ExtendedVideoCapability);

            stat = asn1PD_H245ExtendedVideoCapability (pctxt, pvalue->u.extendedVideoCapability);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "extendedVideoCapability", -1);

            break;

         default:;
      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

EXTERN int asn1PD_H245AudioCapability_g7231 (OOCTXT* pctxt, H245AudioCapability_g7231* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode maxAl_sduAudioFrames */
   invokeStartElement (pctxt, "maxAl_sduAudioFrames", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->maxAl_sduAudioFrames, 1, 256);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->maxAl_sduAudioFrames);
   invokeEndElement (pctxt, "maxAl_sduAudioFrames", -1);

   /* decode silenceSuppression */
   invokeStartElement (pctxt, "silenceSuppression", -1);

   stat = DECODEBIT (pctxt, &pvalue->silenceSuppression);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->silenceSuppression);
   invokeEndElement (pctxt, "silenceSuppression", -1);

   return (stat);
}

EXTERN int asn1PD_H245IS11172AudioCapability (OOCTXT* pctxt, H245IS11172AudioCapability* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode audioLayer1 */
   invokeStartElement (pctxt, "audioLayer1", -1);

   stat = DECODEBIT (pctxt, &pvalue->audioLayer1);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->audioLayer1);
   invokeEndElement (pctxt, "audioLayer1", -1);

   /* decode audioLayer2 */
   invokeStartElement (pctxt, "audioLayer2", -1);

   stat = DECODEBIT (pctxt, &pvalue->audioLayer2);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->audioLayer2);
   invokeEndElement (pctxt, "audioLayer2", -1);

   /* decode audioLayer3 */
   invokeStartElement (pctxt, "audioLayer3", -1);

   stat = DECODEBIT (pctxt, &pvalue->audioLayer3);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->audioLayer3);
   invokeEndElement (pctxt, "audioLayer3", -1);

   /* decode audioSampling32k */
   invokeStartElement (pctxt, "audioSampling32k", -1);

   stat = DECODEBIT (pctxt, &pvalue->audioSampling32k);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->audioSampling32k);
   invokeEndElement (pctxt, "audioSampling32k", -1);

   /* decode audioSampling44k1 */
   invokeStartElement (pctxt, "audioSampling44k1", -1);

   stat = DECODEBIT (pctxt, &pvalue->audioSampling44k1);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->audioSampling44k1);
   invokeEndElement (pctxt, "audioSampling44k1", -1);

   /* decode audioSampling48k */
   invokeStartElement (pctxt, "audioSampling48k", -1);

   stat = DECODEBIT (pctxt, &pvalue->audioSampling48k);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->audioSampling48k);
   invokeEndElement (pctxt, "audioSampling48k", -1);

   /* decode singleChannel */
   invokeStartElement (pctxt, "singleChannel", -1);

   stat = DECODEBIT (pctxt, &pvalue->singleChannel);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->singleChannel);
   invokeEndElement (pctxt, "singleChannel", -1);

   /* decode twoChannels */
   invokeStartElement (pctxt, "twoChannels", -1);

   stat = DECODEBIT (pctxt, &pvalue->twoChannels);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->twoChannels);
   invokeEndElement (pctxt, "twoChannels", -1);

   /* decode bitRate */
   invokeStartElement (pctxt, "bitRate", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->bitRate, 1, 448);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->bitRate);
   invokeEndElement (pctxt, "bitRate", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245IS13818AudioCapability (OOCTXT* pctxt, H245IS13818AudioCapability* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode audioLayer1 */
   invokeStartElement (pctxt, "audioLayer1", -1);

   stat = DECODEBIT (pctxt, &pvalue->audioLayer1);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->audioLayer1);
   invokeEndElement (pctxt, "audioLayer1", -1);

   /* decode audioLayer2 */
   invokeStartElement (pctxt, "audioLayer2", -1);

   stat = DECODEBIT (pctxt, &pvalue->audioLayer2);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->audioLayer2);
   invokeEndElement (pctxt, "audioLayer2", -1);

   /* decode audioLayer3 */
   invokeStartElement (pctxt, "audioLayer3", -1);

   stat = DECODEBIT (pctxt, &pvalue->audioLayer3);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->audioLayer3);
   invokeEndElement (pctxt, "audioLayer3", -1);

   /* decode audioSampling16k */
   invokeStartElement (pctxt, "audioSampling16k", -1);

   stat = DECODEBIT (pctxt, &pvalue->audioSampling16k);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->audioSampling16k);
   invokeEndElement (pctxt, "audioSampling16k", -1);

   /* decode audioSampling22k05 */
   invokeStartElement (pctxt, "audioSampling22k05", -1);

   stat = DECODEBIT (pctxt, &pvalue->audioSampling22k05);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->audioSampling22k05);
   invokeEndElement (pctxt, "audioSampling22k05", -1);

   /* decode audioSampling24k */
   invokeStartElement (pctxt, "audioSampling24k", -1);

   stat = DECODEBIT (pctxt, &pvalue->audioSampling24k);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->audioSampling24k);
   invokeEndElement (pctxt, "audioSampling24k", -1);

   /* decode audioSampling32k */
   invokeStartElement (pctxt, "audioSampling32k", -1);

   stat = DECODEBIT (pctxt, &pvalue->audioSampling32k);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->audioSampling32k);
   invokeEndElement (pctxt, "audioSampling32k", -1);

   /* decode audioSampling44k1 */
   invokeStartElement (pctxt, "audioSampling44k1", -1);

   stat = DECODEBIT (pctxt, &pvalue->audioSampling44k1);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->audioSampling44k1);
   invokeEndElement (pctxt, "audioSampling44k1", -1);

   /* decode audioSampling48k */
   invokeStartElement (pctxt, "audioSampling48k", -1);

   stat = DECODEBIT (pctxt, &pvalue->audioSampling48k);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->audioSampling48k);
   invokeEndElement (pctxt, "audioSampling48k", -1);

   /* decode singleChannel */
   invokeStartElement (pctxt, "singleChannel", -1);

   stat = DECODEBIT (pctxt, &pvalue->singleChannel);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->singleChannel);
   invokeEndElement (pctxt, "singleChannel", -1);

   /* decode twoChannels */
   invokeStartElement (pctxt, "twoChannels", -1);

   stat = DECODEBIT (pctxt, &pvalue->twoChannels);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->twoChannels);
   invokeEndElement (pctxt, "twoChannels", -1);

   /* decode threeChannels2_1 */
   invokeStartElement (pctxt, "threeChannels2_1", -1);

   stat = DECODEBIT (pctxt, &pvalue->threeChannels2_1);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->threeChannels2_1);
   invokeEndElement (pctxt, "threeChannels2_1", -1);

   /* decode threeChannels3_0 */
   invokeStartElement (pctxt, "threeChannels3_0", -1);

   stat = DECODEBIT (pctxt, &pvalue->threeChannels3_0);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->threeChannels3_0);
   invokeEndElement (pctxt, "threeChannels3_0", -1);

   /* decode fourChannels2_0_2_0 */
   invokeStartElement (pctxt, "fourChannels2_0_2_0", -1);

   stat = DECODEBIT (pctxt, &pvalue->fourChannels2_0_2_0);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->fourChannels2_0_2_0);
   invokeEndElement (pctxt, "fourChannels2_0_2_0", -1);

   /* decode fourChannels2_2 */
   invokeStartElement (pctxt, "fourChannels2_2", -1);

   stat = DECODEBIT (pctxt, &pvalue->fourChannels2_2);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->fourChannels2_2);
   invokeEndElement (pctxt, "fourChannels2_2", -1);

   /* decode fourChannels3_1 */
   invokeStartElement (pctxt, "fourChannels3_1", -1);

   stat = DECODEBIT (pctxt, &pvalue->fourChannels3_1);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->fourChannels3_1);
   invokeEndElement (pctxt, "fourChannels3_1", -1);

   /* decode fiveChannels3_0_2_0 */
   invokeStartElement (pctxt, "fiveChannels3_0_2_0", -1);

   stat = DECODEBIT (pctxt, &pvalue->fiveChannels3_0_2_0);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->fiveChannels3_0_2_0);
   invokeEndElement (pctxt, "fiveChannels3_0_2_0", -1);

   /* decode fiveChannels3_2 */
   invokeStartElement (pctxt, "fiveChannels3_2", -1);

   stat = DECODEBIT (pctxt, &pvalue->fiveChannels3_2);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->fiveChannels3_2);
   invokeEndElement (pctxt, "fiveChannels3_2", -1);

   /* decode lowFrequencyEnhancement */
   invokeStartElement (pctxt, "lowFrequencyEnhancement", -1);

   stat = DECODEBIT (pctxt, &pvalue->lowFrequencyEnhancement);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->lowFrequencyEnhancement);
   invokeEndElement (pctxt, "lowFrequencyEnhancement", -1);

   /* decode multilingual */
   invokeStartElement (pctxt, "multilingual", -1);

   stat = DECODEBIT (pctxt, &pvalue->multilingual);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->multilingual);
   invokeEndElement (pctxt, "multilingual", -1);

   /* decode bitRate */
   invokeStartElement (pctxt, "bitRate", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->bitRate, 1, 1130);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->bitRate);
   invokeEndElement (pctxt, "bitRate", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245G7231AnnexCCapability_g723AnnexCAudioMode (OOCTXT* pctxt, H245G7231AnnexCCapability_g723AnnexCAudioMode* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode highRateMode0 */
   invokeStartElement (pctxt, "highRateMode0", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->highRateMode0, 27, 78);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->highRateMode0);
   invokeEndElement (pctxt, "highRateMode0", -1);

   /* decode highRateMode1 */
   invokeStartElement (pctxt, "highRateMode1", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->highRateMode1, 27, 78);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->highRateMode1);
   invokeEndElement (pctxt, "highRateMode1", -1);

   /* decode lowRateMode0 */
   invokeStartElement (pctxt, "lowRateMode0", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->lowRateMode0, 23, 66);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->lowRateMode0);
   invokeEndElement (pctxt, "lowRateMode0", -1);

   /* decode lowRateMode1 */
   invokeStartElement (pctxt, "lowRateMode1", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->lowRateMode1, 23, 66);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->lowRateMode1);
   invokeEndElement (pctxt, "lowRateMode1", -1);

   /* decode sidMode0 */
   invokeStartElement (pctxt, "sidMode0", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->sidMode0, 6, 17);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->sidMode0);
   invokeEndElement (pctxt, "sidMode0", -1);

   /* decode sidMode1 */
   invokeStartElement (pctxt, "sidMode1", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->sidMode1, 6, 17);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->sidMode1);
   invokeEndElement (pctxt, "sidMode1", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245G7231AnnexCCapability (OOCTXT* pctxt, H245G7231AnnexCCapability* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.g723AnnexCAudioModePresent = optbit;

   /* decode root elements */
   /* decode maxAl_sduAudioFrames */
   invokeStartElement (pctxt, "maxAl_sduAudioFrames", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->maxAl_sduAudioFrames, 1, 256);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->maxAl_sduAudioFrames);
   invokeEndElement (pctxt, "maxAl_sduAudioFrames", -1);

   /* decode silenceSuppression */
   invokeStartElement (pctxt, "silenceSuppression", -1);

   stat = DECODEBIT (pctxt, &pvalue->silenceSuppression);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->silenceSuppression);
   invokeEndElement (pctxt, "silenceSuppression", -1);

   /* decode g723AnnexCAudioMode */
   if (pvalue->m.g723AnnexCAudioModePresent) {
      invokeStartElement (pctxt, "g723AnnexCAudioMode", -1);

      stat = asn1PD_H245G7231AnnexCCapability_g723AnnexCAudioMode (pctxt, &pvalue->g723AnnexCAudioMode);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "g723AnnexCAudioMode", -1);

   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245GSMAudioCapability (OOCTXT* pctxt, H245GSMAudioCapability* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode audioUnitSize */
   invokeStartElement (pctxt, "audioUnitSize", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->audioUnitSize, 1, 256);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->audioUnitSize);
   invokeEndElement (pctxt, "audioUnitSize", -1);

   /* decode comfortNoise */
   invokeStartElement (pctxt, "comfortNoise", -1);

   stat = DECODEBIT (pctxt, &pvalue->comfortNoise);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->comfortNoise);
   invokeEndElement (pctxt, "comfortNoise", -1);

   /* decode scrambled */
   invokeStartElement (pctxt, "scrambled", -1);

   stat = DECODEBIT (pctxt, &pvalue->scrambled);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->scrambled);
   invokeEndElement (pctxt, "scrambled", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245G729Extensions (OOCTXT* pctxt, H245G729Extensions* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.audioUnitPresent = optbit;

   /* decode root elements */
   /* decode audioUnit */
   if (pvalue->m.audioUnitPresent) {
      invokeStartElement (pctxt, "audioUnit", -1);

      stat = decodeConsUInt16 (pctxt, &pvalue->audioUnit, 1, 256);
      if (stat != 0) return stat;

      invokeUIntValue (pctxt, pvalue->audioUnit);
      invokeEndElement (pctxt, "audioUnit", -1);

   }

   /* decode annexA */
   invokeStartElement (pctxt, "annexA", -1);

   stat = DECODEBIT (pctxt, &pvalue->annexA);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->annexA);
   invokeEndElement (pctxt, "annexA", -1);

   /* decode annexB */
   invokeStartElement (pctxt, "annexB", -1);

   stat = DECODEBIT (pctxt, &pvalue->annexB);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->annexB);
   invokeEndElement (pctxt, "annexB", -1);

   /* decode annexD */
   invokeStartElement (pctxt, "annexD", -1);

   stat = DECODEBIT (pctxt, &pvalue->annexD);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->annexD);
   invokeEndElement (pctxt, "annexD", -1);

   /* decode annexE */
   invokeStartElement (pctxt, "annexE", -1);

   stat = DECODEBIT (pctxt, &pvalue->annexE);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->annexE);
   invokeEndElement (pctxt, "annexE", -1);

   /* decode annexF */
   invokeStartElement (pctxt, "annexF", -1);

   stat = DECODEBIT (pctxt, &pvalue->annexF);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->annexF);
   invokeEndElement (pctxt, "annexF", -1);

   /* decode annexG */
   invokeStartElement (pctxt, "annexG", -1);

   stat = DECODEBIT (pctxt, &pvalue->annexG);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->annexG);
   invokeEndElement (pctxt, "annexG", -1);

   /* decode annexH */
   invokeStartElement (pctxt, "annexH", -1);

   stat = DECODEBIT (pctxt, &pvalue->annexH);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->annexH);
   invokeEndElement (pctxt, "annexH", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245VBDCapability (OOCTXT* pctxt, H245VBDCapability* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode type */
   invokeStartElement (pctxt, "type", -1);

   pvalue->type = memAllocTypeZ (pctxt, H245AudioCapability);

   stat = asn1PD_H245AudioCapability (pctxt, (H245AudioCapability*)pvalue->type);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "type", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245NoPTAudioTelephonyEventCapability (OOCTXT* pctxt, H245NoPTAudioTelephonyEventCapability* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode audioTelephoneEvent */
   invokeStartElement (pctxt, "audioTelephoneEvent", -1);

   stat = decodeVarWidthCharString (pctxt, &pvalue->audioTelephoneEvent);
   if (stat != 0) return stat;

   invokeCharStrValue (pctxt, pvalue->audioTelephoneEvent);
   invokeEndElement (pctxt, "audioTelephoneEvent", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245NoPTAudioToneCapability (OOCTXT* pctxt, H245NoPTAudioToneCapability* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245AudioCapability (OOCTXT* pctxt, H245AudioCapability* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 13);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            invokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = memAllocTypeZ (pctxt,
               H245NonStandardParameter);

            stat = asn1PD_H245NonStandardParameter (pctxt, pvalue->u.nonStandard);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* g711Alaw64k */
         case 1:
            invokeStartElement (pctxt, "g711Alaw64k", -1);

            stat = decodeConsUInt16 (pctxt, &pvalue->u.g711Alaw64k, 1, 256);
            if (stat != 0) return stat;

            invokeUIntValue (pctxt, pvalue->u.g711Alaw64k);
            invokeEndElement (pctxt, "g711Alaw64k", -1);

            break;

         /* g711Alaw56k */
         case 2:
            invokeStartElement (pctxt, "g711Alaw56k", -1);

            stat = decodeConsUInt16 (pctxt, &pvalue->u.g711Alaw56k, 1, 256);
            if (stat != 0) return stat;

            invokeUIntValue (pctxt, pvalue->u.g711Alaw56k);
            invokeEndElement (pctxt, "g711Alaw56k", -1);

            break;

         /* g711Ulaw64k */
         case 3:
            invokeStartElement (pctxt, "g711Ulaw64k", -1);

            stat = decodeConsUInt16 (pctxt, &pvalue->u.g711Ulaw64k, 1, 256);
            if (stat != 0) return stat;

            invokeUIntValue (pctxt, pvalue->u.g711Ulaw64k);
            invokeEndElement (pctxt, "g711Ulaw64k", -1);

            break;

         /* g711Ulaw56k */
         case 4:
            invokeStartElement (pctxt, "g711Ulaw56k", -1);

            stat = decodeConsUInt16 (pctxt, &pvalue->u.g711Ulaw56k, 1, 256);
            if (stat != 0) return stat;

            invokeUIntValue (pctxt, pvalue->u.g711Ulaw56k);
            invokeEndElement (pctxt, "g711Ulaw56k", -1);

            break;

         /* g722_64k */
         case 5:
            invokeStartElement (pctxt, "g722_64k", -1);

            stat = decodeConsUInt16 (pctxt, &pvalue->u.g722_64k, 1, 256);
            if (stat != 0) return stat;

            invokeUIntValue (pctxt, pvalue->u.g722_64k);
            invokeEndElement (pctxt, "g722_64k", -1);

            break;

         /* g722_56k */
         case 6:
            invokeStartElement (pctxt, "g722_56k", -1);

            stat = decodeConsUInt16 (pctxt, &pvalue->u.g722_56k, 1, 256);
            if (stat != 0) return stat;

            invokeUIntValue (pctxt, pvalue->u.g722_56k);
            invokeEndElement (pctxt, "g722_56k", -1);

            break;

         /* g722_48k */
         case 7:
            invokeStartElement (pctxt, "g722_48k", -1);

            stat = decodeConsUInt16 (pctxt, &pvalue->u.g722_48k, 1, 256);
            if (stat != 0) return stat;

            invokeUIntValue (pctxt, pvalue->u.g722_48k);
            invokeEndElement (pctxt, "g722_48k", -1);

            break;

         /* g7231 */
         case 8:
            invokeStartElement (pctxt, "g7231", -1);

            pvalue->u.g7231 = memAllocTypeZ (pctxt,
               H245AudioCapability_g7231);

            stat = asn1PD_H245AudioCapability_g7231 (pctxt, pvalue->u.g7231);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "g7231", -1);

            break;

         /* g728 */
         case 9:
            invokeStartElement (pctxt, "g728", -1);

            stat = decodeConsUInt16 (pctxt, &pvalue->u.g728, 1, 256);
            if (stat != 0) return stat;

            invokeUIntValue (pctxt, pvalue->u.g728);
            invokeEndElement (pctxt, "g728", -1);

            break;

         /* g729 */
         case 10:
            invokeStartElement (pctxt, "g729", -1);

            stat = decodeConsUInt16 (pctxt, &pvalue->u.g729, 1, 256);
            if (stat != 0) return stat;

            invokeUIntValue (pctxt, pvalue->u.g729);
            invokeEndElement (pctxt, "g729", -1);

            break;

         /* g729AnnexA */
         case 11:
            invokeStartElement (pctxt, "g729AnnexA", -1);

            stat = decodeConsUInt16 (pctxt, &pvalue->u.g729AnnexA, 1, 256);
            if (stat != 0) return stat;

            invokeUIntValue (pctxt, pvalue->u.g729AnnexA);
            invokeEndElement (pctxt, "g729AnnexA", -1);

            break;

         /* is11172AudioCapability */
         case 12:
            invokeStartElement (pctxt, "is11172AudioCapability", -1);

            pvalue->u.is11172AudioCapability = memAllocTypeZ (pctxt,
               H245IS11172AudioCapability);

            stat = asn1PD_H245IS11172AudioCapability (pctxt, pvalue->u.is11172AudioCapability);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "is11172AudioCapability", -1);

            break;

         /* is13818AudioCapability */
         case 13:
            invokeStartElement (pctxt, "is13818AudioCapability", -1);

            pvalue->u.is13818AudioCapability = memAllocTypeZ (pctxt,
               H245IS13818AudioCapability);

            stat = asn1PD_H245IS13818AudioCapability (pctxt, pvalue->u.is13818AudioCapability);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "is13818AudioCapability", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 15;

      if (pvalue->t < 15) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt,
         (ASN1OCTET*)openType.data, openType.numocts);

      switch (pvalue->t) {
         /* g729wAnnexB */
         case 15:
            invokeStartElement (pctxt, "g729wAnnexB", -1);

            stat = decodeConsUInt16 (pctxt, &pvalue->u.g729wAnnexB, 1, 256);
            if (stat != 0) return stat;

            invokeUIntValue (pctxt, pvalue->u.g729wAnnexB);
            invokeEndElement (pctxt, "g729wAnnexB", -1);

            break;

         /* g729AnnexAwAnnexB */
         case 16:
            invokeStartElement (pctxt, "g729AnnexAwAnnexB", -1);

            stat = decodeConsUInt16 (pctxt, &pvalue->u.g729AnnexAwAnnexB, 1, 256);
            if (stat != 0) return stat;

            invokeUIntValue (pctxt, pvalue->u.g729AnnexAwAnnexB);
            invokeEndElement (pctxt, "g729AnnexAwAnnexB", -1);

            break;

         /* g7231AnnexCCapability */
         case 17:
            invokeStartElement (pctxt, "g7231AnnexCCapability", -1);

            pvalue->u.g7231AnnexCCapability = memAllocTypeZ (pctxt,
               H245G7231AnnexCCapability);

            stat = asn1PD_H245G7231AnnexCCapability (pctxt, pvalue->u.g7231AnnexCCapability);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "g7231AnnexCCapability", -1);

            break;

         /* gsmFullRate */
         case 18:
            invokeStartElement (pctxt, "gsmFullRate", -1);

            pvalue->u.gsmFullRate = memAllocTypeZ (pctxt,
               H245GSMAudioCapability);

            stat = asn1PD_H245GSMAudioCapability (pctxt, pvalue->u.gsmFullRate);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "gsmFullRate", -1);

            break;

         /* gsmHalfRate */
         case 19:
            invokeStartElement (pctxt, "gsmHalfRate", -1);

            pvalue->u.gsmHalfRate = memAllocTypeZ (pctxt,
               H245GSMAudioCapability);

            stat = asn1PD_H245GSMAudioCapability (pctxt, pvalue->u.gsmHalfRate);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "gsmHalfRate", -1);

            break;

         /* gsmEnhancedFullRate */
         case 20:
            invokeStartElement (pctxt, "gsmEnhancedFullRate", -1);

            pvalue->u.gsmEnhancedFullRate = memAllocTypeZ (pctxt,
               H245GSMAudioCapability);

            stat = asn1PD_H245GSMAudioCapability (pctxt, pvalue->u.gsmEnhancedFullRate);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "gsmEnhancedFullRate", -1);

            break;

         /* genericAudioCapability */
         case 21:
            invokeStartElement (pctxt, "genericAudioCapability", -1);

            pvalue->u.genericAudioCapability = memAllocTypeZ (pctxt,
               H245GenericCapability);

            stat = asn1PD_H245GenericCapability (pctxt, pvalue->u.genericAudioCapability);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "genericAudioCapability", -1);

            break;

         /* g729Extensions */
         case 22:
            invokeStartElement (pctxt, "g729Extensions", -1);

            pvalue->u.g729Extensions = memAllocTypeZ (pctxt,
               H245G729Extensions);

            stat = asn1PD_H245G729Extensions (pctxt, pvalue->u.g729Extensions);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "g729Extensions", -1);

            break;

         /* vbd */
         case 23:
            invokeStartElement (pctxt, "vbd", -1);

            pvalue->u.vbd = memAllocTypeZ (pctxt, H245VBDCapability);

            stat = asn1PD_H245VBDCapability (pctxt, pvalue->u.vbd);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "vbd", -1);

            break;

         /* audioTelephonyEvent */
         case 24:
            invokeStartElement (pctxt, "audioTelephonyEvent", -1);

            pvalue->u.audioTelephonyEvent = memAllocTypeZ (pctxt,
               H245NoPTAudioTelephonyEventCapability);

            stat = asn1PD_H245NoPTAudioTelephonyEventCapability (pctxt, pvalue->u.audioTelephonyEvent);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "audioTelephonyEvent", -1);

            break;

         /* audioTone */
         case 25:
            invokeStartElement (pctxt, "audioTone", -1);

            pvalue->u.audioTone = memAllocTypeZ (pctxt,
               H245NoPTAudioToneCapability);

            stat = asn1PD_H245NoPTAudioToneCapability (pctxt, pvalue->u.audioTone);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "audioTone", -1);

            break;

         default:;
      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

EXTERN int asn1PD_H245Capability_h233EncryptionReceiveCapability (OOCTXT* pctxt, H245Capability_h233EncryptionReceiveCapability* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode h233IVResponseTime */
   invokeStartElement (pctxt, "h233IVResponseTime", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->h233IVResponseTime, 0, 255);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->h233IVResponseTime);
   invokeEndElement (pctxt, "h233IVResponseTime", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245_SeqOfH245NonStandardParameter (OOCTXT* pctxt, H245_SeqOfH245NonStandardParameter* pvalue)
{
   int stat = 0;
   H245NonStandardParameter* pdata;
   DListNode* pnode;
   OOUINT32 count = 0;
   OOUINT32 xx1 = 0;
   int lstat;
   OOUINT32 total = 0;

   dListInit (pvalue);

   for (;;) {
      /* decode length determinant */

      lstat = decodeLength (pctxt, &count);
      if (lstat != 0 && lstat != ASN_OK_FRAG) {
         return lstat;
      }
      else if (count == 0) break;
      total += count;

      /* decode elements */

      for (; xx1 < total; xx1++) {
         invokeStartElement (pctxt, "elem", xx1);

         dListAllocNodeAndData (pctxt, H245NonStandardParameter, &pnode, &pdata);

         stat = asn1PD_H245NonStandardParameter (pctxt, pdata);
         if (stat != 0) return stat;

         invokeEndElement (pctxt, "elem", xx1);

         dListAppendNode2 (pvalue, pnode);
      }

      if (lstat == 0) break;
   }

   return (stat);
}

EXTERN int asn1PD_H245ConferenceCapability (OOCTXT* pctxt, H245ConferenceCapability* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.nonStandardDataPresent = optbit;

   /* decode root elements */
   /* decode nonStandardData */
   if (pvalue->m.nonStandardDataPresent) {
      invokeStartElement (pctxt, "nonStandardData", -1);

      stat = asn1PD_H245_SeqOfH245NonStandardParameter (pctxt, &pvalue->nonStandardData);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "nonStandardData", -1);

   }

   /* decode chairControlCapability */
   invokeStartElement (pctxt, "chairControlCapability", -1);

   stat = DECODEBIT (pctxt, &pvalue->chairControlCapability);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->chairControlCapability);
   invokeEndElement (pctxt, "chairControlCapability", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return stat;

            if (i < 2) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt,
                  (ASN1OCTET*)openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     if (openType.numocts == 0) break;

                     pvalue->m.videoIndicateMixingCapabilityPresent = 1;

                     invokeStartElement (pctxt, "videoIndicateMixingCapability", -1);

                     stat = DECODEBIT (pctxt, &pvalue->videoIndicateMixingCapability);
                     if (stat != 0) return stat;

                     invokeBoolValue (pctxt, pvalue->videoIndicateMixingCapability);
                     invokeEndElement (pctxt, "videoIndicateMixingCapability", -1);

                     break;

                  case 1:
                     if (openType.numocts == 0) break;

                     pvalue->m.multipointVisualizationCapabilityPresent = 1;

                     invokeStartElement (pctxt, "multipointVisualizationCapability", -1);

                     stat = DECODEBIT (pctxt, &pvalue->multipointVisualizationCapability);
                     if (stat != 0) return stat;

                     invokeBoolValue (pctxt, pvalue->multipointVisualizationCapability);
                     invokeEndElement (pctxt, "multipointVisualizationCapability", -1);

                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245MediaEncryptionAlgorithm (OOCTXT* pctxt, H245MediaEncryptionAlgorithm* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            invokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = memAllocTypeZ (pctxt,
               H245NonStandardParameter);

            stat = asn1PD_H245NonStandardParameter (pctxt, pvalue->u.nonStandard);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* algorithm */
         case 1:
            invokeStartElement (pctxt, "algorithm", -1);

            pvalue->u.algorithm = memAllocTypeZ (pctxt, ASN1OBJID);

            stat = decodeObjectIdentifier (pctxt, pvalue->u.algorithm);
            if (stat != 0) return stat;

            invokeOidValue (pctxt, pvalue->u.algorithm->numids, pvalue->u.algorithm->subid);
            invokeEndElement (pctxt, "algorithm", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245EncryptionCapability (OOCTXT* pctxt, H245EncryptionCapability* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 256, 0 };
   int stat = 0;
   H245MediaEncryptionAlgorithm* pdata;
   DListNode* pnode;
   OOUINT32 count = 0;
   OOUINT32 xx1 = 0;

   /* decode length determinant */

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeLength (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      invokeStartElement (pctxt, "elem", xx1);

      dListAllocNodeAndData (pctxt, H245MediaEncryptionAlgorithm, &pnode, &pdata);

      stat = asn1PD_H245MediaEncryptionAlgorithm (pctxt, pdata);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "elem", xx1);

      dListAppendNode2 (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1PD_H245AuthenticationCapability (OOCTXT* pctxt, H245AuthenticationCapability* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.nonStandardPresent = optbit;

   /* decode root elements */
   /* decode nonStandard */
   if (pvalue->m.nonStandardPresent) {
      invokeStartElement (pctxt, "nonStandard", -1);

      stat = asn1PD_H245NonStandardParameter (pctxt, &pvalue->nonStandard);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "nonStandard", -1);

   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return stat;

            if (i < 1) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt,
                  (ASN1OCTET*)openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     if (openType.numocts == 0) break;

                     pvalue->m.antiSpamAlgorithmPresent = 1;

                     invokeStartElement (pctxt, "antiSpamAlgorithm", -1);

                     stat = decodeObjectIdentifier (pctxt, &pvalue->antiSpamAlgorithm);
                     if (stat != 0) return stat;

                     invokeOidValue (pctxt, pvalue->antiSpamAlgorithm.numids, pvalue->antiSpamAlgorithm.subid);
                     invokeEndElement (pctxt, "antiSpamAlgorithm", -1);

                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245IntegrityCapability (OOCTXT* pctxt, H245IntegrityCapability* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.nonStandardPresent = optbit;

   /* decode root elements */
   /* decode nonStandard */
   if (pvalue->m.nonStandardPresent) {
      invokeStartElement (pctxt, "nonStandard", -1);

      stat = asn1PD_H245NonStandardParameter (pctxt, &pvalue->nonStandard);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "nonStandard", -1);

   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245EncryptionAuthenticationAndIntegrity (OOCTXT* pctxt, H245EncryptionAuthenticationAndIntegrity* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;
   OOUINT32 j = 0;
   OOBOOL optbits[3];

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   for (i = 0; i < 3; i++) {
      stat = DECODEBIT (pctxt, &optbits[i]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i = 0; i < 3; i++) {
      switch (i) {
         case 0:
         /* decode encryptionCapability */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "encryptionCapability", -1);

            stat = asn1PD_H245EncryptionCapability (pctxt, &pvalue->encryptionCapability);

            pvalue->m.encryptionCapabilityPresent = 1;
            invokeEndElement (pctxt, "encryptionCapability", -1);

         }
         break;

         case 1:
         /* decode authenticationCapability */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "authenticationCapability", -1);

            stat = asn1PD_H245AuthenticationCapability (pctxt, &pvalue->authenticationCapability);

            pvalue->m.authenticationCapabilityPresent = 1;
            invokeEndElement (pctxt, "authenticationCapability", -1);

         }
         break;

         case 2:
         /* decode integrityCapability */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "integrityCapability", -1);

            stat = asn1PD_H245IntegrityCapability (pctxt, &pvalue->integrityCapability);

            pvalue->m.integrityCapabilityPresent = 1;
            invokeEndElement (pctxt, "integrityCapability", -1);

         }
         break;

         default: j++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return stat;

            if (i < 1) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt,
                  (ASN1OCTET*)openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     if (openType.numocts == 0) break;

                     pvalue->m.genericH235SecurityCapabilityPresent = 1;

                     invokeStartElement (pctxt, "genericH235SecurityCapability", -1);

                     stat = asn1PD_H245GenericCapability (pctxt, &pvalue->genericH235SecurityCapability);
                     if (stat != 0) return stat;

                     invokeEndElement (pctxt, "genericH235SecurityCapability", -1);

                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245H235SecurityCapability (OOCTXT* pctxt, H245H235SecurityCapability* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode encryptionAuthenticationAndIntegrity */
   invokeStartElement (pctxt, "encryptionAuthenticationAndIntegrity", -1);

   stat = asn1PD_H245EncryptionAuthenticationAndIntegrity (pctxt, &pvalue->encryptionAuthenticationAndIntegrity);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "encryptionAuthenticationAndIntegrity", -1);

   /* decode mediaCapability */
   invokeStartElement (pctxt, "mediaCapability", -1);

   stat = asn1PD_H245CapabilityTableEntryNumber (pctxt, &pvalue->mediaCapability);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "mediaCapability", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245UserInputCapability_nonStandard (OOCTXT* pctxt, H245UserInputCapability_nonStandard* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 16, 0 };
   int stat = 0;
   H245NonStandardParameter* pdata;
   DListNode* pnode;
   OOUINT32 count = 0;
   OOUINT32 xx1 = 0;

   /* decode length determinant */

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeLength (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      invokeStartElement (pctxt, "elem", xx1);

      dListAllocNodeAndData (pctxt, H245NonStandardParameter, &pnode, &pdata);

      stat = asn1PD_H245NonStandardParameter (pctxt, pdata);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "elem", xx1);

      dListAppendNode2 (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1PD_H245UserInputCapability (OOCTXT* pctxt, H245UserInputCapability* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 5);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            invokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = memAllocTypeZ (pctxt,
               H245UserInputCapability_nonStandard);

            stat = asn1PD_H245UserInputCapability_nonStandard (pctxt, pvalue->u.nonStandard);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* basicString */
         case 1:
            invokeStartElement (pctxt, "basicString", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "basicString", -1);

            break;

         /* iA5String */
         case 2:
            invokeStartElement (pctxt, "iA5String", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "iA5String", -1);

            break;

         /* generalString */
         case 3:
            invokeStartElement (pctxt, "generalString", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "generalString", -1);

            break;

         /* dtmf */
         case 4:
            invokeStartElement (pctxt, "dtmf", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "dtmf", -1);

            break;

         /* hookflash */
         case 5:
            invokeStartElement (pctxt, "hookflash", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "hookflash", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 7;

      if (pvalue->t < 7) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt,
         (ASN1OCTET*)openType.data, openType.numocts);

      switch (pvalue->t) {
         /* extendedAlphanumeric */
         case 7:
            invokeStartElement (pctxt, "extendedAlphanumeric", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "extendedAlphanumeric", -1);

            break;

         /* encryptedBasicString */
         case 8:
            invokeStartElement (pctxt, "encryptedBasicString", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "encryptedBasicString", -1);

            break;

         /* encryptedIA5String */
         case 9:
            invokeStartElement (pctxt, "encryptedIA5String", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "encryptedIA5String", -1);

            break;

         /* encryptedGeneralString */
         case 10:
            invokeStartElement (pctxt, "encryptedGeneralString", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "encryptedGeneralString", -1);

            break;

         /* secureDTMF */
         case 11:
            invokeStartElement (pctxt, "secureDTMF", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "secureDTMF", -1);

            break;

         /* genericUserInputCapability */
         case 12:
            invokeStartElement (pctxt, "genericUserInputCapability", -1);

            pvalue->u.genericUserInputCapability = memAllocTypeZ (pctxt,
               H245GenericCapability);

            stat = asn1PD_H245GenericCapability (pctxt, pvalue->u.genericUserInputCapability);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "genericUserInputCapability", -1);

            break;

         default:;
      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

EXTERN int asn1PD_H245MultiplexFormat (OOCTXT* pctxt, H245MultiplexFormat* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            invokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = memAllocTypeZ (pctxt,
               H245NonStandardParameter);

            stat = asn1PD_H245NonStandardParameter (pctxt, pvalue->u.nonStandard);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* h222Capability */
         case 1:
            invokeStartElement (pctxt, "h222Capability", -1);

            pvalue->u.h222Capability = memAllocTypeZ (pctxt,
               H245H222Capability);

            stat = asn1PD_H245H222Capability (pctxt, pvalue->u.h222Capability);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "h222Capability", -1);

            break;

         /* h223Capability */
         case 2:
            invokeStartElement (pctxt, "h223Capability", -1);

            pvalue->u.h223Capability = memAllocTypeZ (pctxt,
               H245H223Capability);

            stat = asn1PD_H245H223Capability (pctxt, pvalue->u.h223Capability);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "h223Capability", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 4;

      if (pvalue->t < 4) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245AlternativeCapabilitySet (OOCTXT* pctxt, H245AlternativeCapabilitySet* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 256, 0 };
   int stat = 0;
   OOUINT32 xx1 = 0;

   /* decode length determinant */

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeLength (pctxt, &pvalue->n);
   if (stat != 0) return stat;

   /* decode elements */

   if (256 < pvalue->n) {
      return stat;
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      invokeStartElement (pctxt, "elem", xx1);

      stat = asn1PD_H245CapabilityTableEntryNumber (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "elem", xx1);

   }

   return (stat);
}

EXTERN int asn1PD_H245MultiplexedStreamCapability_capabilityOnMuxStream (OOCTXT* pctxt, H245MultiplexedStreamCapability_capabilityOnMuxStream* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 256, 0 };
   int stat = 0;
   H245AlternativeCapabilitySet* pdata;
   DListNode* pnode;
   OOUINT32 count = 0;
   OOUINT32 xx1 = 0;

   /* decode length determinant */

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeLength (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      invokeStartElement (pctxt, "elem", xx1);

      dListAllocNodeAndData (pctxt, H245AlternativeCapabilitySet, &pnode, &pdata);

      stat = asn1PD_H245AlternativeCapabilitySet (pctxt, pdata);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "elem", xx1);

      dListAppendNode2 (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1PD_H245MultiplexedStreamCapability (OOCTXT* pctxt, H245MultiplexedStreamCapability* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.capabilityOnMuxStreamPresent = optbit;

   /* decode root elements */
   /* decode multiplexFormat */
   invokeStartElement (pctxt, "multiplexFormat", -1);

   stat = asn1PD_H245MultiplexFormat (pctxt, &pvalue->multiplexFormat);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "multiplexFormat", -1);

   /* decode controlOnMuxStream */
   invokeStartElement (pctxt, "controlOnMuxStream", -1);

   stat = DECODEBIT (pctxt, &pvalue->controlOnMuxStream);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->controlOnMuxStream);
   invokeEndElement (pctxt, "controlOnMuxStream", -1);

   /* decode capabilityOnMuxStream */
   if (pvalue->m.capabilityOnMuxStreamPresent) {
      invokeStartElement (pctxt, "capabilityOnMuxStream", -1);

      stat = asn1PD_H245MultiplexedStreamCapability_capabilityOnMuxStream (pctxt, &pvalue->capabilityOnMuxStream);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "capabilityOnMuxStream", -1);

   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245AudioTelephonyEventCapability (OOCTXT* pctxt, H245AudioTelephonyEventCapability* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode dynamicRTPPayloadType */
   invokeStartElement (pctxt, "dynamicRTPPayloadType", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->dynamicRTPPayloadType, 96, 127);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->dynamicRTPPayloadType);
   invokeEndElement (pctxt, "dynamicRTPPayloadType", -1);

   /* decode audioTelephoneEvent */
   invokeStartElement (pctxt, "audioTelephoneEvent", -1);

   stat = decodeVarWidthCharString (pctxt, &pvalue->audioTelephoneEvent);
   if (stat != 0) return stat;

   invokeCharStrValue (pctxt, pvalue->audioTelephoneEvent);
   invokeEndElement (pctxt, "audioTelephoneEvent", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245AudioToneCapability (OOCTXT* pctxt, H245AudioToneCapability* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode dynamicRTPPayloadType */
   invokeStartElement (pctxt, "dynamicRTPPayloadType", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->dynamicRTPPayloadType, 96, 127);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->dynamicRTPPayloadType);
   invokeEndElement (pctxt, "dynamicRTPPayloadType", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245DepFECCapability_rfc2733_separateStream (OOCTXT* pctxt, H245DepFECCapability_rfc2733_separateStream* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode separatePort */
   invokeStartElement (pctxt, "separatePort", -1);

   stat = DECODEBIT (pctxt, &pvalue->separatePort);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->separatePort);
   invokeEndElement (pctxt, "separatePort", -1);

   /* decode samePort */
   invokeStartElement (pctxt, "samePort", -1);

   stat = DECODEBIT (pctxt, &pvalue->samePort);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->samePort);
   invokeEndElement (pctxt, "samePort", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245DepFECCapability_rfc2733 (OOCTXT* pctxt, H245DepFECCapability_rfc2733* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode redundancyEncoding */
   invokeStartElement (pctxt, "redundancyEncoding", -1);

   stat = DECODEBIT (pctxt, &pvalue->redundancyEncoding);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->redundancyEncoding);
   invokeEndElement (pctxt, "redundancyEncoding", -1);

   /* decode separateStream */
   invokeStartElement (pctxt, "separateStream", -1);

   stat = asn1PD_H245DepFECCapability_rfc2733_separateStream (pctxt, &pvalue->separateStream);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "separateStream", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245DepFECCapability (OOCTXT* pctxt, H245DepFECCapability* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 0);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* rfc2733 */
         case 0:
            invokeStartElement (pctxt, "rfc2733", -1);

            pvalue->u.rfc2733 = memAllocTypeZ (pctxt,
               H245DepFECCapability_rfc2733);

            stat = asn1PD_H245DepFECCapability_rfc2733 (pctxt, pvalue->u.rfc2733);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "rfc2733", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 2;

      if (pvalue->t < 2) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245MultiplePayloadStreamCapability_capabilities (OOCTXT* pctxt, H245MultiplePayloadStreamCapability_capabilities* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 256, 0 };
   int stat = 0;
   H245AlternativeCapabilitySet* pdata;
   DListNode* pnode;
   OOUINT32 count = 0;
   OOUINT32 xx1 = 0;

   /* decode length determinant */

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeLength (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      invokeStartElement (pctxt, "elem", xx1);

      dListAllocNodeAndData (pctxt, H245AlternativeCapabilitySet, &pnode, &pdata);

      stat = asn1PD_H245AlternativeCapabilitySet (pctxt, pdata);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "elem", xx1);

      dListAppendNode2 (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1PD_H245MultiplePayloadStreamCapability (OOCTXT* pctxt, H245MultiplePayloadStreamCapability* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode capabilities */
   invokeStartElement (pctxt, "capabilities", -1);

   stat = asn1PD_H245MultiplePayloadStreamCapability_capabilities (pctxt, &pvalue->capabilities);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "capabilities", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245FECCapability_rfc2733Format (OOCTXT* pctxt, H245FECCapability_rfc2733Format* pvalue)
{
   int stat = 0;
   OOUINT32 ui;

   stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
   if (stat != 0) return stat;
   else pvalue->t = ui + 1;

   switch (ui) {
      /* rfc2733rfc2198 */
      case 0:
         invokeStartElement (pctxt, "rfc2733rfc2198", -1);

         stat = asn1PD_H245MaxRedundancy (pctxt, &pvalue->u.rfc2733rfc2198);
         if (stat != 0) return stat;

         invokeEndElement (pctxt, "rfc2733rfc2198", -1);

         break;

      /* rfc2733sameport */
      case 1:
         invokeStartElement (pctxt, "rfc2733sameport", -1);

         stat = asn1PD_H245MaxRedundancy (pctxt, &pvalue->u.rfc2733sameport);
         if (stat != 0) return stat;

         invokeEndElement (pctxt, "rfc2733sameport", -1);

         break;

      /* rfc2733diffport */
      case 2:
         invokeStartElement (pctxt, "rfc2733diffport", -1);

         stat = asn1PD_H245MaxRedundancy (pctxt, &pvalue->u.rfc2733diffport);
         if (stat != 0) return stat;

         invokeEndElement (pctxt, "rfc2733diffport", -1);

         break;

      default:
         return ASN_E_INVOPT;
   }

   return (stat);
}

EXTERN int asn1PD_H245FECCapability (OOCTXT* pctxt, H245FECCapability* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.fecSchemePresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.rfc2733FormatPresent = optbit;

   /* decode root elements */
   /* decode protectedCapability */
   invokeStartElement (pctxt, "protectedCapability", -1);

   stat = asn1PD_H245CapabilityTableEntryNumber (pctxt, &pvalue->protectedCapability);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "protectedCapability", -1);

   /* decode fecScheme */
   if (pvalue->m.fecSchemePresent) {
      invokeStartElement (pctxt, "fecScheme", -1);

      stat = decodeObjectIdentifier (pctxt, &pvalue->fecScheme);
      if (stat != 0) return stat;

      invokeOidValue (pctxt, pvalue->fecScheme.numids, pvalue->fecScheme.subid);
      invokeEndElement (pctxt, "fecScheme", -1);

   }

   /* decode rfc2733Format */
   if (pvalue->m.rfc2733FormatPresent) {
      invokeStartElement (pctxt, "rfc2733Format", -1);

      stat = asn1PD_H245FECCapability_rfc2733Format (pctxt, &pvalue->rfc2733Format);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "rfc2733Format", -1);

   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245Capability (OOCTXT* pctxt, H245Capability* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 11);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            invokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = memAllocTypeZ (pctxt,
               H245NonStandardParameter);

            stat = asn1PD_H245NonStandardParameter (pctxt, pvalue->u.nonStandard);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* receiveVideoCapability */
         case 1:
            invokeStartElement (pctxt, "receiveVideoCapability", -1);

            pvalue->u.receiveVideoCapability = memAllocTypeZ (pctxt,
               H245VideoCapability);

            stat = asn1PD_H245VideoCapability (pctxt, pvalue->u.receiveVideoCapability);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "receiveVideoCapability", -1);

            break;

         /* transmitVideoCapability */
         case 2:
            invokeStartElement (pctxt, "transmitVideoCapability", -1);

            pvalue->u.transmitVideoCapability = memAllocTypeZ (pctxt,
               H245VideoCapability);

            stat = asn1PD_H245VideoCapability (pctxt, pvalue->u.transmitVideoCapability);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "transmitVideoCapability", -1);

            break;

         /* receiveAndTransmitVideoCapability */
         case 3:
            invokeStartElement (pctxt, "receiveAndTransmitVideoCapability", -1);

            pvalue->u.receiveAndTransmitVideoCapability
                = memAllocTypeZ (pctxt, H245VideoCapability);

            stat = asn1PD_H245VideoCapability (pctxt, pvalue->u.receiveAndTransmitVideoCapability);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "receiveAndTransmitVideoCapability", -1);

            break;

         /* receiveAudioCapability */
         case 4:
            invokeStartElement (pctxt, "receiveAudioCapability", -1);

            pvalue->u.receiveAudioCapability = memAllocTypeZ (pctxt,
               H245AudioCapability);

            stat = asn1PD_H245AudioCapability (pctxt, pvalue->u.receiveAudioCapability);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "receiveAudioCapability", -1);

            break;

         /* transmitAudioCapability */
         case 5:
            invokeStartElement (pctxt, "transmitAudioCapability", -1);

            pvalue->u.transmitAudioCapability = memAllocTypeZ (pctxt,
               H245AudioCapability);

            stat = asn1PD_H245AudioCapability (pctxt, pvalue->u.transmitAudioCapability);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "transmitAudioCapability", -1);

            break;

         /* receiveAndTransmitAudioCapability */
         case 6:
            invokeStartElement (pctxt, "receiveAndTransmitAudioCapability", -1);

            pvalue->u.receiveAndTransmitAudioCapability
                = memAllocTypeZ (pctxt, H245AudioCapability);

            stat = asn1PD_H245AudioCapability (pctxt, pvalue->u.receiveAndTransmitAudioCapability);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "receiveAndTransmitAudioCapability", -1);

            break;

         /* receiveDataApplicationCapability */
         case 7:
            invokeStartElement (pctxt, "receiveDataApplicationCapability", -1);

            pvalue->u.receiveDataApplicationCapability
                = memAllocTypeZ (pctxt, H245DataApplicationCapability);

            stat = asn1PD_H245DataApplicationCapability (pctxt, pvalue->u.receiveDataApplicationCapability);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "receiveDataApplicationCapability", -1);

            break;

         /* transmitDataApplicationCapability */
         case 8:
            invokeStartElement (pctxt, "transmitDataApplicationCapability", -1);

            pvalue->u.transmitDataApplicationCapability
                = memAllocTypeZ (pctxt, H245DataApplicationCapability);

            stat = asn1PD_H245DataApplicationCapability (pctxt, pvalue->u.transmitDataApplicationCapability);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "transmitDataApplicationCapability", -1);

            break;

         /* receiveAndTransmitDataApplicationCapability */
         case 9:
            invokeStartElement (pctxt, "receiveAndTransmitDataApplicationCapability", -1);

            pvalue->u.receiveAndTransmitDataApplicationCapability
                = memAllocTypeZ (pctxt, H245DataApplicationCapability);

            stat = asn1PD_H245DataApplicationCapability (pctxt, pvalue->u.receiveAndTransmitDataApplicationCapability);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "receiveAndTransmitDataApplicationCapability", -1);

            break;

         /* h233EncryptionTransmitCapability */
         case 10:
            invokeStartElement (pctxt, "h233EncryptionTransmitCapability", -1);

            stat = DECODEBIT (pctxt, &pvalue->u.h233EncryptionTransmitCapability);
            if (stat != 0) return stat;

            invokeBoolValue (pctxt, pvalue->u.h233EncryptionTransmitCapability);
            invokeEndElement (pctxt, "h233EncryptionTransmitCapability", -1);

            break;

         /* h233EncryptionReceiveCapability */
         case 11:
            invokeStartElement (pctxt, "h233EncryptionReceiveCapability", -1);

            pvalue->u.h233EncryptionReceiveCapability
                = memAllocTypeZ (pctxt,
               H245Capability_h233EncryptionReceiveCapability);

            stat = asn1PD_H245Capability_h233EncryptionReceiveCapability (pctxt, pvalue->u.h233EncryptionReceiveCapability);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "h233EncryptionReceiveCapability", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 13;

      if (pvalue->t < 13) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt,
         (ASN1OCTET*)openType.data, openType.numocts);

      switch (pvalue->t) {
         /* conferenceCapability */
         case 13:
            invokeStartElement (pctxt, "conferenceCapability", -1);

            pvalue->u.conferenceCapability = memAllocTypeZ (pctxt,
               H245ConferenceCapability);

            stat = asn1PD_H245ConferenceCapability (pctxt, pvalue->u.conferenceCapability);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "conferenceCapability", -1);

            break;

         /* h235SecurityCapability */
         case 14:
            invokeStartElement (pctxt, "h235SecurityCapability", -1);

            pvalue->u.h235SecurityCapability = memAllocTypeZ (pctxt,
               H245H235SecurityCapability);

            stat = asn1PD_H245H235SecurityCapability (pctxt, pvalue->u.h235SecurityCapability);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "h235SecurityCapability", -1);

            break;

         /* maxPendingReplacementFor */
         case 15:
            invokeStartElement (pctxt, "maxPendingReplacementFor", -1);

            stat = decodeConsUInt8 (pctxt, &pvalue->u.maxPendingReplacementFor, 0, 255);
            if (stat != 0) return stat;

            invokeUIntValue (pctxt, pvalue->u.maxPendingReplacementFor);
            invokeEndElement (pctxt, "maxPendingReplacementFor", -1);

            break;

         /* receiveUserInputCapability */
         case 16:
            invokeStartElement (pctxt, "receiveUserInputCapability", -1);

            pvalue->u.receiveUserInputCapability = memAllocTypeZ (pctxt,
               H245UserInputCapability);

            stat = asn1PD_H245UserInputCapability (pctxt, pvalue->u.receiveUserInputCapability);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "receiveUserInputCapability", -1);

            break;

         /* transmitUserInputCapability */
         case 17:
            invokeStartElement (pctxt, "transmitUserInputCapability", -1);

            pvalue->u.transmitUserInputCapability = memAllocTypeZ (pctxt,
               H245UserInputCapability);

            stat = asn1PD_H245UserInputCapability (pctxt, pvalue->u.transmitUserInputCapability);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "transmitUserInputCapability", -1);

            break;

         /* receiveAndTransmitUserInputCapability */
         case 18:
            invokeStartElement (pctxt, "receiveAndTransmitUserInputCapability", -1);

            pvalue->u.receiveAndTransmitUserInputCapability
                = memAllocTypeZ (pctxt, H245UserInputCapability);

            stat = asn1PD_H245UserInputCapability (pctxt, pvalue->u.receiveAndTransmitUserInputCapability);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "receiveAndTransmitUserInputCapability", -1);

            break;

         /* genericControlCapability */
         case 19:
            invokeStartElement (pctxt, "genericControlCapability", -1);

            pvalue->u.genericControlCapability = memAllocTypeZ (pctxt,
               H245GenericCapability);

            stat = asn1PD_H245GenericCapability (pctxt, pvalue->u.genericControlCapability);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "genericControlCapability", -1);

            break;

         /* receiveMultiplexedStreamCapability */
         case 20:
            invokeStartElement (pctxt, "receiveMultiplexedStreamCapability", -1);

            pvalue->u.receiveMultiplexedStreamCapability
                = memAllocTypeZ (pctxt, H245MultiplexedStreamCapability);

            stat = asn1PD_H245MultiplexedStreamCapability (pctxt, pvalue->u.receiveMultiplexedStreamCapability);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "receiveMultiplexedStreamCapability", -1);

            break;

         /* transmitMultiplexedStreamCapability */
         case 21:
            invokeStartElement (pctxt, "transmitMultiplexedStreamCapability", -1);

            pvalue->u.transmitMultiplexedStreamCapability
                = memAllocTypeZ (pctxt, H245MultiplexedStreamCapability);

            stat = asn1PD_H245MultiplexedStreamCapability (pctxt, pvalue->u.transmitMultiplexedStreamCapability);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "transmitMultiplexedStreamCapability", -1);

            break;

         /* receiveAndTransmitMultiplexedStreamCapability */
         case 22:
            invokeStartElement (pctxt, "receiveAndTransmitMultiplexedStreamCapability", -1);

            pvalue->u.receiveAndTransmitMultiplexedStreamCapability
                = memAllocTypeZ (pctxt, H245MultiplexedStreamCapability);

            stat = asn1PD_H245MultiplexedStreamCapability (pctxt, pvalue->u.receiveAndTransmitMultiplexedStreamCapability);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "receiveAndTransmitMultiplexedStreamCapability", -1);

            break;

         /* receiveRTPAudioTelephonyEventCapability */
         case 23:
            invokeStartElement (pctxt, "receiveRTPAudioTelephonyEventCapability", -1);

            pvalue->u.receiveRTPAudioTelephonyEventCapability
                = memAllocTypeZ (pctxt, H245AudioTelephonyEventCapability);

            stat = asn1PD_H245AudioTelephonyEventCapability (pctxt, pvalue->u.receiveRTPAudioTelephonyEventCapability);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "receiveRTPAudioTelephonyEventCapability", -1);

            break;

         /* receiveRTPAudioToneCapability */
         case 24:
            invokeStartElement (pctxt, "receiveRTPAudioToneCapability", -1);

            pvalue->u.receiveRTPAudioToneCapability = memAllocTypeZ (pctxt,
               H245AudioToneCapability);

            stat = asn1PD_H245AudioToneCapability (pctxt, pvalue->u.receiveRTPAudioToneCapability);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "receiveRTPAudioToneCapability", -1);

            break;

         /* depFecCapability */
         case 25:
            invokeStartElement (pctxt, "depFecCapability", -1);

            pvalue->u.depFecCapability = memAllocTypeZ (pctxt,
               H245DepFECCapability);

            stat = asn1PD_H245DepFECCapability (pctxt, pvalue->u.depFecCapability);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "depFecCapability", -1);

            break;

         /* multiplePayloadStreamCapability */
         case 26:
            invokeStartElement (pctxt, "multiplePayloadStreamCapability", -1);

            pvalue->u.multiplePayloadStreamCapability
                = memAllocTypeZ (pctxt,
               H245MultiplePayloadStreamCapability);

            stat = asn1PD_H245MultiplePayloadStreamCapability (pctxt, pvalue->u.multiplePayloadStreamCapability);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "multiplePayloadStreamCapability", -1);

            break;

         /* fecCapability */
         case 27:
            invokeStartElement (pctxt, "fecCapability", -1);

            pvalue->u.fecCapability = memAllocTypeZ (pctxt,
               H245FECCapability);

            stat = asn1PD_H245FECCapability (pctxt, pvalue->u.fecCapability);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "fecCapability", -1);

            break;

         /* redundancyEncodingCap */
         case 28:
            invokeStartElement (pctxt, "redundancyEncodingCap", -1);

            pvalue->u.redundancyEncodingCap = memAllocTypeZ (pctxt,
               H245RedundancyEncodingCapability);

            stat = asn1PD_H245RedundancyEncodingCapability (pctxt, pvalue->u.redundancyEncodingCap);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "redundancyEncodingCap", -1);

            break;

         /* oneOfCapabilities */
         case 29:
            invokeStartElement (pctxt, "oneOfCapabilities", -1);

            pvalue->u.oneOfCapabilities = memAllocTypeZ (pctxt,
               H245AlternativeCapabilitySet);

            stat = asn1PD_H245AlternativeCapabilitySet (pctxt, pvalue->u.oneOfCapabilities);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "oneOfCapabilities", -1);

            break;

         default:;
      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

EXTERN int asn1PD_H245CapabilityTableEntry (OOCTXT* pctxt, H245CapabilityTableEntry* pvalue)
{
   int stat = 0;
   OOBOOL optbit = FALSE;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.capabilityPresent = optbit;

   /* decode root elements */
   /* decode capabilityTableEntryNumber */
   invokeStartElement (pctxt, "capabilityTableEntryNumber", -1);

   stat = asn1PD_H245CapabilityTableEntryNumber (pctxt, &pvalue->capabilityTableEntryNumber);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "capabilityTableEntryNumber", -1);

   /* decode capability */
   if (pvalue->m.capabilityPresent) {
      invokeStartElement (pctxt, "capability", -1);

      stat = asn1PD_H245Capability (pctxt, &pvalue->capability);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "capability", -1);

   }

   return (stat);
}

EXTERN int asn1PD_H245TerminalCapabilitySet_capabilityTable (OOCTXT* pctxt, H245TerminalCapabilitySet_capabilityTable* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 256, 0 };
   int stat = 0;
   H245CapabilityTableEntry* pdata;
   DListNode* pnode;
   OOUINT32 count = 0;
   OOUINT32 xx1 = 0;

   /* decode length determinant */

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeLength (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      invokeStartElement (pctxt, "elem", xx1);

      dListAllocNodeAndData (pctxt, H245CapabilityTableEntry, &pnode, &pdata);

      stat = asn1PD_H245CapabilityTableEntry (pctxt, pdata);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "elem", xx1);

      dListAppendNode2 (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1PD_H245CapabilityDescriptor_simultaneousCapabilities (OOCTXT* pctxt, H245CapabilityDescriptor_simultaneousCapabilities* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 256, 0 };
   int stat = 0;
   H245AlternativeCapabilitySet* pdata;
   DListNode* pnode;
   OOUINT32 count = 0;
   OOUINT32 xx1 = 0;

   /* decode length determinant */

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeLength (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      invokeStartElement (pctxt, "elem", xx1);

      dListAllocNodeAndData (pctxt, H245AlternativeCapabilitySet, &pnode, &pdata);

      stat = asn1PD_H245AlternativeCapabilitySet (pctxt, pdata);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "elem", xx1);

      dListAppendNode2 (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1PD_H245CapabilityDescriptor (OOCTXT* pctxt, H245CapabilityDescriptor* pvalue)
{
   int stat = 0;
   OOBOOL optbit = FALSE;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.simultaneousCapabilitiesPresent = optbit;

   /* decode root elements */
   /* decode capabilityDescriptorNumber */
   invokeStartElement (pctxt, "capabilityDescriptorNumber", -1);

   stat = asn1PD_H245CapabilityDescriptorNumber (pctxt, &pvalue->capabilityDescriptorNumber);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "capabilityDescriptorNumber", -1);

   /* decode simultaneousCapabilities */
   if (pvalue->m.simultaneousCapabilitiesPresent) {
      invokeStartElement (pctxt, "simultaneousCapabilities", -1);

      stat = asn1PD_H245CapabilityDescriptor_simultaneousCapabilities (pctxt, &pvalue->simultaneousCapabilities);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "simultaneousCapabilities", -1);

   }

   return (stat);
}

EXTERN int asn1PD_H245TerminalCapabilitySet_capabilityDescriptors (OOCTXT* pctxt, H245TerminalCapabilitySet_capabilityDescriptors* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 256, 0 };
   int stat = 0;
   H245CapabilityDescriptor* pdata;
   DListNode* pnode;
   OOUINT32 count = 0;
   OOUINT32 xx1 = 0;

   /* decode length determinant */

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeLength (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      invokeStartElement (pctxt, "elem", xx1);

      dListAllocNodeAndData (pctxt, H245CapabilityDescriptor, &pnode, &pdata);

      stat = asn1PD_H245CapabilityDescriptor (pctxt, pdata);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "elem", xx1);

      dListAppendNode2 (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1PD_H245_SeqOfH245GenericInformation (OOCTXT* pctxt, H245_SeqOfH245GenericInformation* pvalue)
{
   int stat = 0;
   H245GenericInformation* pdata;
   DListNode* pnode;
   OOUINT32 count = 0;
   OOUINT32 xx1 = 0;
   int lstat;
   OOUINT32 total = 0;

   dListInit (pvalue);

   for (;;) {
      /* decode length determinant */

      lstat = decodeLength (pctxt, &count);
      if (lstat != 0 && lstat != ASN_OK_FRAG) {
         return lstat;
      }
      else if (count == 0) break;
      total += count;

      /* decode elements */

      for (; xx1 < total; xx1++) {
         invokeStartElement (pctxt, "elem", xx1);

         dListAllocNodeAndData (pctxt, H245GenericInformation, &pnode, &pdata);

         stat = asn1PD_H245GenericInformation (pctxt, pdata);
         if (stat != 0) return stat;

         invokeEndElement (pctxt, "elem", xx1);

         dListAppendNode2 (pvalue, pnode);
      }

      if (lstat == 0) break;
   }

   return (stat);
}

EXTERN int asn1PD_H245TerminalCapabilitySet (OOCTXT* pctxt, H245TerminalCapabilitySet* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;
   OOUINT32 j = 0;
   OOBOOL optbits[3];

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   for (i = 0; i < 3; i++) {
      stat = DECODEBIT (pctxt, &optbits[i]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i = 0; i < 5; i++) {
      switch (i) {
         case 0:
         /* decode sequenceNumber */
         invokeStartElement (pctxt, "sequenceNumber", -1);

         stat = asn1PD_H245SequenceNumber (pctxt, &pvalue->sequenceNumber);

         invokeEndElement (pctxt, "sequenceNumber", -1);

         break;

         case 1:
         /* decode protocolIdentifier */
         invokeStartElement (pctxt, "protocolIdentifier", -1);

         stat = decodeObjectIdentifier (pctxt, &pvalue->protocolIdentifier);

         invokeOidValue (pctxt, pvalue->protocolIdentifier.numids, pvalue->protocolIdentifier.subid);
         invokeEndElement (pctxt, "protocolIdentifier", -1);

         break;

         case 2:
         /* decode multiplexCapability */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "multiplexCapability", -1);

            stat = asn1PD_H245MultiplexCapability (pctxt, &pvalue->multiplexCapability);

            pvalue->m.multiplexCapabilityPresent = 1;
            invokeEndElement (pctxt, "multiplexCapability", -1);

         }
         break;

         case 3:
         /* decode capabilityTable */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "capabilityTable", -1);

            stat = asn1PD_H245TerminalCapabilitySet_capabilityTable (pctxt, &pvalue->capabilityTable);

            pvalue->m.capabilityTablePresent = 1;
            invokeEndElement (pctxt, "capabilityTable", -1);

         }
         break;

         case 4:
         /* decode capabilityDescriptors */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "capabilityDescriptors", -1);

            stat = asn1PD_H245TerminalCapabilitySet_capabilityDescriptors (pctxt, &pvalue->capabilityDescriptors);

            pvalue->m.capabilityDescriptorsPresent = 1;
            invokeEndElement (pctxt, "capabilityDescriptors", -1);

         }
         break;

         default: j++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return stat;

            if (i < 1) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt,
                  (ASN1OCTET*)openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     if (openType.numocts == 0) break;

                     pvalue->m.genericInformationPresent = 1;

                     invokeStartElement (pctxt, "genericInformation", -1);

                     stat = asn1PD_H245_SeqOfH245GenericInformation (pctxt, &pvalue->genericInformation);
                     if (stat != 0) return stat;

                     invokeEndElement (pctxt, "genericInformation", -1);

                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245EncryptionMode (OOCTXT* pctxt, H245EncryptionMode* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            invokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = memAllocTypeZ (pctxt,
               H245NonStandardParameter);

            stat = asn1PD_H245NonStandardParameter (pctxt, pvalue->u.nonStandard);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* h233Encryption */
         case 1:
            invokeStartElement (pctxt, "h233Encryption", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "h233Encryption", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245RedundancyEncodingElement (OOCTXT* pctxt, H245RedundancyEncodingElement* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.payloadTypePresent = optbit;

   /* decode root elements */
   /* decode dataType */
   invokeStartElement (pctxt, "dataType", -1);

   pvalue->dataType = memAllocTypeZ (pctxt, H245DataType);

   stat = asn1PD_H245DataType (pctxt, (H245DataType*)pvalue->dataType);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "dataType", -1);

   /* decode payloadType */
   if (pvalue->m.payloadTypePresent) {
      invokeStartElement (pctxt, "payloadType", -1);

      stat = decodeConsUInt8 (pctxt, &pvalue->payloadType, 0, 127);
      if (stat != 0) return stat;

      invokeUIntValue (pctxt, pvalue->payloadType);
      invokeEndElement (pctxt, "payloadType", -1);

   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245_SeqOfH245RedundancyEncodingElement (OOCTXT* pctxt, H245_SeqOfH245RedundancyEncodingElement* pvalue)
{
   int stat = 0;
   H245RedundancyEncodingElement* pdata;
   DListNode* pnode;
   OOUINT32 count = 0;
   OOUINT32 xx1 = 0;
   int lstat;
   OOUINT32 total = 0;

   dListInit (pvalue);

   for (;;) {
      /* decode length determinant */

      lstat = decodeLength (pctxt, &count);
      if (lstat != 0 && lstat != ASN_OK_FRAG) {
         return lstat;
      }
      else if (count == 0) break;
      total += count;

      /* decode elements */

      for (; xx1 < total; xx1++) {
         invokeStartElement (pctxt, "elem", xx1);

         dListAllocNodeAndData (pctxt, H245RedundancyEncodingElement, &pnode, &pdata);

         stat = asn1PD_H245RedundancyEncodingElement (pctxt, pdata);
         if (stat != 0) return stat;

         invokeEndElement (pctxt, "elem", xx1);

         dListAppendNode2 (pvalue, pnode);
      }

      if (lstat == 0) break;
   }

   return (stat);
}

EXTERN int asn1PD_H245RedundancyEncoding_rtpRedundancyEncoding (OOCTXT* pctxt, H245RedundancyEncoding_rtpRedundancyEncoding* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.primaryPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.secondaryPresent = optbit;

   /* decode root elements */
   /* decode primary */
   if (pvalue->m.primaryPresent) {
      invokeStartElement (pctxt, "primary", -1);

      stat = asn1PD_H245RedundancyEncodingElement (pctxt, &pvalue->primary);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "primary", -1);

   }

   /* decode secondary */
   if (pvalue->m.secondaryPresent) {
      invokeStartElement (pctxt, "secondary", -1);

      stat = asn1PD_H245_SeqOfH245RedundancyEncodingElement (pctxt, &pvalue->secondary);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "secondary", -1);

   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245RedundancyEncoding (OOCTXT* pctxt, H245RedundancyEncoding* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.secondaryEncodingPresent = optbit;

   /* decode root elements */
   /* decode redundancyEncodingMethod */
   invokeStartElement (pctxt, "redundancyEncodingMethod", -1);

   stat = asn1PD_H245RedundancyEncodingMethod (pctxt, &pvalue->redundancyEncodingMethod);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "redundancyEncodingMethod", -1);

   /* decode secondaryEncoding */
   if (pvalue->m.secondaryEncodingPresent) {
      invokeStartElement (pctxt, "secondaryEncoding", -1);

      pvalue->secondaryEncoding = memAllocTypeZ (pctxt, H245DataType);

      stat = asn1PD_H245DataType (pctxt, (H245DataType*)pvalue->secondaryEncoding);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "secondaryEncoding", -1);

   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return stat;

            if (i < 1) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt,
                  (ASN1OCTET*)openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     if (openType.numocts == 0) break;

                     pvalue->m.rtpRedundancyEncodingPresent = 1;

                     invokeStartElement (pctxt, "rtpRedundancyEncoding", -1);

                     stat = asn1PD_H245RedundancyEncoding_rtpRedundancyEncoding (pctxt, &pvalue->rtpRedundancyEncoding);
                     if (stat != 0) return stat;

                     invokeEndElement (pctxt, "rtpRedundancyEncoding", -1);

                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245MultiplePayloadStreamElement (OOCTXT* pctxt, H245MultiplePayloadStreamElement* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.payloadTypePresent = optbit;

   /* decode root elements */
   /* decode dataType */
   invokeStartElement (pctxt, "dataType", -1);

   pvalue->dataType = memAllocTypeZ (pctxt, H245DataType);

   stat = asn1PD_H245DataType (pctxt, (H245DataType*)pvalue->dataType);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "dataType", -1);

   /* decode payloadType */
   if (pvalue->m.payloadTypePresent) {
      invokeStartElement (pctxt, "payloadType", -1);

      stat = decodeConsUInt8 (pctxt, &pvalue->payloadType, 0, 127);
      if (stat != 0) return stat;

      invokeUIntValue (pctxt, pvalue->payloadType);
      invokeEndElement (pctxt, "payloadType", -1);

   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245_SeqOfH245MultiplePayloadStreamElement (OOCTXT* pctxt, H245_SeqOfH245MultiplePayloadStreamElement* pvalue)
{
   int stat = 0;
   H245MultiplePayloadStreamElement* pdata;
   DListNode* pnode;
   OOUINT32 count = 0;
   OOUINT32 xx1 = 0;
   int lstat;
   OOUINT32 total = 0;

   dListInit (pvalue);

   for (;;) {
      /* decode length determinant */

      lstat = decodeLength (pctxt, &count);
      if (lstat != 0 && lstat != ASN_OK_FRAG) {
         return lstat;
      }
      else if (count == 0) break;
      total += count;

      /* decode elements */

      for (; xx1 < total; xx1++) {
         invokeStartElement (pctxt, "elem", xx1);

         dListAllocNodeAndData (pctxt, H245MultiplePayloadStreamElement, &pnode, &pdata);

         stat = asn1PD_H245MultiplePayloadStreamElement (pctxt, pdata);
         if (stat != 0) return stat;

         invokeEndElement (pctxt, "elem", xx1);

         dListAppendNode2 (pvalue, pnode);
      }

      if (lstat == 0) break;
   }

   return (stat);
}

EXTERN int asn1PD_H245MultiplePayloadStream (OOCTXT* pctxt, H245MultiplePayloadStream* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode elements */
   invokeStartElement (pctxt, "elements", -1);

   stat = asn1PD_H245_SeqOfH245MultiplePayloadStreamElement (pctxt, &pvalue->elements);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "elements", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245DepFECData_rfc2733_mode_separateStream_differentPort (OOCTXT* pctxt, H245DepFECData_rfc2733_mode_separateStream_differentPort* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.protectedPayloadTypePresent = optbit;

   /* decode root elements */
   /* decode protectedSessionID */
   invokeStartElement (pctxt, "protectedSessionID", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->protectedSessionID, 1, 255);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->protectedSessionID);
   invokeEndElement (pctxt, "protectedSessionID", -1);

   /* decode protectedPayloadType */
   if (pvalue->m.protectedPayloadTypePresent) {
      invokeStartElement (pctxt, "protectedPayloadType", -1);

      stat = decodeConsUInt8 (pctxt, &pvalue->protectedPayloadType, 0, 127);
      if (stat != 0) return stat;

      invokeUIntValue (pctxt, pvalue->protectedPayloadType);
      invokeEndElement (pctxt, "protectedPayloadType", -1);

   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245DepFECData_rfc2733_mode_separateStream_samePort (OOCTXT* pctxt, H245DepFECData_rfc2733_mode_separateStream_samePort* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode protectedPayloadType */
   invokeStartElement (pctxt, "protectedPayloadType", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->protectedPayloadType, 0, 127);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->protectedPayloadType);
   invokeEndElement (pctxt, "protectedPayloadType", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245DepFECData_rfc2733_mode_separateStream (OOCTXT* pctxt, H245DepFECData_rfc2733_mode_separateStream* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* differentPort */
         case 0:
            invokeStartElement (pctxt, "differentPort", -1);

            pvalue->u.differentPort = memAllocTypeZ (pctxt,
               H245DepFECData_rfc2733_mode_separateStream_differentPort);

            stat = asn1PD_H245DepFECData_rfc2733_mode_separateStream_differentPort (pctxt, pvalue->u.differentPort);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "differentPort", -1);

            break;

         /* samePort */
         case 1:
            invokeStartElement (pctxt, "samePort", -1);

            pvalue->u.samePort = memAllocTypeZ (pctxt,
               H245DepFECData_rfc2733_mode_separateStream_samePort);

            stat = asn1PD_H245DepFECData_rfc2733_mode_separateStream_samePort (pctxt, pvalue->u.samePort);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "samePort", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245DepFECData_rfc2733_mode (OOCTXT* pctxt, H245DepFECData_rfc2733_mode* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* redundancyEncoding */
         case 0:
            invokeStartElement (pctxt, "redundancyEncoding", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "redundancyEncoding", -1);

            break;

         /* separateStream */
         case 1:
            invokeStartElement (pctxt, "separateStream", -1);

            pvalue->u.separateStream = memAllocTypeZ (pctxt,
               H245DepFECData_rfc2733_mode_separateStream);

            stat = asn1PD_H245DepFECData_rfc2733_mode_separateStream (pctxt, pvalue->u.separateStream);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "separateStream", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245DepFECData_rfc2733 (OOCTXT* pctxt, H245DepFECData_rfc2733* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode mode */
   invokeStartElement (pctxt, "mode", -1);

   stat = asn1PD_H245DepFECData_rfc2733_mode (pctxt, &pvalue->mode);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "mode", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245DepFECData (OOCTXT* pctxt, H245DepFECData* pvalue)
{
   int stat = 0;
   OOUINT32 ui;

   stat = decodeConsUnsigned (pctxt, &ui, 0, 0);
   if (stat != 0) return stat;
   else pvalue->t = ui + 1;

   switch (ui) {
      /* rfc2733 */
      case 0:
         invokeStartElement (pctxt, "rfc2733", -1);

         pvalue->u.rfc2733 = memAllocTypeZ (pctxt, H245DepFECData_rfc2733);

         stat = asn1PD_H245DepFECData_rfc2733 (pctxt, pvalue->u.rfc2733);
         if (stat != 0) return stat;

         invokeEndElement (pctxt, "rfc2733", -1);

         break;

      default:
         return ASN_E_INVOPT;
   }

   return (stat);
}

EXTERN int asn1PD_H245FECData_rfc2733_pktMode_rfc2733sameport (OOCTXT* pctxt, H245FECData_rfc2733_pktMode_rfc2733sameport* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245FECData_rfc2733_pktMode_rfc2733diffport (OOCTXT* pctxt, H245FECData_rfc2733_pktMode_rfc2733diffport* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode protectedChannel */
   invokeStartElement (pctxt, "protectedChannel", -1);

   stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->protectedChannel);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "protectedChannel", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245FECData_rfc2733_pktMode (OOCTXT* pctxt, H245FECData_rfc2733_pktMode* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* rfc2198coding */
         case 0:
            invokeStartElement (pctxt, "rfc2198coding", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "rfc2198coding", -1);

            break;

         /* rfc2733sameport */
         case 1:
            invokeStartElement (pctxt, "rfc2733sameport", -1);

            pvalue->u.rfc2733sameport = memAllocTypeZ (pctxt,
               H245FECData_rfc2733_pktMode_rfc2733sameport);

            stat = asn1PD_H245FECData_rfc2733_pktMode_rfc2733sameport (pctxt, pvalue->u.rfc2733sameport);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "rfc2733sameport", -1);

            break;

         /* rfc2733diffport */
         case 2:
            invokeStartElement (pctxt, "rfc2733diffport", -1);

            pvalue->u.rfc2733diffport = memAllocTypeZ (pctxt,
               H245FECData_rfc2733_pktMode_rfc2733diffport);

            stat = asn1PD_H245FECData_rfc2733_pktMode_rfc2733diffport (pctxt, pvalue->u.rfc2733diffport);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "rfc2733diffport", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 4;

      if (pvalue->t < 4) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245FECData_rfc2733 (OOCTXT* pctxt, H245FECData_rfc2733* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.fecSchemePresent = optbit;

   /* decode root elements */
   /* decode protectedPayloadType */
   invokeStartElement (pctxt, "protectedPayloadType", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->protectedPayloadType, 0, 127);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->protectedPayloadType);
   invokeEndElement (pctxt, "protectedPayloadType", -1);

   /* decode fecScheme */
   if (pvalue->m.fecSchemePresent) {
      invokeStartElement (pctxt, "fecScheme", -1);

      stat = decodeObjectIdentifier (pctxt, &pvalue->fecScheme);
      if (stat != 0) return stat;

      invokeOidValue (pctxt, pvalue->fecScheme.numids, pvalue->fecScheme.subid);
      invokeEndElement (pctxt, "fecScheme", -1);

   }

   /* decode pktMode */
   invokeStartElement (pctxt, "pktMode", -1);

   stat = asn1PD_H245FECData_rfc2733_pktMode (pctxt, &pvalue->pktMode);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "pktMode", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245FECData (OOCTXT* pctxt, H245FECData* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 0);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* rfc2733 */
         case 0:
            invokeStartElement (pctxt, "rfc2733", -1);

            pvalue->u.rfc2733 = memAllocTypeZ (pctxt, H245FECData_rfc2733);

            stat = asn1PD_H245FECData_rfc2733 (pctxt, pvalue->u.rfc2733);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "rfc2733", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 2;

      if (pvalue->t < 2) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245H235Media_mediaType (OOCTXT* pctxt, H245H235Media_mediaType* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 3);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            invokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = memAllocTypeZ (pctxt,
               H245NonStandardParameter);

            stat = asn1PD_H245NonStandardParameter (pctxt, pvalue->u.nonStandard);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* videoData */
         case 1:
            invokeStartElement (pctxt, "videoData", -1);

            pvalue->u.videoData = memAllocTypeZ (pctxt,
               H245VideoCapability);

            stat = asn1PD_H245VideoCapability (pctxt, pvalue->u.videoData);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "videoData", -1);

            break;

         /* audioData */
         case 2:
            invokeStartElement (pctxt, "audioData", -1);

            pvalue->u.audioData = memAllocTypeZ (pctxt,
               H245AudioCapability);

            stat = asn1PD_H245AudioCapability (pctxt, pvalue->u.audioData);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "audioData", -1);

            break;

         /* data */
         case 3:
            invokeStartElement (pctxt, "data", -1);

            pvalue->u.data = memAllocTypeZ (pctxt,
               H245DataApplicationCapability);

            stat = asn1PD_H245DataApplicationCapability (pctxt, pvalue->u.data);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "data", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 5;

      if (pvalue->t < 5) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt,
         (ASN1OCTET*)openType.data, openType.numocts);

      switch (pvalue->t) {
         /* redundancyEncoding */
         case 5:
            invokeStartElement (pctxt, "redundancyEncoding", -1);

            pvalue->u.redundancyEncoding = memAllocTypeZ (pctxt,
               H245RedundancyEncoding);

            stat = asn1PD_H245RedundancyEncoding (pctxt, pvalue->u.redundancyEncoding);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "redundancyEncoding", -1);

            break;

         /* multiplePayloadStream */
         case 6:
            invokeStartElement (pctxt, "multiplePayloadStream", -1);

            pvalue->u.multiplePayloadStream = memAllocTypeZ (pctxt,
               H245MultiplePayloadStream);

            stat = asn1PD_H245MultiplePayloadStream (pctxt, pvalue->u.multiplePayloadStream);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "multiplePayloadStream", -1);

            break;

         /* depFec */
         case 7:
            invokeStartElement (pctxt, "depFec", -1);

            pvalue->u.depFec = memAllocTypeZ (pctxt, H245DepFECData);

            stat = asn1PD_H245DepFECData (pctxt, pvalue->u.depFec);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "depFec", -1);

            break;

         /* fec */
         case 8:
            invokeStartElement (pctxt, "fec", -1);

            pvalue->u.fec = memAllocTypeZ (pctxt, H245FECData);

            stat = asn1PD_H245FECData (pctxt, pvalue->u.fec);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "fec", -1);

            break;

         default:;
      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

EXTERN int asn1PD_H245H235Media (OOCTXT* pctxt, H245H235Media* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode encryptionAuthenticationAndIntegrity */
   invokeStartElement (pctxt, "encryptionAuthenticationAndIntegrity", -1);

   stat = asn1PD_H245EncryptionAuthenticationAndIntegrity (pctxt, &pvalue->encryptionAuthenticationAndIntegrity);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "encryptionAuthenticationAndIntegrity", -1);

   /* decode mediaType */
   invokeStartElement (pctxt, "mediaType", -1);

   stat = asn1PD_H245H235Media_mediaType (pctxt, &pvalue->mediaType);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "mediaType", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245MultiplexedStreamParameter (OOCTXT* pctxt, H245MultiplexedStreamParameter* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode multiplexFormat */
   invokeStartElement (pctxt, "multiplexFormat", -1);

   stat = asn1PD_H245MultiplexFormat (pctxt, &pvalue->multiplexFormat);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "multiplexFormat", -1);

   /* decode controlOnMuxStream */
   invokeStartElement (pctxt, "controlOnMuxStream", -1);

   stat = DECODEBIT (pctxt, &pvalue->controlOnMuxStream);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->controlOnMuxStream);
   invokeEndElement (pctxt, "controlOnMuxStream", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245DataType (OOCTXT* pctxt, H245DataType* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 5);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            invokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = memAllocTypeZ (pctxt,
               H245NonStandardParameter);

            stat = asn1PD_H245NonStandardParameter (pctxt, pvalue->u.nonStandard);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* nullData */
         case 1:
            invokeStartElement (pctxt, "nullData", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "nullData", -1);

            break;

         /* videoData */
         case 2:
            invokeStartElement (pctxt, "videoData", -1);

            pvalue->u.videoData = memAllocTypeZ (pctxt,
               H245VideoCapability);

            stat = asn1PD_H245VideoCapability (pctxt, pvalue->u.videoData);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "videoData", -1);

            break;

         /* audioData */
         case 3:
            invokeStartElement (pctxt, "audioData", -1);

            pvalue->u.audioData = memAllocTypeZ (pctxt,
               H245AudioCapability);

            stat = asn1PD_H245AudioCapability (pctxt, pvalue->u.audioData);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "audioData", -1);

            break;

         /* data */
         case 4:
            invokeStartElement (pctxt, "data", -1);

            pvalue->u.data = memAllocTypeZ (pctxt,
               H245DataApplicationCapability);

            stat = asn1PD_H245DataApplicationCapability (pctxt, pvalue->u.data);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "data", -1);

            break;

         /* encryptionData */
         case 5:
            invokeStartElement (pctxt, "encryptionData", -1);

            pvalue->u.encryptionData = memAllocTypeZ (pctxt,
               H245EncryptionMode);

            stat = asn1PD_H245EncryptionMode (pctxt, pvalue->u.encryptionData);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "encryptionData", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 7;

      if (pvalue->t < 7) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt,
         (ASN1OCTET*)openType.data, openType.numocts);

      switch (pvalue->t) {
         /* h235Control */
         case 7:
            invokeStartElement (pctxt, "h235Control", -1);

            pvalue->u.h235Control = memAllocTypeZ (pctxt,
               H245NonStandardParameter);

            stat = asn1PD_H245NonStandardParameter (pctxt, pvalue->u.h235Control);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "h235Control", -1);

            break;

         /* h235Media */
         case 8:
            invokeStartElement (pctxt, "h235Media", -1);

            pvalue->u.h235Media = memAllocTypeZ (pctxt, H245H235Media);

            stat = asn1PD_H245H235Media (pctxt, pvalue->u.h235Media);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "h235Media", -1);

            break;

         /* multiplexedStream */
         case 9:
            invokeStartElement (pctxt, "multiplexedStream", -1);

            pvalue->u.multiplexedStream = memAllocTypeZ (pctxt,
               H245MultiplexedStreamParameter);

            stat = asn1PD_H245MultiplexedStreamParameter (pctxt, pvalue->u.multiplexedStream);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "multiplexedStream", -1);

            break;

         /* redundancyEncoding */
         case 10:
            invokeStartElement (pctxt, "redundancyEncoding", -1);

            pvalue->u.redundancyEncoding = memAllocTypeZ (pctxt,
               H245RedundancyEncoding);

            stat = asn1PD_H245RedundancyEncoding (pctxt, pvalue->u.redundancyEncoding);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "redundancyEncoding", -1);

            break;

         /* multiplePayloadStream */
         case 11:
            invokeStartElement (pctxt, "multiplePayloadStream", -1);

            pvalue->u.multiplePayloadStream = memAllocTypeZ (pctxt,
               H245MultiplePayloadStream);

            stat = asn1PD_H245MultiplePayloadStream (pctxt, pvalue->u.multiplePayloadStream);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "multiplePayloadStream", -1);

            break;

         /* depFec */
         case 12:
            invokeStartElement (pctxt, "depFec", -1);

            pvalue->u.depFec = memAllocTypeZ (pctxt, H245DepFECData);

            stat = asn1PD_H245DepFECData (pctxt, pvalue->u.depFec);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "depFec", -1);

            break;

         /* fec */
         case 13:
            invokeStartElement (pctxt, "fec", -1);

            pvalue->u.fec = memAllocTypeZ (pctxt, H245FECData);

            stat = asn1PD_H245FECData (pctxt, pvalue->u.fec);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "fec", -1);

            break;

         default:;
      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

EXTERN int asn1PD_H245H222LogicalChannelParameters (OOCTXT* pctxt, H245H222LogicalChannelParameters* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;
   OOUINT32 j = 0;
   OOBOOL optbits[3];

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   for (i = 0; i < 3; i++) {
      stat = DECODEBIT (pctxt, &optbits[i]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i = 0; i < 5; i++) {
      switch (i) {
         case 0:
         /* decode resourceID */
         invokeStartElement (pctxt, "resourceID", -1);

         stat = decodeConsUInt16 (pctxt, &pvalue->resourceID, 0, 65535);

         invokeUIntValue (pctxt, pvalue->resourceID);
         invokeEndElement (pctxt, "resourceID", -1);

         break;

         case 1:
         /* decode subChannelID */
         invokeStartElement (pctxt, "subChannelID", -1);

         stat = decodeConsUInt16 (pctxt, &pvalue->subChannelID, 0, 8191);

         invokeUIntValue (pctxt, pvalue->subChannelID);
         invokeEndElement (pctxt, "subChannelID", -1);

         break;

         case 2:
         /* decode pcr_pid */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "pcr_pid", -1);

            stat = decodeConsUInt16 (pctxt, &pvalue->pcr_pid, 0, 8191);

            invokeUIntValue (pctxt, pvalue->pcr_pid);
            pvalue->m.pcr_pidPresent = 1;
            invokeEndElement (pctxt, "pcr_pid", -1);

         }
         break;

         case 3:
         /* decode programDescriptors */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "programDescriptors", -1);

            stat = decodeDynOctetString (pctxt, (ASN1DynOctStr*)&pvalue->programDescriptors);

            invokeOctStrValue (pctxt, pvalue->programDescriptors.numocts, pvalue->programDescriptors.data);
            pvalue->m.programDescriptorsPresent = 1;
            invokeEndElement (pctxt, "programDescriptors", -1);

         }
         break;

         case 4:
         /* decode streamDescriptors */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "streamDescriptors", -1);

            stat = decodeDynOctetString (pctxt, (ASN1DynOctStr*)&pvalue->streamDescriptors);

            invokeOctStrValue (pctxt, pvalue->streamDescriptors.numocts, pvalue->streamDescriptors.data);
            pvalue->m.streamDescriptorsPresent = 1;
            invokeEndElement (pctxt, "streamDescriptors", -1);

         }
         break;

         default: j++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245H223LogicalChannelParameters_adaptationLayerType_al3 (OOCTXT* pctxt, H245H223LogicalChannelParameters_adaptationLayerType_al3* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode controlFieldOctets */
   invokeStartElement (pctxt, "controlFieldOctets", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->controlFieldOctets, 0, 2);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->controlFieldOctets);
   invokeEndElement (pctxt, "controlFieldOctets", -1);

   /* decode sendBufferSize */
   invokeStartElement (pctxt, "sendBufferSize", -1);

   stat = decodeConsUnsigned (pctxt, &pvalue->sendBufferSize, 0, 16777215);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->sendBufferSize);
   invokeEndElement (pctxt, "sendBufferSize", -1);

   return (stat);
}

EXTERN int asn1PD_H245H223AL1MParameters_transferMode (OOCTXT* pctxt, H245H223AL1MParameters_transferMode* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* framed */
         case 0:
            invokeStartElement (pctxt, "framed", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "framed", -1);

            break;

         /* unframed */
         case 1:
            invokeStartElement (pctxt, "unframed", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "unframed", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245H223AL1MParameters_headerFEC (OOCTXT* pctxt, H245H223AL1MParameters_headerFEC* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* sebch16_7 */
         case 0:
            invokeStartElement (pctxt, "sebch16_7", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "sebch16_7", -1);

            break;

         /* golay24_12 */
         case 1:
            invokeStartElement (pctxt, "golay24_12", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "golay24_12", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245H223AL1MParameters_crcLength (OOCTXT* pctxt, H245H223AL1MParameters_crcLength* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 3);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* crc4bit */
         case 0:
            invokeStartElement (pctxt, "crc4bit", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "crc4bit", -1);

            break;

         /* crc12bit */
         case 1:
            invokeStartElement (pctxt, "crc12bit", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "crc12bit", -1);

            break;

         /* crc20bit */
         case 2:
            invokeStartElement (pctxt, "crc20bit", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "crc20bit", -1);

            break;

         /* crc28bit */
         case 3:
            invokeStartElement (pctxt, "crc28bit", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "crc28bit", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 5;

      if (pvalue->t < 5) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt,
         (ASN1OCTET*)openType.data, openType.numocts);

      switch (pvalue->t) {
         /* crc8bit */
         case 5:
            invokeStartElement (pctxt, "crc8bit", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "crc8bit", -1);

            break;

         /* crc16bit */
         case 6:
            invokeStartElement (pctxt, "crc16bit", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "crc16bit", -1);

            break;

         /* crc32bit */
         case 7:
            invokeStartElement (pctxt, "crc32bit", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "crc32bit", -1);

            break;

         /* crcNotUsed */
         case 8:
            invokeStartElement (pctxt, "crcNotUsed", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "crcNotUsed", -1);

            break;

         default:;
      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

EXTERN int asn1PD_H245H223AnnexCArqParameters_numberOfRetransmissions (OOCTXT* pctxt, H245H223AnnexCArqParameters_numberOfRetransmissions* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* finite */
         case 0:
            invokeStartElement (pctxt, "finite", -1);

            stat = decodeConsUInt8 (pctxt, &pvalue->u.finite, 0, 16);
            if (stat != 0) return stat;

            invokeUIntValue (pctxt, pvalue->u.finite);
            invokeEndElement (pctxt, "finite", -1);

            break;

         /* infinite */
         case 1:
            invokeStartElement (pctxt, "infinite", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "infinite", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245H223AnnexCArqParameters (OOCTXT* pctxt, H245H223AnnexCArqParameters* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode numberOfRetransmissions */
   invokeStartElement (pctxt, "numberOfRetransmissions", -1);

   stat = asn1PD_H245H223AnnexCArqParameters_numberOfRetransmissions (pctxt, &pvalue->numberOfRetransmissions);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "numberOfRetransmissions", -1);

   /* decode sendBufferSize */
   invokeStartElement (pctxt, "sendBufferSize", -1);

   stat = decodeConsUnsigned (pctxt, &pvalue->sendBufferSize, 0, 16777215);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->sendBufferSize);
   invokeEndElement (pctxt, "sendBufferSize", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245H223AL1MParameters_arqType (OOCTXT* pctxt, H245H223AL1MParameters_arqType* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* noArq */
         case 0:
            invokeStartElement (pctxt, "noArq", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "noArq", -1);

            break;

         /* typeIArq */
         case 1:
            invokeStartElement (pctxt, "typeIArq", -1);

            pvalue->u.typeIArq = memAllocTypeZ (pctxt,
               H245H223AnnexCArqParameters);

            stat = asn1PD_H245H223AnnexCArqParameters (pctxt, pvalue->u.typeIArq);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "typeIArq", -1);

            break;

         /* typeIIArq */
         case 2:
            invokeStartElement (pctxt, "typeIIArq", -1);

            pvalue->u.typeIIArq = memAllocTypeZ (pctxt,
               H245H223AnnexCArqParameters);

            stat = asn1PD_H245H223AnnexCArqParameters (pctxt, pvalue->u.typeIIArq);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "typeIIArq", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 4;

      if (pvalue->t < 4) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245H223AL1MParameters (OOCTXT* pctxt, H245H223AL1MParameters* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   /* decode root elements */
   /* decode transferMode */
   invokeStartElement (pctxt, "transferMode", -1);

   stat = asn1PD_H245H223AL1MParameters_transferMode (pctxt, &pvalue->transferMode);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "transferMode", -1);

   /* decode headerFEC */
   invokeStartElement (pctxt, "headerFEC", -1);

   stat = asn1PD_H245H223AL1MParameters_headerFEC (pctxt, &pvalue->headerFEC);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "headerFEC", -1);

   /* decode crcLength */
   invokeStartElement (pctxt, "crcLength", -1);

   stat = asn1PD_H245H223AL1MParameters_crcLength (pctxt, &pvalue->crcLength);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "crcLength", -1);

   /* decode rcpcCodeRate */
   invokeStartElement (pctxt, "rcpcCodeRate", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->rcpcCodeRate, 8, 32);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->rcpcCodeRate);
   invokeEndElement (pctxt, "rcpcCodeRate", -1);

   /* decode arqType */
   invokeStartElement (pctxt, "arqType", -1);

   stat = asn1PD_H245H223AL1MParameters_arqType (pctxt, &pvalue->arqType);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "arqType", -1);

   /* decode alpduInterleaving */
   invokeStartElement (pctxt, "alpduInterleaving", -1);

   stat = DECODEBIT (pctxt, &pvalue->alpduInterleaving);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->alpduInterleaving);
   invokeEndElement (pctxt, "alpduInterleaving", -1);

   /* decode alsduSplitting */
   invokeStartElement (pctxt, "alsduSplitting", -1);

   stat = DECODEBIT (pctxt, &pvalue->alsduSplitting);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->alsduSplitting);
   invokeEndElement (pctxt, "alsduSplitting", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return stat;

            if (i < 1) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt,
                  (ASN1OCTET*)openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     if (openType.numocts == 0) break;

                     pvalue->m.rsCodeCorrectionPresent = 1;

                     invokeStartElement (pctxt, "rsCodeCorrection", -1);

                     stat = decodeConsUInt8 (pctxt, &pvalue->rsCodeCorrection, 0, 127);
                     if (stat != 0) return stat;

                     invokeUIntValue (pctxt, pvalue->rsCodeCorrection);
                     invokeEndElement (pctxt, "rsCodeCorrection", -1);

                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245H223AL2MParameters_headerFEC (OOCTXT* pctxt, H245H223AL2MParameters_headerFEC* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* sebch16_5 */
         case 0:
            invokeStartElement (pctxt, "sebch16_5", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "sebch16_5", -1);

            break;

         /* golay24_12 */
         case 1:
            invokeStartElement (pctxt, "golay24_12", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "golay24_12", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245H223AL2MParameters (OOCTXT* pctxt, H245H223AL2MParameters* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode headerFEC */
   invokeStartElement (pctxt, "headerFEC", -1);

   stat = asn1PD_H245H223AL2MParameters_headerFEC (pctxt, &pvalue->headerFEC);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "headerFEC", -1);

   /* decode alpduInterleaving */
   invokeStartElement (pctxt, "alpduInterleaving", -1);

   stat = DECODEBIT (pctxt, &pvalue->alpduInterleaving);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->alpduInterleaving);
   invokeEndElement (pctxt, "alpduInterleaving", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245H223AL3MParameters_headerFormat (OOCTXT* pctxt, H245H223AL3MParameters_headerFormat* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* sebch16_7 */
         case 0:
            invokeStartElement (pctxt, "sebch16_7", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "sebch16_7", -1);

            break;

         /* golay24_12 */
         case 1:
            invokeStartElement (pctxt, "golay24_12", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "golay24_12", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245H223AL3MParameters_crcLength (OOCTXT* pctxt, H245H223AL3MParameters_crcLength* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 3);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* crc4bit */
         case 0:
            invokeStartElement (pctxt, "crc4bit", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "crc4bit", -1);

            break;

         /* crc12bit */
         case 1:
            invokeStartElement (pctxt, "crc12bit", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "crc12bit", -1);

            break;

         /* crc20bit */
         case 2:
            invokeStartElement (pctxt, "crc20bit", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "crc20bit", -1);

            break;

         /* crc28bit */
         case 3:
            invokeStartElement (pctxt, "crc28bit", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "crc28bit", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 5;

      if (pvalue->t < 5) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt,
         (ASN1OCTET*)openType.data, openType.numocts);

      switch (pvalue->t) {
         /* crc8bit */
         case 5:
            invokeStartElement (pctxt, "crc8bit", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "crc8bit", -1);

            break;

         /* crc16bit */
         case 6:
            invokeStartElement (pctxt, "crc16bit", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "crc16bit", -1);

            break;

         /* crc32bit */
         case 7:
            invokeStartElement (pctxt, "crc32bit", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "crc32bit", -1);

            break;

         /* crcNotUsed */
         case 8:
            invokeStartElement (pctxt, "crcNotUsed", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "crcNotUsed", -1);

            break;

         default:;
      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

EXTERN int asn1PD_H245H223AL3MParameters_arqType (OOCTXT* pctxt, H245H223AL3MParameters_arqType* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* noArq */
         case 0:
            invokeStartElement (pctxt, "noArq", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "noArq", -1);

            break;

         /* typeIArq */
         case 1:
            invokeStartElement (pctxt, "typeIArq", -1);

            pvalue->u.typeIArq = memAllocTypeZ (pctxt,
               H245H223AnnexCArqParameters);

            stat = asn1PD_H245H223AnnexCArqParameters (pctxt, pvalue->u.typeIArq);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "typeIArq", -1);

            break;

         /* typeIIArq */
         case 2:
            invokeStartElement (pctxt, "typeIIArq", -1);

            pvalue->u.typeIIArq = memAllocTypeZ (pctxt,
               H245H223AnnexCArqParameters);

            stat = asn1PD_H245H223AnnexCArqParameters (pctxt, pvalue->u.typeIIArq);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "typeIIArq", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 4;

      if (pvalue->t < 4) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245H223AL3MParameters (OOCTXT* pctxt, H245H223AL3MParameters* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   /* decode root elements */
   /* decode headerFormat */
   invokeStartElement (pctxt, "headerFormat", -1);

   stat = asn1PD_H245H223AL3MParameters_headerFormat (pctxt, &pvalue->headerFormat);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "headerFormat", -1);

   /* decode crcLength */
   invokeStartElement (pctxt, "crcLength", -1);

   stat = asn1PD_H245H223AL3MParameters_crcLength (pctxt, &pvalue->crcLength);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "crcLength", -1);

   /* decode rcpcCodeRate */
   invokeStartElement (pctxt, "rcpcCodeRate", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->rcpcCodeRate, 8, 32);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->rcpcCodeRate);
   invokeEndElement (pctxt, "rcpcCodeRate", -1);

   /* decode arqType */
   invokeStartElement (pctxt, "arqType", -1);

   stat = asn1PD_H245H223AL3MParameters_arqType (pctxt, &pvalue->arqType);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "arqType", -1);

   /* decode alpduInterleaving */
   invokeStartElement (pctxt, "alpduInterleaving", -1);

   stat = DECODEBIT (pctxt, &pvalue->alpduInterleaving);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->alpduInterleaving);
   invokeEndElement (pctxt, "alpduInterleaving", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return stat;

            if (i < 1) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt,
                  (ASN1OCTET*)openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     if (openType.numocts == 0) break;

                     pvalue->m.rsCodeCorrectionPresent = 1;

                     invokeStartElement (pctxt, "rsCodeCorrection", -1);

                     stat = decodeConsUInt8 (pctxt, &pvalue->rsCodeCorrection, 0, 127);
                     if (stat != 0) return stat;

                     invokeUIntValue (pctxt, pvalue->rsCodeCorrection);
                     invokeEndElement (pctxt, "rsCodeCorrection", -1);

                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245H223LogicalChannelParameters_adaptationLayerType (OOCTXT* pctxt, H245H223LogicalChannelParameters_adaptationLayerType* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 5);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            invokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = memAllocTypeZ (pctxt,
               H245NonStandardParameter);

            stat = asn1PD_H245NonStandardParameter (pctxt, pvalue->u.nonStandard);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* al1Framed */
         case 1:
            invokeStartElement (pctxt, "al1Framed", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "al1Framed", -1);

            break;

         /* al1NotFramed */
         case 2:
            invokeStartElement (pctxt, "al1NotFramed", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "al1NotFramed", -1);

            break;

         /* al2WithoutSequenceNumbers */
         case 3:
            invokeStartElement (pctxt, "al2WithoutSequenceNumbers", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "al2WithoutSequenceNumbers", -1);

            break;

         /* al2WithSequenceNumbers */
         case 4:
            invokeStartElement (pctxt, "al2WithSequenceNumbers", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "al2WithSequenceNumbers", -1);

            break;

         /* al3 */
         case 5:
            invokeStartElement (pctxt, "al3", -1);

            pvalue->u.al3 = memAllocTypeZ (pctxt,
               H245H223LogicalChannelParameters_adaptationLayerType_al3);

            stat = asn1PD_H245H223LogicalChannelParameters_adaptationLayerType_al3 (pctxt, pvalue->u.al3);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "al3", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 7;

      if (pvalue->t < 7) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt,
         (ASN1OCTET*)openType.data, openType.numocts);

      switch (pvalue->t) {
         /* al1M */
         case 7:
            invokeStartElement (pctxt, "al1M", -1);

            pvalue->u.al1M = memAllocTypeZ (pctxt, H245H223AL1MParameters);

            stat = asn1PD_H245H223AL1MParameters (pctxt, pvalue->u.al1M);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "al1M", -1);

            break;

         /* al2M */
         case 8:
            invokeStartElement (pctxt, "al2M", -1);

            pvalue->u.al2M = memAllocTypeZ (pctxt, H245H223AL2MParameters);

            stat = asn1PD_H245H223AL2MParameters (pctxt, pvalue->u.al2M);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "al2M", -1);

            break;

         /* al3M */
         case 9:
            invokeStartElement (pctxt, "al3M", -1);

            pvalue->u.al3M = memAllocTypeZ (pctxt, H245H223AL3MParameters);

            stat = asn1PD_H245H223AL3MParameters (pctxt, pvalue->u.al3M);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "al3M", -1);

            break;

         default:;
      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

EXTERN int asn1PD_H245H223LogicalChannelParameters (OOCTXT* pctxt, H245H223LogicalChannelParameters* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode adaptationLayerType */
   invokeStartElement (pctxt, "adaptationLayerType", -1);

   stat = asn1PD_H245H223LogicalChannelParameters_adaptationLayerType (pctxt, &pvalue->adaptationLayerType);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "adaptationLayerType", -1);

   /* decode segmentableFlag */
   invokeStartElement (pctxt, "segmentableFlag", -1);

   stat = DECODEBIT (pctxt, &pvalue->segmentableFlag);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->segmentableFlag);
   invokeEndElement (pctxt, "segmentableFlag", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245CRCLength (OOCTXT* pctxt, H245CRCLength* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* crc8bit */
         case 0:
            invokeStartElement (pctxt, "crc8bit", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "crc8bit", -1);

            break;

         /* crc16bit */
         case 1:
            invokeStartElement (pctxt, "crc16bit", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "crc16bit", -1);

            break;

         /* crc32bit */
         case 2:
            invokeStartElement (pctxt, "crc32bit", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "crc32bit", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 4;

      if (pvalue->t < 4) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245V76HDLCParameters (OOCTXT* pctxt, H245V76HDLCParameters* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode crcLength */
   invokeStartElement (pctxt, "crcLength", -1);

   stat = asn1PD_H245CRCLength (pctxt, &pvalue->crcLength);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "crcLength", -1);

   /* decode n401 */
   invokeStartElement (pctxt, "n401", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->n401, 1, 4095);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->n401);
   invokeEndElement (pctxt, "n401", -1);

   /* decode loopbackTestProcedure */
   invokeStartElement (pctxt, "loopbackTestProcedure", -1);

   stat = DECODEBIT (pctxt, &pvalue->loopbackTestProcedure);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->loopbackTestProcedure);
   invokeEndElement (pctxt, "loopbackTestProcedure", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245V76LogicalChannelParameters_suspendResume (OOCTXT* pctxt, H245V76LogicalChannelParameters_suspendResume* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* noSuspendResume */
         case 0:
            invokeStartElement (pctxt, "noSuspendResume", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "noSuspendResume", -1);

            break;

         /* suspendResumewAddress */
         case 1:
            invokeStartElement (pctxt, "suspendResumewAddress", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "suspendResumewAddress", -1);

            break;

         /* suspendResumewoAddress */
         case 2:
            invokeStartElement (pctxt, "suspendResumewoAddress", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "suspendResumewoAddress", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 4;

      if (pvalue->t < 4) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245V76LogicalChannelParameters_mode_eRM_recovery (OOCTXT* pctxt, H245V76LogicalChannelParameters_mode_eRM_recovery* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* rej */
         case 0:
            invokeStartElement (pctxt, "rej", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "rej", -1);

            break;

         /* sREJ */
         case 1:
            invokeStartElement (pctxt, "sREJ", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "sREJ", -1);

            break;

         /* mSREJ */
         case 2:
            invokeStartElement (pctxt, "mSREJ", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "mSREJ", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 4;

      if (pvalue->t < 4) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245V76LogicalChannelParameters_mode_eRM (OOCTXT* pctxt, H245V76LogicalChannelParameters_mode_eRM* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode windowSize */
   invokeStartElement (pctxt, "windowSize", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->windowSize, 1, 127);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->windowSize);
   invokeEndElement (pctxt, "windowSize", -1);

   /* decode recovery */
   invokeStartElement (pctxt, "recovery", -1);

   stat = asn1PD_H245V76LogicalChannelParameters_mode_eRM_recovery (pctxt, &pvalue->recovery);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "recovery", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245V76LogicalChannelParameters_mode (OOCTXT* pctxt, H245V76LogicalChannelParameters_mode* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* eRM */
         case 0:
            invokeStartElement (pctxt, "eRM", -1);

            pvalue->u.eRM = memAllocTypeZ (pctxt,
               H245V76LogicalChannelParameters_mode_eRM);

            stat = asn1PD_H245V76LogicalChannelParameters_mode_eRM (pctxt, pvalue->u.eRM);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "eRM", -1);

            break;

         /* uNERM */
         case 1:
            invokeStartElement (pctxt, "uNERM", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "uNERM", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245V75Parameters (OOCTXT* pctxt, H245V75Parameters* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode audioHeaderPresent */
   invokeStartElement (pctxt, "audioHeaderPresent", -1);

   stat = DECODEBIT (pctxt, &pvalue->audioHeaderPresent);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->audioHeaderPresent);
   invokeEndElement (pctxt, "audioHeaderPresent", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245V76LogicalChannelParameters (OOCTXT* pctxt, H245V76LogicalChannelParameters* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode hdlcParameters */
   invokeStartElement (pctxt, "hdlcParameters", -1);

   stat = asn1PD_H245V76HDLCParameters (pctxt, &pvalue->hdlcParameters);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "hdlcParameters", -1);

   /* decode suspendResume */
   invokeStartElement (pctxt, "suspendResume", -1);

   stat = asn1PD_H245V76LogicalChannelParameters_suspendResume (pctxt, &pvalue->suspendResume);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "suspendResume", -1);

   /* decode uIH */
   invokeStartElement (pctxt, "uIH", -1);

   stat = DECODEBIT (pctxt, &pvalue->uIH);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->uIH);
   invokeEndElement (pctxt, "uIH", -1);

   /* decode mode */
   invokeStartElement (pctxt, "mode", -1);

   stat = asn1PD_H245V76LogicalChannelParameters_mode (pctxt, &pvalue->mode);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "mode", -1);

   /* decode v75Parameters */
   invokeStartElement (pctxt, "v75Parameters", -1);

   stat = asn1PD_H245V75Parameters (pctxt, &pvalue->v75Parameters);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "v75Parameters", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245UnicastAddress_iPAddress (OOCTXT* pctxt, H245UnicastAddress_iPAddress* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode network */
   invokeStartElement (pctxt, "network", -1);

   stat = asn1PD_H245UnicastAddress_iPAddress_network (pctxt, &pvalue->network);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "network", -1);

   /* decode tsapIdentifier */
   invokeStartElement (pctxt, "tsapIdentifier", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->tsapIdentifier, 0, 65535);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->tsapIdentifier);
   invokeEndElement (pctxt, "tsapIdentifier", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245UnicastAddress_iPXAddress (OOCTXT* pctxt, H245UnicastAddress_iPXAddress* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode node */
   invokeStartElement (pctxt, "node", -1);

   stat = asn1PD_H245UnicastAddress_iPXAddress_node (pctxt, &pvalue->node);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "node", -1);

   /* decode netnum */
   invokeStartElement (pctxt, "netnum", -1);

   stat = asn1PD_H245UnicastAddress_iPXAddress_netnum (pctxt, &pvalue->netnum);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "netnum", -1);

   /* decode tsapIdentifier */
   invokeStartElement (pctxt, "tsapIdentifier", -1);

   stat = asn1PD_H245UnicastAddress_iPXAddress_tsapIdentifier (pctxt, &pvalue->tsapIdentifier);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "tsapIdentifier", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245UnicastAddress_iP6Address (OOCTXT* pctxt, H245UnicastAddress_iP6Address* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode network */
   invokeStartElement (pctxt, "network", -1);

   stat = asn1PD_H245UnicastAddress_iP6Address_network (pctxt, &pvalue->network);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "network", -1);

   /* decode tsapIdentifier */
   invokeStartElement (pctxt, "tsapIdentifier", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->tsapIdentifier, 0, 65535);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->tsapIdentifier);
   invokeEndElement (pctxt, "tsapIdentifier", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245UnicastAddress_iPSourceRouteAddress_routing (OOCTXT* pctxt, H245UnicastAddress_iPSourceRouteAddress_routing* pvalue)
{
   int stat = 0;
   OOUINT32 ui;

   stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
   if (stat != 0) return stat;
   else pvalue->t = ui + 1;

   switch (ui) {
      /* strict */
      case 0:
         invokeStartElement (pctxt, "strict", -1);

         /* NULL */

         invokeNullValue (pctxt);
         invokeEndElement (pctxt, "strict", -1);

         break;

      /* loose */
      case 1:
         invokeStartElement (pctxt, "loose", -1);

         /* NULL */

         invokeNullValue (pctxt);
         invokeEndElement (pctxt, "loose", -1);

         break;

      default:
         return ASN_E_INVOPT;
   }

   return (stat);
}

EXTERN int asn1PD_H245_SeqOfH245UnicastAddress_iPSourceRouteAddress_route_element (OOCTXT* pctxt, H245_SeqOfH245UnicastAddress_iPSourceRouteAddress_route_element* pvalue)
{
   int stat = 0;
   H245UnicastAddress_iPSourceRouteAddress_route_element* pdata;
   DListNode* pnode;
   OOUINT32 count = 0;
   OOUINT32 xx1 = 0;
   int lstat;
   OOUINT32 total = 0;

   dListInit (pvalue);

   for (;;) {
      /* decode length determinant */

      lstat = decodeLength (pctxt, &count);
      if (lstat != 0 && lstat != ASN_OK_FRAG) {
         return lstat;
      }
      else if (count == 0) break;
      total += count;

      /* decode elements */

      for (; xx1 < total; xx1++) {
         invokeStartElement (pctxt, "elem", xx1);

         dListAllocNodeAndData (pctxt, H245UnicastAddress_iPSourceRouteAddress_route_element, &pnode, &pdata);

         stat = asn1PD_H245UnicastAddress_iPSourceRouteAddress_route_element (pctxt, pdata);
         if (stat != 0) return stat;

         invokeEndElement (pctxt, "elem", xx1);

         dListAppendNode2 (pvalue, pnode);
      }

      if (lstat == 0) break;
   }

   return (stat);
}

EXTERN int asn1PD_H245UnicastAddress_iPSourceRouteAddress (OOCTXT* pctxt, H245UnicastAddress_iPSourceRouteAddress* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode routing */
   invokeStartElement (pctxt, "routing", -1);

   stat = asn1PD_H245UnicastAddress_iPSourceRouteAddress_routing (pctxt, &pvalue->routing);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "routing", -1);

   /* decode network */
   invokeStartElement (pctxt, "network", -1);

   stat = asn1PD_H245UnicastAddress_iPSourceRouteAddress_network (pctxt, &pvalue->network);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "network", -1);

   /* decode tsapIdentifier */
   invokeStartElement (pctxt, "tsapIdentifier", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->tsapIdentifier, 0, 65535);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->tsapIdentifier);
   invokeEndElement (pctxt, "tsapIdentifier", -1);

   /* decode route */
   invokeStartElement (pctxt, "route", -1);

   stat = asn1PD_H245_SeqOfH245UnicastAddress_iPSourceRouteAddress_route_element (pctxt, &pvalue->route);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "route", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245UnicastAddress (OOCTXT* pctxt, H245UnicastAddress* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 4);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* iPAddress */
         case 0:
            invokeStartElement (pctxt, "iPAddress", -1);

            pvalue->u.iPAddress = memAllocTypeZ (pctxt,
               H245UnicastAddress_iPAddress);

            stat = asn1PD_H245UnicastAddress_iPAddress (pctxt, pvalue->u.iPAddress);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "iPAddress", -1);

            break;

         /* iPXAddress */
         case 1:
            invokeStartElement (pctxt, "iPXAddress", -1);

            pvalue->u.iPXAddress = memAllocTypeZ (pctxt,
               H245UnicastAddress_iPXAddress);

            stat = asn1PD_H245UnicastAddress_iPXAddress (pctxt, pvalue->u.iPXAddress);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "iPXAddress", -1);

            break;

         /* iP6Address */
         case 2:
            invokeStartElement (pctxt, "iP6Address", -1);

            pvalue->u.iP6Address = memAllocTypeZ (pctxt,
               H245UnicastAddress_iP6Address);

            stat = asn1PD_H245UnicastAddress_iP6Address (pctxt, pvalue->u.iP6Address);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "iP6Address", -1);

            break;

         /* netBios */
         case 3:
            invokeStartElement (pctxt, "netBios", -1);

            pvalue->u.netBios = memAllocTypeZ (pctxt,
               H245UnicastAddress_netBios);

            stat = asn1PD_H245UnicastAddress_netBios (pctxt, pvalue->u.netBios);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "netBios", -1);

            break;

         /* iPSourceRouteAddress */
         case 4:
            invokeStartElement (pctxt, "iPSourceRouteAddress", -1);

            pvalue->u.iPSourceRouteAddress = memAllocTypeZ (pctxt,
               H245UnicastAddress_iPSourceRouteAddress);

            stat = asn1PD_H245UnicastAddress_iPSourceRouteAddress (pctxt, pvalue->u.iPSourceRouteAddress);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "iPSourceRouteAddress", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 6;

      if (pvalue->t < 6) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt,
         (ASN1OCTET*)openType.data, openType.numocts);

      switch (pvalue->t) {
         /* nsap */
         case 6:
            invokeStartElement (pctxt, "nsap", -1);

            pvalue->u.nsap = memAllocTypeZ (pctxt,
               H245UnicastAddress_nsap);

            stat = asn1PD_H245UnicastAddress_nsap (pctxt, pvalue->u.nsap);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "nsap", -1);

            break;

         /* nonStandardAddress */
         case 7:
            invokeStartElement (pctxt, "nonStandardAddress", -1);

            pvalue->u.nonStandardAddress = memAllocTypeZ (pctxt,
               H245NonStandardParameter);

            stat = asn1PD_H245NonStandardParameter (pctxt, pvalue->u.nonStandardAddress);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "nonStandardAddress", -1);

            break;

         default:;
      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

EXTERN int asn1PD_H245MulticastAddress_iPAddress (OOCTXT* pctxt, H245MulticastAddress_iPAddress* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode network */
   invokeStartElement (pctxt, "network", -1);

   stat = asn1PD_H245MulticastAddress_iPAddress_network (pctxt, &pvalue->network);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "network", -1);

   /* decode tsapIdentifier */
   invokeStartElement (pctxt, "tsapIdentifier", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->tsapIdentifier, 0, 65535);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->tsapIdentifier);
   invokeEndElement (pctxt, "tsapIdentifier", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245MulticastAddress_iP6Address (OOCTXT* pctxt, H245MulticastAddress_iP6Address* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode network */
   invokeStartElement (pctxt, "network", -1);

   stat = asn1PD_H245MulticastAddress_iP6Address_network (pctxt, &pvalue->network);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "network", -1);

   /* decode tsapIdentifier */
   invokeStartElement (pctxt, "tsapIdentifier", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->tsapIdentifier, 0, 65535);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->tsapIdentifier);
   invokeEndElement (pctxt, "tsapIdentifier", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245MulticastAddress (OOCTXT* pctxt, H245MulticastAddress* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* iPAddress */
         case 0:
            invokeStartElement (pctxt, "iPAddress", -1);

            pvalue->u.iPAddress = memAllocTypeZ (pctxt,
               H245MulticastAddress_iPAddress);

            stat = asn1PD_H245MulticastAddress_iPAddress (pctxt, pvalue->u.iPAddress);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "iPAddress", -1);

            break;

         /* iP6Address */
         case 1:
            invokeStartElement (pctxt, "iP6Address", -1);

            pvalue->u.iP6Address = memAllocTypeZ (pctxt,
               H245MulticastAddress_iP6Address);

            stat = asn1PD_H245MulticastAddress_iP6Address (pctxt, pvalue->u.iP6Address);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "iP6Address", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt,
         (ASN1OCTET*)openType.data, openType.numocts);

      switch (pvalue->t) {
         /* nsap */
         case 3:
            invokeStartElement (pctxt, "nsap", -1);

            pvalue->u.nsap = memAllocTypeZ (pctxt,
               H245MulticastAddress_nsap);

            stat = asn1PD_H245MulticastAddress_nsap (pctxt, pvalue->u.nsap);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "nsap", -1);

            break;

         /* nonStandardAddress */
         case 4:
            invokeStartElement (pctxt, "nonStandardAddress", -1);

            pvalue->u.nonStandardAddress = memAllocTypeZ (pctxt,
               H245NonStandardParameter);

            stat = asn1PD_H245NonStandardParameter (pctxt, pvalue->u.nonStandardAddress);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "nonStandardAddress", -1);

            break;

         default:;
      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

EXTERN int asn1PD_H245TransportAddress (OOCTXT* pctxt, H245TransportAddress* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* unicastAddress */
         case 0:
            invokeStartElement (pctxt, "unicastAddress", -1);

            pvalue->u.unicastAddress = memAllocTypeZ (pctxt,
               H245UnicastAddress);

            stat = asn1PD_H245UnicastAddress (pctxt, pvalue->u.unicastAddress);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "unicastAddress", -1);

            break;

         /* multicastAddress */
         case 1:
            invokeStartElement (pctxt, "multicastAddress", -1);

            pvalue->u.multicastAddress = memAllocTypeZ (pctxt,
               H245MulticastAddress);

            stat = asn1PD_H245MulticastAddress (pctxt, pvalue->u.multicastAddress);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "multicastAddress", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245TerminalLabel (OOCTXT* pctxt, H245TerminalLabel* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode mcuNumber */
   invokeStartElement (pctxt, "mcuNumber", -1);

   stat = asn1PD_H245McuNumber (pctxt, &pvalue->mcuNumber);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "mcuNumber", -1);

   /* decode terminalNumber */
   invokeStartElement (pctxt, "terminalNumber", -1);

   stat = asn1PD_H245TerminalNumber (pctxt, &pvalue->terminalNumber);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "terminalNumber", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245H2250LogicalChannelParameters_mediaPacketization (OOCTXT* pctxt, H245H2250LogicalChannelParameters_mediaPacketization* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 0);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* h261aVideoPacketization */
         case 0:
            invokeStartElement (pctxt, "h261aVideoPacketization", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "h261aVideoPacketization", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 2;

      if (pvalue->t < 2) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt,
         (ASN1OCTET*)openType.data, openType.numocts);

      switch (pvalue->t) {
         /* rtpPayloadType */
         case 2:
            invokeStartElement (pctxt, "rtpPayloadType", -1);

            pvalue->u.rtpPayloadType = memAllocTypeZ (pctxt,
               H245RTPPayloadType);

            stat = asn1PD_H245RTPPayloadType (pctxt, pvalue->u.rtpPayloadType);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "rtpPayloadType", -1);

            break;

         default:;
      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

EXTERN int asn1PD_H245H2250LogicalChannelParameters (OOCTXT* pctxt, H245H2250LogicalChannelParameters* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;
   OOUINT32 j = 0;
   OOBOOL optbits[10];

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   for (i = 0; i < 10; i++) {
      stat = DECODEBIT (pctxt, &optbits[i]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i = 0; i < 11; i++) {
      switch (i) {
         case 0:
         /* decode nonStandard */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "nonStandard", -1);

            stat = asn1PD_H245_SeqOfH245NonStandardParameter (pctxt, &pvalue->nonStandard);

            pvalue->m.nonStandardPresent = 1;
            invokeEndElement (pctxt, "nonStandard", -1);

         }
         break;

         case 1:
         /* decode sessionID */
         invokeStartElement (pctxt, "sessionID", -1);

         stat = decodeConsUInt8 (pctxt, &pvalue->sessionID, 0, 255);

         invokeUIntValue (pctxt, pvalue->sessionID);
         invokeEndElement (pctxt, "sessionID", -1);

         break;

         case 2:
         /* decode associatedSessionID */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "associatedSessionID", -1);

            stat = decodeConsUInt8 (pctxt, &pvalue->associatedSessionID, 1, 255);

            invokeUIntValue (pctxt, pvalue->associatedSessionID);
            pvalue->m.associatedSessionIDPresent = 1;
            invokeEndElement (pctxt, "associatedSessionID", -1);

         }
         break;

         case 3:
         /* decode mediaChannel */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "mediaChannel", -1);

            stat = asn1PD_H245TransportAddress (pctxt, &pvalue->mediaChannel);

            pvalue->m.mediaChannelPresent = 1;
            invokeEndElement (pctxt, "mediaChannel", -1);

         }
         break;

         case 4:
         /* decode mediaGuaranteedDelivery */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "mediaGuaranteedDelivery", -1);

            stat = DECODEBIT (pctxt, &pvalue->mediaGuaranteedDelivery);

            invokeBoolValue (pctxt, pvalue->mediaGuaranteedDelivery);
            pvalue->m.mediaGuaranteedDeliveryPresent = 1;
            invokeEndElement (pctxt, "mediaGuaranteedDelivery", -1);

         }
         break;

         case 5:
         /* decode mediaControlChannel */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "mediaControlChannel", -1);

            stat = asn1PD_H245TransportAddress (pctxt, &pvalue->mediaControlChannel);

            pvalue->m.mediaControlChannelPresent = 1;
            invokeEndElement (pctxt, "mediaControlChannel", -1);

         }
         break;

         case 6:
         /* decode mediaControlGuaranteedDelivery */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "mediaControlGuaranteedDelivery", -1);

            stat = DECODEBIT (pctxt, &pvalue->mediaControlGuaranteedDelivery);

            invokeBoolValue (pctxt, pvalue->mediaControlGuaranteedDelivery);
            pvalue->m.mediaControlGuaranteedDeliveryPresent = 1;
            invokeEndElement (pctxt, "mediaControlGuaranteedDelivery", -1);

         }
         break;

         case 7:
         /* decode silenceSuppression */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "silenceSuppression", -1);

            stat = DECODEBIT (pctxt, &pvalue->silenceSuppression);

            invokeBoolValue (pctxt, pvalue->silenceSuppression);
            pvalue->m.silenceSuppressionPresent = 1;
            invokeEndElement (pctxt, "silenceSuppression", -1);

         }
         break;

         case 8:
         /* decode destination */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "destination", -1);

            stat = asn1PD_H245TerminalLabel (pctxt, &pvalue->destination);

            pvalue->m.destinationPresent = 1;
            invokeEndElement (pctxt, "destination", -1);

         }
         break;

         case 9:
         /* decode dynamicRTPPayloadType */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "dynamicRTPPayloadType", -1);

            stat = decodeConsUInt8 (pctxt, &pvalue->dynamicRTPPayloadType, 96, 127);

            invokeUIntValue (pctxt, pvalue->dynamicRTPPayloadType);
            pvalue->m.dynamicRTPPayloadTypePresent = 1;
            invokeEndElement (pctxt, "dynamicRTPPayloadType", -1);

         }
         break;

         case 10:
         /* decode mediaPacketization */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "mediaPacketization", -1);

            stat = asn1PD_H245H2250LogicalChannelParameters_mediaPacketization (pctxt, &pvalue->mediaPacketization);

            pvalue->m.mediaPacketizationPresent = 1;
            invokeEndElement (pctxt, "mediaPacketization", -1);

         }
         break;

         default: j++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return stat;

            if (i < 3) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt,
                  (ASN1OCTET*)openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     if (openType.numocts == 0) break;

                     pvalue->m.transportCapabilityPresent = 1;

                     invokeStartElement (pctxt, "transportCapability", -1);

                     stat = asn1PD_H245TransportCapability (pctxt, &pvalue->transportCapability);
                     if (stat != 0) return stat;

                     invokeEndElement (pctxt, "transportCapability", -1);

                     break;

                  case 1:
                     if (openType.numocts == 0) break;

                     pvalue->m.redundancyEncodingPresent = 1;

                     invokeStartElement (pctxt, "redundancyEncoding", -1);

                     stat = asn1PD_H245RedundancyEncoding (pctxt, &pvalue->redundancyEncoding);
                     if (stat != 0) return stat;

                     invokeEndElement (pctxt, "redundancyEncoding", -1);

                     break;

                  case 2:
                     if (openType.numocts == 0) break;

                     pvalue->m.sourcePresent = 1;

                     invokeStartElement (pctxt, "source", -1);

                     stat = asn1PD_H245TerminalLabel (pctxt, &pvalue->source);
                     if (stat != 0) return stat;

                     invokeEndElement (pctxt, "source", -1);

                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters (OOCTXT* pctxt, H245OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* h222LogicalChannelParameters */
         case 0:
            invokeStartElement (pctxt, "h222LogicalChannelParameters", -1);

            pvalue->u.h222LogicalChannelParameters = memAllocTypeZ (pctxt,
               H245H222LogicalChannelParameters);

            stat = asn1PD_H245H222LogicalChannelParameters (pctxt, pvalue->u.h222LogicalChannelParameters);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "h222LogicalChannelParameters", -1);

            break;

         /* h223LogicalChannelParameters */
         case 1:
            invokeStartElement (pctxt, "h223LogicalChannelParameters", -1);

            pvalue->u.h223LogicalChannelParameters = memAllocTypeZ (pctxt,
               H245H223LogicalChannelParameters);

            stat = asn1PD_H245H223LogicalChannelParameters (pctxt, pvalue->u.h223LogicalChannelParameters);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "h223LogicalChannelParameters", -1);

            break;

         /* v76LogicalChannelParameters */
         case 2:
            invokeStartElement (pctxt, "v76LogicalChannelParameters", -1);

            pvalue->u.v76LogicalChannelParameters = memAllocTypeZ (pctxt,
               H245V76LogicalChannelParameters);

            stat = asn1PD_H245V76LogicalChannelParameters (pctxt, pvalue->u.v76LogicalChannelParameters);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "v76LogicalChannelParameters", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 4;

      if (pvalue->t < 4) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt,
         (ASN1OCTET*)openType.data, openType.numocts);

      switch (pvalue->t) {
         /* h2250LogicalChannelParameters */
         case 4:
            invokeStartElement (pctxt, "h2250LogicalChannelParameters", -1);

            pvalue->u.h2250LogicalChannelParameters = memAllocTypeZ (pctxt,
               H245H2250LogicalChannelParameters);

            stat = asn1PD_H245H2250LogicalChannelParameters (pctxt, pvalue->u.h2250LogicalChannelParameters);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "h2250LogicalChannelParameters", -1);

            break;

         /* none */
         case 5:
            invokeStartElement (pctxt, "none", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "none", -1);

            break;

         default:;
      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

EXTERN int asn1PD_H245OpenLogicalChannel_forwardLogicalChannelParameters (OOCTXT* pctxt, H245OpenLogicalChannel_forwardLogicalChannelParameters* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.portNumberPresent = optbit;

   /* decode root elements */
   /* decode portNumber */
   if (pvalue->m.portNumberPresent) {
      invokeStartElement (pctxt, "portNumber", -1);

      stat = decodeConsUInt16 (pctxt, &pvalue->portNumber, 0, 65535);
      if (stat != 0) return stat;

      invokeUIntValue (pctxt, pvalue->portNumber);
      invokeEndElement (pctxt, "portNumber", -1);

   }

   /* decode dataType */
   invokeStartElement (pctxt, "dataType", -1);

   stat = asn1PD_H245DataType (pctxt, &pvalue->dataType);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "dataType", -1);

   /* decode multiplexParameters */
   invokeStartElement (pctxt, "multiplexParameters", -1);

   stat = asn1PD_H245OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters (pctxt, &pvalue->multiplexParameters);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "multiplexParameters", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return stat;

            if (i < 2) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt,
                  (ASN1OCTET*)openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     if (openType.numocts == 0) break;

                     pvalue->m.forwardLogicalChannelDependencyPresent = 1;

                     invokeStartElement (pctxt, "forwardLogicalChannelDependency", -1);

                     stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->forwardLogicalChannelDependency);
                     if (stat != 0) return stat;

                     invokeEndElement (pctxt, "forwardLogicalChannelDependency", -1);

                     break;

                  case 1:
                     if (openType.numocts == 0) break;

                     pvalue->m.replacementForPresent = 1;

                     invokeStartElement (pctxt, "replacementFor", -1);

                     stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->replacementFor);
                     if (stat != 0) return stat;

                     invokeEndElement (pctxt, "replacementFor", -1);

                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters (OOCTXT* pctxt, H245OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* h223LogicalChannelParameters */
         case 0:
            invokeStartElement (pctxt, "h223LogicalChannelParameters", -1);

            pvalue->u.h223LogicalChannelParameters = memAllocTypeZ (pctxt,
               H245H223LogicalChannelParameters);

            stat = asn1PD_H245H223LogicalChannelParameters (pctxt, pvalue->u.h223LogicalChannelParameters);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "h223LogicalChannelParameters", -1);

            break;

         /* v76LogicalChannelParameters */
         case 1:
            invokeStartElement (pctxt, "v76LogicalChannelParameters", -1);

            pvalue->u.v76LogicalChannelParameters = memAllocTypeZ (pctxt,
               H245V76LogicalChannelParameters);

            stat = asn1PD_H245V76LogicalChannelParameters (pctxt, pvalue->u.v76LogicalChannelParameters);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "v76LogicalChannelParameters", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt,
         (ASN1OCTET*)openType.data, openType.numocts);

      switch (pvalue->t) {
         /* h2250LogicalChannelParameters */
         case 3:
            invokeStartElement (pctxt, "h2250LogicalChannelParameters", -1);

            pvalue->u.h2250LogicalChannelParameters = memAllocTypeZ (pctxt,
               H245H2250LogicalChannelParameters);

            stat = asn1PD_H245H2250LogicalChannelParameters (pctxt, pvalue->u.h2250LogicalChannelParameters);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "h2250LogicalChannelParameters", -1);

            break;

         default:;
      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

EXTERN int asn1PD_H245OpenLogicalChannel_reverseLogicalChannelParameters (OOCTXT* pctxt, H245OpenLogicalChannel_reverseLogicalChannelParameters* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.multiplexParametersPresent = optbit;

   /* decode root elements */
   /* decode dataType */
   invokeStartElement (pctxt, "dataType", -1);

   stat = asn1PD_H245DataType (pctxt, &pvalue->dataType);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "dataType", -1);

   /* decode multiplexParameters */
   if (pvalue->m.multiplexParametersPresent) {
      invokeStartElement (pctxt, "multiplexParameters", -1);

      stat = asn1PD_H245OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters (pctxt, &pvalue->multiplexParameters);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "multiplexParameters", -1);

   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return stat;

            if (i < 2) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt,
                  (ASN1OCTET*)openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     if (openType.numocts == 0) break;

                     pvalue->m.reverseLogicalChannelDependencyPresent = 1;

                     invokeStartElement (pctxt, "reverseLogicalChannelDependency", -1);

                     stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->reverseLogicalChannelDependency);
                     if (stat != 0) return stat;

                     invokeEndElement (pctxt, "reverseLogicalChannelDependency", -1);

                     break;

                  case 1:
                     if (openType.numocts == 0) break;

                     pvalue->m.replacementForPresent = 1;

                     invokeStartElement (pctxt, "replacementFor", -1);

                     stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->replacementFor);
                     if (stat != 0) return stat;

                     invokeEndElement (pctxt, "replacementFor", -1);

                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245NetworkAccessParameters_distribution (OOCTXT* pctxt, H245NetworkAccessParameters_distribution* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* unicast */
         case 0:
            invokeStartElement (pctxt, "unicast", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "unicast", -1);

            break;

         /* multicast */
         case 1:
            invokeStartElement (pctxt, "multicast", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "multicast", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

extern EXTERN const char* gs_MULTIMEDIA_SYSTEM_CONTROL_NetworkAccessParameters_networkAddress_e164Address_CharSet;

EXTERN int asn1PD_H245NetworkAccessParameters_networkAddress (OOCTXT* pctxt, H245NetworkAccessParameters_networkAddress* pvalue)
{
   static Asn1SizeCnst e164Address_lsize1 = { 0, 1, 128, 0 };
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* q2931Address */
         case 0:
            invokeStartElement (pctxt, "q2931Address", -1);

            pvalue->u.q2931Address = memAllocTypeZ (pctxt,
               H245Q2931Address);

            stat = asn1PD_H245Q2931Address (pctxt, pvalue->u.q2931Address);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "q2931Address", -1);

            break;

         /* e164Address */
         case 1:
            invokeStartElement (pctxt, "e164Address", -1);

            addSizeConstraint (pctxt, &e164Address_lsize1);

            stat = decodeConstrainedStringEx (pctxt, &pvalue->u.e164Address, gs_MULTIMEDIA_SYSTEM_CONTROL_NetworkAccessParameters_networkAddress_e164Address_CharSet, 4, 4, 7);
            if (stat != 0) return stat;

            invokeCharStrValue (pctxt, pvalue->u.e164Address);
            invokeEndElement (pctxt, "e164Address", -1);

            break;

         /* localAreaAddress */
         case 2:
            invokeStartElement (pctxt, "localAreaAddress", -1);

            pvalue->u.localAreaAddress = memAllocTypeZ (pctxt,
               H245TransportAddress);

            stat = asn1PD_H245TransportAddress (pctxt, pvalue->u.localAreaAddress);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "localAreaAddress", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 4;

      if (pvalue->t < 4) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245NetworkAccessParameters_t120SetupProcedure (OOCTXT* pctxt, H245NetworkAccessParameters_t120SetupProcedure* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* originateCall */
         case 0:
            invokeStartElement (pctxt, "originateCall", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "originateCall", -1);

            break;

         /* waitForCall */
         case 1:
            invokeStartElement (pctxt, "waitForCall", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "waitForCall", -1);

            break;

         /* issueQuery */
         case 2:
            invokeStartElement (pctxt, "issueQuery", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "issueQuery", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 4;

      if (pvalue->t < 4) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245NetworkAccessParameters (OOCTXT* pctxt, H245NetworkAccessParameters* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.distributionPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.externalReferencePresent = optbit;

   /* decode root elements */
   /* decode distribution */
   if (pvalue->m.distributionPresent) {
      invokeStartElement (pctxt, "distribution", -1);

      stat = asn1PD_H245NetworkAccessParameters_distribution (pctxt, &pvalue->distribution);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "distribution", -1);

   }

   /* decode networkAddress */
   invokeStartElement (pctxt, "networkAddress", -1);

   stat = asn1PD_H245NetworkAccessParameters_networkAddress (pctxt, &pvalue->networkAddress);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "networkAddress", -1);

   /* decode associateConference */
   invokeStartElement (pctxt, "associateConference", -1);

   stat = DECODEBIT (pctxt, &pvalue->associateConference);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->associateConference);
   invokeEndElement (pctxt, "associateConference", -1);

   /* decode externalReference */
   if (pvalue->m.externalReferencePresent) {
      invokeStartElement (pctxt, "externalReference", -1);

      stat = asn1PD_H245NetworkAccessParameters_externalReference (pctxt, &pvalue->externalReference);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "externalReference", -1);

   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return stat;

            if (i < 1) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt,
                  (ASN1OCTET*)openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     if (openType.numocts == 0) break;

                     pvalue->m.t120SetupProcedurePresent = 1;

                     invokeStartElement (pctxt, "t120SetupProcedure", -1);

                     stat = asn1PD_H245NetworkAccessParameters_t120SetupProcedure (pctxt, &pvalue->t120SetupProcedure);
                     if (stat != 0) return stat;

                     invokeEndElement (pctxt, "t120SetupProcedure", -1);

                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245EscrowData (OOCTXT* pctxt, H245EscrowData* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode escrowID */
   invokeStartElement (pctxt, "escrowID", -1);

   stat = decodeObjectIdentifier (pctxt, &pvalue->escrowID);
   if (stat != 0) return stat;

   invokeOidValue (pctxt, pvalue->escrowID.numids, pvalue->escrowID.subid);
   invokeEndElement (pctxt, "escrowID", -1);

   /* decode escrowValue */
   invokeStartElement (pctxt, "escrowValue", -1);

   stat = asn1PD_H245EscrowData_escrowValue (pctxt, &pvalue->escrowValue);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "escrowValue", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245EncryptionSync_escrowentry (OOCTXT* pctxt, H245EncryptionSync_escrowentry* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 256, 0 };
   int stat = 0;
   H245EscrowData* pdata;
   DListNode* pnode;
   OOUINT32 count = 0;
   OOUINT32 xx1 = 0;

   /* decode length determinant */

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeLength (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      invokeStartElement (pctxt, "elem", xx1);

      dListAllocNodeAndData (pctxt, H245EscrowData, &pnode, &pdata);

      stat = asn1PD_H245EscrowData (pctxt, pdata);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "elem", xx1);

      dListAppendNode2 (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1PD_H245EncryptionSync (OOCTXT* pctxt, H245EncryptionSync* pvalue)
{
   static Asn1SizeCnst h235Key_lsize1 = { 0, 1, 65535, 0 };
   int stat = 0;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.nonStandardPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.escrowentryPresent = optbit;

   /* decode root elements */
   /* decode nonStandard */
   if (pvalue->m.nonStandardPresent) {
      invokeStartElement (pctxt, "nonStandard", -1);

      stat = asn1PD_H245NonStandardParameter (pctxt, &pvalue->nonStandard);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "nonStandard", -1);

   }

   /* decode synchFlag */
   invokeStartElement (pctxt, "synchFlag", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->synchFlag, 0, 255);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->synchFlag);
   invokeEndElement (pctxt, "synchFlag", -1);

   /* decode h235Key */
   invokeStartElement (pctxt, "h235Key", -1);

   addSizeConstraint (pctxt, &h235Key_lsize1);

   stat = decodeDynOctetString (pctxt, (ASN1DynOctStr*)&pvalue->h235Key);
   if (stat != 0) return stat;

   invokeOctStrValue (pctxt, pvalue->h235Key.numocts, pvalue->h235Key.data);
   invokeEndElement (pctxt, "h235Key", -1);

   /* decode escrowentry */
   if (pvalue->m.escrowentryPresent) {
      invokeStartElement (pctxt, "escrowentry", -1);

      stat = asn1PD_H245EncryptionSync_escrowentry (pctxt, &pvalue->escrowentry);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "escrowentry", -1);

   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return stat;

            if (i < 1) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt,
                  (ASN1OCTET*)openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     if (openType.numocts == 0) break;

                     pvalue->m.genericParameterPresent = 1;

                     invokeStartElement (pctxt, "genericParameter", -1);

                     stat = asn1PD_H245GenericParameter (pctxt, &pvalue->genericParameter);
                     if (stat != 0) return stat;

                     invokeEndElement (pctxt, "genericParameter", -1);

                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245OpenLogicalChannel (OOCTXT* pctxt, H245OpenLogicalChannel* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.reverseLogicalChannelParametersPresent = optbit;

   /* decode root elements */
   /* decode forwardLogicalChannelNumber */
   invokeStartElement (pctxt, "forwardLogicalChannelNumber", -1);

   stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->forwardLogicalChannelNumber);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "forwardLogicalChannelNumber", -1);

   /* decode forwardLogicalChannelParameters */
   invokeStartElement (pctxt, "forwardLogicalChannelParameters", -1);

   stat = asn1PD_H245OpenLogicalChannel_forwardLogicalChannelParameters (pctxt, &pvalue->forwardLogicalChannelParameters);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "forwardLogicalChannelParameters", -1);

   /* decode reverseLogicalChannelParameters */
   if (pvalue->m.reverseLogicalChannelParametersPresent) {
      invokeStartElement (pctxt, "reverseLogicalChannelParameters", -1);

      stat = asn1PD_H245OpenLogicalChannel_reverseLogicalChannelParameters (pctxt, &pvalue->reverseLogicalChannelParameters);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "reverseLogicalChannelParameters", -1);

   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return stat;

            if (i < 3) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt,
                  (ASN1OCTET*)openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     if (openType.numocts == 0) break;

                     pvalue->m.separateStackPresent = 1;

                     invokeStartElement (pctxt, "separateStack", -1);

                     stat = asn1PD_H245NetworkAccessParameters (pctxt, &pvalue->separateStack);
                     if (stat != 0) return stat;

                     invokeEndElement (pctxt, "separateStack", -1);

                     break;

                  case 1:
                     if (openType.numocts == 0) break;

                     pvalue->m.encryptionSyncPresent = 1;

                     invokeStartElement (pctxt, "encryptionSync", -1);

                     stat = asn1PD_H245EncryptionSync (pctxt, &pvalue->encryptionSync);
                     if (stat != 0) return stat;

                     invokeEndElement (pctxt, "encryptionSync", -1);

                     break;

                  case 2:
                     if (openType.numocts == 0) break;

                     pvalue->m.genericInformationPresent = 1;

                     invokeStartElement (pctxt, "genericInformation", -1);

                     stat = asn1PD_H245_SeqOfH245GenericInformation (pctxt, &pvalue->genericInformation);
                     if (stat != 0) return stat;

                     invokeEndElement (pctxt, "genericInformation", -1);

                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245CloseLogicalChannel_source (OOCTXT* pctxt, H245CloseLogicalChannel_source* pvalue)
{
   int stat = 0;
   OOUINT32 ui;

   stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
   if (stat != 0) return stat;
   else pvalue->t = ui + 1;

   switch (ui) {
      /* user */
      case 0:
         invokeStartElement (pctxt, "user", -1);

         /* NULL */

         invokeNullValue (pctxt);
         invokeEndElement (pctxt, "user", -1);

         break;

      /* lcse */
      case 1:
         invokeStartElement (pctxt, "lcse", -1);

         /* NULL */

         invokeNullValue (pctxt);
         invokeEndElement (pctxt, "lcse", -1);

         break;

      default:
         return ASN_E_INVOPT;
   }

   return (stat);
}

EXTERN int asn1PD_H245CloseLogicalChannel_reason (OOCTXT* pctxt, H245CloseLogicalChannel_reason* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* unknown */
         case 0:
            invokeStartElement (pctxt, "unknown", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "unknown", -1);

            break;

         /* reopen */
         case 1:
            invokeStartElement (pctxt, "reopen", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "reopen", -1);

            break;

         /* reservationFailure */
         case 2:
            invokeStartElement (pctxt, "reservationFailure", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "reservationFailure", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 4;

      if (pvalue->t < 4) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245CloseLogicalChannel (OOCTXT* pctxt, H245CloseLogicalChannel* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode forwardLogicalChannelNumber */
   invokeStartElement (pctxt, "forwardLogicalChannelNumber", -1);

   stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->forwardLogicalChannelNumber);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "forwardLogicalChannelNumber", -1);

   /* decode source */
   invokeStartElement (pctxt, "source", -1);

   stat = asn1PD_H245CloseLogicalChannel_source (pctxt, &pvalue->source);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "source", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return stat;

            if (i < 1) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt,
                  (ASN1OCTET*)openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     if (openType.numocts == 0) break;

                     pvalue->m.reasonPresent = 1;

                     invokeStartElement (pctxt, "reason", -1);

                     stat = asn1PD_H245CloseLogicalChannel_reason (pctxt, &pvalue->reason);
                     if (stat != 0) return stat;

                     invokeEndElement (pctxt, "reason", -1);

                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245RequestChannelClose_reason (OOCTXT* pctxt, H245RequestChannelClose_reason* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 3);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* unknown */
         case 0:
            invokeStartElement (pctxt, "unknown", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "unknown", -1);

            break;

         /* normal */
         case 1:
            invokeStartElement (pctxt, "normal", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "normal", -1);

            break;

         /* reopen */
         case 2:
            invokeStartElement (pctxt, "reopen", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "reopen", -1);

            break;

         /* reservationFailure */
         case 3:
            invokeStartElement (pctxt, "reservationFailure", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "reservationFailure", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 5;

      if (pvalue->t < 5) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245RequestChannelClose (OOCTXT* pctxt, H245RequestChannelClose* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   /* decode root elements */
   /* decode forwardLogicalChannelNumber */
   invokeStartElement (pctxt, "forwardLogicalChannelNumber", -1);

   stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->forwardLogicalChannelNumber);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "forwardLogicalChannelNumber", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return stat;

            if (i < 2) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt,
                  (ASN1OCTET*)openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     if (openType.numocts == 0) break;

                     pvalue->m.qosCapabilityPresent = 1;

                     invokeStartElement (pctxt, "qosCapability", -1);

                     stat = asn1PD_H245QOSCapability (pctxt, &pvalue->qosCapability);
                     if (stat != 0) return stat;

                     invokeEndElement (pctxt, "qosCapability", -1);

                     break;

                  case 1:
                     if (openType.numocts == 0) break;

                     pvalue->m.reasonPresent = 1;

                     invokeStartElement (pctxt, "reason", -1);

                     stat = asn1PD_H245RequestChannelClose_reason (pctxt, &pvalue->reason);
                     if (stat != 0) return stat;

                     invokeEndElement (pctxt, "reason", -1);

                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245MultiplexElement_type_subElementList (OOCTXT* pctxt, H245MultiplexElement_type_subElementList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 2, 255, 0 };
   int stat = 0;
   H245MultiplexElement* pdata;
   DListNode* pnode;
   OOUINT32 count = 0;
   OOUINT32 xx1 = 0;

   /* decode length determinant */

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeLength (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      invokeStartElement (pctxt, "elem", xx1);

      dListAllocNodeAndData (pctxt, H245MultiplexElement, &pnode, &pdata);

      stat = asn1PD_H245MultiplexElement (pctxt, (H245MultiplexElement*)pdata);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "elem", xx1);

      dListAppendNode2 (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1PD_H245MultiplexElement_type (OOCTXT* pctxt, H245MultiplexElement_type* pvalue)
{
   int stat = 0;
   OOUINT32 ui;

   stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
   if (stat != 0) return stat;
   else pvalue->t = ui + 1;

   switch (ui) {
      /* logicalChannelNumber */
      case 0:
         invokeStartElement (pctxt, "logicalChannelNumber", -1);

         stat = decodeConsUInt16 (pctxt, &pvalue->u.logicalChannelNumber, 0, 65535);
         if (stat != 0) return stat;

         invokeUIntValue (pctxt, pvalue->u.logicalChannelNumber);
         invokeEndElement (pctxt, "logicalChannelNumber", -1);

         break;

      /* subElementList */
      case 1:
         invokeStartElement (pctxt, "subElementList", -1);

         pvalue->u.subElementList = memAllocTypeZ (pctxt,
            H245MultiplexElement_type_subElementList);

         stat = asn1PD_H245MultiplexElement_type_subElementList (pctxt, pvalue->u.subElementList);
         if (stat != 0) return stat;

         invokeEndElement (pctxt, "subElementList", -1);

         break;

      default:
         return ASN_E_INVOPT;
   }

   return (stat);
}

EXTERN int asn1PD_H245MultiplexElement_repeatCount (OOCTXT* pctxt, H245MultiplexElement_repeatCount* pvalue)
{
   int stat = 0;
   OOUINT32 ui;

   stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
   if (stat != 0) return stat;
   else pvalue->t = ui + 1;

   switch (ui) {
      /* finite */
      case 0:
         invokeStartElement (pctxt, "finite", -1);

         stat = decodeConsUInt16 (pctxt, &pvalue->u.finite, 1, 65535);
         if (stat != 0) return stat;

         invokeUIntValue (pctxt, pvalue->u.finite);
         invokeEndElement (pctxt, "finite", -1);

         break;

      /* untilClosingFlag */
      case 1:
         invokeStartElement (pctxt, "untilClosingFlag", -1);

         /* NULL */

         invokeNullValue (pctxt);
         invokeEndElement (pctxt, "untilClosingFlag", -1);

         break;

      default:
         return ASN_E_INVOPT;
   }

   return (stat);
}

EXTERN int asn1PD_H245MultiplexElement (OOCTXT* pctxt, H245MultiplexElement* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode type */
   invokeStartElement (pctxt, "type", -1);

   stat = asn1PD_H245MultiplexElement_type (pctxt, &pvalue->type);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "type", -1);

   /* decode repeatCount */
   invokeStartElement (pctxt, "repeatCount", -1);

   stat = asn1PD_H245MultiplexElement_repeatCount (pctxt, &pvalue->repeatCount);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "repeatCount", -1);

   return (stat);
}

EXTERN int asn1PD_H245MultiplexEntryDescriptor_elementList (OOCTXT* pctxt, H245MultiplexEntryDescriptor_elementList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 256, 0 };
   int stat = 0;
   H245MultiplexElement* pdata;
   DListNode* pnode;
   OOUINT32 count = 0;
   OOUINT32 xx1 = 0;

   /* decode length determinant */

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeLength (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      invokeStartElement (pctxt, "elem", xx1);

      dListAllocNodeAndData (pctxt, H245MultiplexElement, &pnode, &pdata);

      stat = asn1PD_H245MultiplexElement (pctxt, pdata);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "elem", xx1);

      dListAppendNode2 (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1PD_H245MultiplexEntryDescriptor (OOCTXT* pctxt, H245MultiplexEntryDescriptor* pvalue)
{
   int stat = 0;
   OOBOOL optbit = FALSE;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.elementListPresent = optbit;

   /* decode root elements */
   /* decode multiplexTableEntryNumber */
   invokeStartElement (pctxt, "multiplexTableEntryNumber", -1);

   stat = asn1PD_H245MultiplexTableEntryNumber (pctxt, &pvalue->multiplexTableEntryNumber);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "multiplexTableEntryNumber", -1);

   /* decode elementList */
   if (pvalue->m.elementListPresent) {
      invokeStartElement (pctxt, "elementList", -1);

      stat = asn1PD_H245MultiplexEntryDescriptor_elementList (pctxt, &pvalue->elementList);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "elementList", -1);

   }

   return (stat);
}

EXTERN int asn1PD_H245MultiplexEntrySend_multiplexEntryDescriptors (OOCTXT* pctxt, H245MultiplexEntrySend_multiplexEntryDescriptors* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 15, 0 };
   int stat = 0;
   H245MultiplexEntryDescriptor* pdata;
   DListNode* pnode;
   OOUINT32 count = 0;
   OOUINT32 xx1 = 0;

   /* decode length determinant */

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeLength (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      invokeStartElement (pctxt, "elem", xx1);

      dListAllocNodeAndData (pctxt, H245MultiplexEntryDescriptor, &pnode, &pdata);

      stat = asn1PD_H245MultiplexEntryDescriptor (pctxt, pdata);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "elem", xx1);

      dListAppendNode2 (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1PD_H245MultiplexEntrySend (OOCTXT* pctxt, H245MultiplexEntrySend* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode sequenceNumber */
   invokeStartElement (pctxt, "sequenceNumber", -1);

   stat = asn1PD_H245SequenceNumber (pctxt, &pvalue->sequenceNumber);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "sequenceNumber", -1);

   /* decode multiplexEntryDescriptors */
   invokeStartElement (pctxt, "multiplexEntryDescriptors", -1);

   stat = asn1PD_H245MultiplexEntrySend_multiplexEntryDescriptors (pctxt, &pvalue->multiplexEntryDescriptors);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "multiplexEntryDescriptors", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245RequestMultiplexEntry_entryNumbers (OOCTXT* pctxt, H245RequestMultiplexEntry_entryNumbers* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 15, 0 };
   int stat = 0;
   OOUINT32 xx1 = 0;

   /* decode length determinant */

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeLength (pctxt, &pvalue->n);
   if (stat != 0) return stat;

   /* decode elements */

   if (15 < pvalue->n) {
      return stat;
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      invokeStartElement (pctxt, "elem", xx1);

      stat = asn1PD_H245MultiplexTableEntryNumber (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "elem", xx1);

   }

   return (stat);
}

EXTERN int asn1PD_H245RequestMultiplexEntry (OOCTXT* pctxt, H245RequestMultiplexEntry* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode entryNumbers */
   invokeStartElement (pctxt, "entryNumbers", -1);

   stat = asn1PD_H245RequestMultiplexEntry_entryNumbers (pctxt, &pvalue->entryNumbers);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "entryNumbers", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245H261VideoMode_resolution (OOCTXT* pctxt, H245H261VideoMode_resolution* pvalue)
{
   int stat = 0;
   OOUINT32 ui;

   stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
   if (stat != 0) return stat;
   else pvalue->t = ui + 1;

   switch (ui) {
      /* qcif */
      case 0:
         invokeStartElement (pctxt, "qcif", -1);

         /* NULL */

         invokeNullValue (pctxt);
         invokeEndElement (pctxt, "qcif", -1);

         break;

      /* cif */
      case 1:
         invokeStartElement (pctxt, "cif", -1);

         /* NULL */

         invokeNullValue (pctxt);
         invokeEndElement (pctxt, "cif", -1);

         break;

      default:
         return ASN_E_INVOPT;
   }

   return (stat);
}

EXTERN int asn1PD_H245H261VideoMode (OOCTXT* pctxt, H245H261VideoMode* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode resolution */
   invokeStartElement (pctxt, "resolution", -1);

   stat = asn1PD_H245H261VideoMode_resolution (pctxt, &pvalue->resolution);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "resolution", -1);

   /* decode bitRate */
   invokeStartElement (pctxt, "bitRate", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->bitRate, 1, 19200);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->bitRate);
   invokeEndElement (pctxt, "bitRate", -1);

   /* decode stillImageTransmission */
   invokeStartElement (pctxt, "stillImageTransmission", -1);

   stat = DECODEBIT (pctxt, &pvalue->stillImageTransmission);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->stillImageTransmission);
   invokeEndElement (pctxt, "stillImageTransmission", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245H262VideoMode_profileAndLevel (OOCTXT* pctxt, H245H262VideoMode_profileAndLevel* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 10);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* profileAndLevel_SPatML */
         case 0:
            invokeStartElement (pctxt, "profileAndLevel_SPatML", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "profileAndLevel_SPatML", -1);

            break;

         /* profileAndLevel_MPatLL */
         case 1:
            invokeStartElement (pctxt, "profileAndLevel_MPatLL", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "profileAndLevel_MPatLL", -1);

            break;

         /* profileAndLevel_MPatML */
         case 2:
            invokeStartElement (pctxt, "profileAndLevel_MPatML", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "profileAndLevel_MPatML", -1);

            break;

         /* profileAndLevel_MPatH_14 */
         case 3:
            invokeStartElement (pctxt, "profileAndLevel_MPatH_14", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "profileAndLevel_MPatH_14", -1);

            break;

         /* profileAndLevel_MPatHL */
         case 4:
            invokeStartElement (pctxt, "profileAndLevel_MPatHL", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "profileAndLevel_MPatHL", -1);

            break;

         /* profileAndLevel_SNRatLL */
         case 5:
            invokeStartElement (pctxt, "profileAndLevel_SNRatLL", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "profileAndLevel_SNRatLL", -1);

            break;

         /* profileAndLevel_SNRatML */
         case 6:
            invokeStartElement (pctxt, "profileAndLevel_SNRatML", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "profileAndLevel_SNRatML", -1);

            break;

         /* profileAndLevel_SpatialatH_14 */
         case 7:
            invokeStartElement (pctxt, "profileAndLevel_SpatialatH_14", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "profileAndLevel_SpatialatH_14", -1);

            break;

         /* profileAndLevel_HPatML */
         case 8:
            invokeStartElement (pctxt, "profileAndLevel_HPatML", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "profileAndLevel_HPatML", -1);

            break;

         /* profileAndLevel_HPatH_14 */
         case 9:
            invokeStartElement (pctxt, "profileAndLevel_HPatH_14", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "profileAndLevel_HPatH_14", -1);

            break;

         /* profileAndLevel_HPatHL */
         case 10:
            invokeStartElement (pctxt, "profileAndLevel_HPatHL", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "profileAndLevel_HPatHL", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 12;

      if (pvalue->t < 12) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245H262VideoMode (OOCTXT* pctxt, H245H262VideoMode* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;
   OOUINT32 j = 0;
   OOBOOL optbits[6];

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   for (i = 0; i < 6; i++) {
      stat = DECODEBIT (pctxt, &optbits[i]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i = 0; i < 7; i++) {
      switch (i) {
         case 0:
         /* decode profileAndLevel */
         invokeStartElement (pctxt, "profileAndLevel", -1);

         stat = asn1PD_H245H262VideoMode_profileAndLevel (pctxt, &pvalue->profileAndLevel);

         invokeEndElement (pctxt, "profileAndLevel", -1);

         break;

         case 1:
         /* decode videoBitRate */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "videoBitRate", -1);

            stat = decodeConsUnsigned (pctxt, &pvalue->videoBitRate, 0, 1073741823);

            invokeUIntValue (pctxt, pvalue->videoBitRate);
            pvalue->m.videoBitRatePresent = 1;
            invokeEndElement (pctxt, "videoBitRate", -1);

         }
         break;

         case 2:
         /* decode vbvBufferSize */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "vbvBufferSize", -1);

            stat = decodeConsUnsigned (pctxt, &pvalue->vbvBufferSize, 0, 262143);

            invokeUIntValue (pctxt, pvalue->vbvBufferSize);
            pvalue->m.vbvBufferSizePresent = 1;
            invokeEndElement (pctxt, "vbvBufferSize", -1);

         }
         break;

         case 3:
         /* decode samplesPerLine */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "samplesPerLine", -1);

            stat = decodeConsUInt16 (pctxt, &pvalue->samplesPerLine, 0, 16383);

            invokeUIntValue (pctxt, pvalue->samplesPerLine);
            pvalue->m.samplesPerLinePresent = 1;
            invokeEndElement (pctxt, "samplesPerLine", -1);

         }
         break;

         case 4:
         /* decode linesPerFrame */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "linesPerFrame", -1);

            stat = decodeConsUInt16 (pctxt, &pvalue->linesPerFrame, 0, 16383);

            invokeUIntValue (pctxt, pvalue->linesPerFrame);
            pvalue->m.linesPerFramePresent = 1;
            invokeEndElement (pctxt, "linesPerFrame", -1);

         }
         break;

         case 5:
         /* decode framesPerSecond */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "framesPerSecond", -1);

            stat = decodeConsUInt8 (pctxt, &pvalue->framesPerSecond, 0, 15);

            invokeUIntValue (pctxt, pvalue->framesPerSecond);
            pvalue->m.framesPerSecondPresent = 1;
            invokeEndElement (pctxt, "framesPerSecond", -1);

         }
         break;

         case 6:
         /* decode luminanceSampleRate */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "luminanceSampleRate", -1);

            stat = decodeConsUnsigned (pctxt, &pvalue->luminanceSampleRate, 0, OOUINT32_MAX);

            invokeUIntValue (pctxt, pvalue->luminanceSampleRate);
            pvalue->m.luminanceSampleRatePresent = 1;
            invokeEndElement (pctxt, "luminanceSampleRate", -1);

         }
         break;

         default: j++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245H263VideoMode_resolution (OOCTXT* pctxt, H245H263VideoMode_resolution* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 4);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* sqcif */
         case 0:
            invokeStartElement (pctxt, "sqcif", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "sqcif", -1);

            break;

         /* qcif */
         case 1:
            invokeStartElement (pctxt, "qcif", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "qcif", -1);

            break;

         /* cif */
         case 2:
            invokeStartElement (pctxt, "cif", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "cif", -1);

            break;

         /* cif4 */
         case 3:
            invokeStartElement (pctxt, "cif4", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "cif4", -1);

            break;

         /* cif16 */
         case 4:
            invokeStartElement (pctxt, "cif16", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "cif16", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 6;

      if (pvalue->t < 6) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt,
         (ASN1OCTET*)openType.data, openType.numocts);

      switch (pvalue->t) {
         /* custom */
         case 6:
            invokeStartElement (pctxt, "custom", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "custom", -1);

            break;

         default:;
      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

EXTERN int asn1PD_H245H263VideoMode (OOCTXT* pctxt, H245H263VideoMode* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   /* decode root elements */
   /* decode resolution */
   invokeStartElement (pctxt, "resolution", -1);

   stat = asn1PD_H245H263VideoMode_resolution (pctxt, &pvalue->resolution);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "resolution", -1);

   /* decode bitRate */
   invokeStartElement (pctxt, "bitRate", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->bitRate, 1, 19200);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->bitRate);
   invokeEndElement (pctxt, "bitRate", -1);

   /* decode unrestrictedVector */
   invokeStartElement (pctxt, "unrestrictedVector", -1);

   stat = DECODEBIT (pctxt, &pvalue->unrestrictedVector);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->unrestrictedVector);
   invokeEndElement (pctxt, "unrestrictedVector", -1);

   /* decode arithmeticCoding */
   invokeStartElement (pctxt, "arithmeticCoding", -1);

   stat = DECODEBIT (pctxt, &pvalue->arithmeticCoding);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->arithmeticCoding);
   invokeEndElement (pctxt, "arithmeticCoding", -1);

   /* decode advancedPrediction */
   invokeStartElement (pctxt, "advancedPrediction", -1);

   stat = DECODEBIT (pctxt, &pvalue->advancedPrediction);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->advancedPrediction);
   invokeEndElement (pctxt, "advancedPrediction", -1);

   /* decode pbFrames */
   invokeStartElement (pctxt, "pbFrames", -1);

   stat = DECODEBIT (pctxt, &pvalue->pbFrames);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->pbFrames);
   invokeEndElement (pctxt, "pbFrames", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return stat;

            if (i < 3) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt,
                  (ASN1OCTET*)openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     if (openType.numocts == 0) break;

                     pvalue->m.errorCompensationPresent = 1;

                     invokeStartElement (pctxt, "errorCompensation", -1);

                     stat = DECODEBIT (pctxt, &pvalue->errorCompensation);
                     if (stat != 0) return stat;

                     invokeBoolValue (pctxt, pvalue->errorCompensation);
                     invokeEndElement (pctxt, "errorCompensation", -1);

                     break;

                  case 1:
                     if (openType.numocts == 0) break;

                     pvalue->m.enhancementLayerInfoPresent = 1;

                     invokeStartElement (pctxt, "enhancementLayerInfo", -1);

                     stat = asn1PD_H245EnhancementLayerInfo (pctxt, &pvalue->enhancementLayerInfo);
                     if (stat != 0) return stat;

                     invokeEndElement (pctxt, "enhancementLayerInfo", -1);

                     break;

                  case 2:
                     if (openType.numocts == 0) break;

                     pvalue->m.h263OptionsPresent = 1;

                     invokeStartElement (pctxt, "h263Options", -1);

                     stat = asn1PD_H245H263Options (pctxt, &pvalue->h263Options);
                     if (stat != 0) return stat;

                     invokeEndElement (pctxt, "h263Options", -1);

                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245IS11172VideoMode (OOCTXT* pctxt, H245IS11172VideoMode* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;
   OOUINT32 j = 0;
   OOBOOL optbits[6];

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   for (i = 0; i < 6; i++) {
      stat = DECODEBIT (pctxt, &optbits[i]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i = 0; i < 7; i++) {
      switch (i) {
         case 0:
         /* decode constrainedBitstream */
         invokeStartElement (pctxt, "constrainedBitstream", -1);

         stat = DECODEBIT (pctxt, &pvalue->constrainedBitstream);

         invokeBoolValue (pctxt, pvalue->constrainedBitstream);
         invokeEndElement (pctxt, "constrainedBitstream", -1);

         break;

         case 1:
         /* decode videoBitRate */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "videoBitRate", -1);

            stat = decodeConsUnsigned (pctxt, &pvalue->videoBitRate, 0, 1073741823);

            invokeUIntValue (pctxt, pvalue->videoBitRate);
            pvalue->m.videoBitRatePresent = 1;
            invokeEndElement (pctxt, "videoBitRate", -1);

         }
         break;

         case 2:
         /* decode vbvBufferSize */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "vbvBufferSize", -1);

            stat = decodeConsUnsigned (pctxt, &pvalue->vbvBufferSize, 0, 262143);

            invokeUIntValue (pctxt, pvalue->vbvBufferSize);
            pvalue->m.vbvBufferSizePresent = 1;
            invokeEndElement (pctxt, "vbvBufferSize", -1);

         }
         break;

         case 3:
         /* decode samplesPerLine */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "samplesPerLine", -1);

            stat = decodeConsUInt16 (pctxt, &pvalue->samplesPerLine, 0, 16383);

            invokeUIntValue (pctxt, pvalue->samplesPerLine);
            pvalue->m.samplesPerLinePresent = 1;
            invokeEndElement (pctxt, "samplesPerLine", -1);

         }
         break;

         case 4:
         /* decode linesPerFrame */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "linesPerFrame", -1);

            stat = decodeConsUInt16 (pctxt, &pvalue->linesPerFrame, 0, 16383);

            invokeUIntValue (pctxt, pvalue->linesPerFrame);
            pvalue->m.linesPerFramePresent = 1;
            invokeEndElement (pctxt, "linesPerFrame", -1);

         }
         break;

         case 5:
         /* decode pictureRate */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "pictureRate", -1);

            stat = decodeConsUInt8 (pctxt, &pvalue->pictureRate, 0, 15);

            invokeUIntValue (pctxt, pvalue->pictureRate);
            pvalue->m.pictureRatePresent = 1;
            invokeEndElement (pctxt, "pictureRate", -1);

         }
         break;

         case 6:
         /* decode luminanceSampleRate */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "luminanceSampleRate", -1);

            stat = decodeConsUnsigned (pctxt, &pvalue->luminanceSampleRate, 0, OOUINT32_MAX);

            invokeUIntValue (pctxt, pvalue->luminanceSampleRate);
            pvalue->m.luminanceSampleRatePresent = 1;
            invokeEndElement (pctxt, "luminanceSampleRate", -1);

         }
         break;

         default: j++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245VideoMode (OOCTXT* pctxt, H245VideoMode* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 4);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            invokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = memAllocTypeZ (pctxt,
               H245NonStandardParameter);

            stat = asn1PD_H245NonStandardParameter (pctxt, pvalue->u.nonStandard);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* h261VideoMode */
         case 1:
            invokeStartElement (pctxt, "h261VideoMode", -1);

            pvalue->u.h261VideoMode = memAllocTypeZ (pctxt,
               H245H261VideoMode);

            stat = asn1PD_H245H261VideoMode (pctxt, pvalue->u.h261VideoMode);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "h261VideoMode", -1);

            break;

         /* h262VideoMode */
         case 2:
            invokeStartElement (pctxt, "h262VideoMode", -1);

            pvalue->u.h262VideoMode = memAllocTypeZ (pctxt,
               H245H262VideoMode);

            stat = asn1PD_H245H262VideoMode (pctxt, pvalue->u.h262VideoMode);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "h262VideoMode", -1);

            break;

         /* h263VideoMode */
         case 3:
            invokeStartElement (pctxt, "h263VideoMode", -1);

            pvalue->u.h263VideoMode = memAllocTypeZ (pctxt,
               H245H263VideoMode);

            stat = asn1PD_H245H263VideoMode (pctxt, pvalue->u.h263VideoMode);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "h263VideoMode", -1);

            break;

         /* is11172VideoMode */
         case 4:
            invokeStartElement (pctxt, "is11172VideoMode", -1);

            pvalue->u.is11172VideoMode = memAllocTypeZ (pctxt,
               H245IS11172VideoMode);

            stat = asn1PD_H245IS11172VideoMode (pctxt, pvalue->u.is11172VideoMode);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "is11172VideoMode", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 6;

      if (pvalue->t < 6) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt,
         (ASN1OCTET*)openType.data, openType.numocts);

      switch (pvalue->t) {
         /* genericVideoMode */
         case 6:
            invokeStartElement (pctxt, "genericVideoMode", -1);

            pvalue->u.genericVideoMode = memAllocTypeZ (pctxt,
               H245GenericCapability);

            stat = asn1PD_H245GenericCapability (pctxt, pvalue->u.genericVideoMode);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "genericVideoMode", -1);

            break;

         default:;
      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

EXTERN int asn1PD_H245AudioMode_g7231 (OOCTXT* pctxt, H245AudioMode_g7231* pvalue)
{
   int stat = 0;
   OOUINT32 ui;

   stat = decodeConsUnsigned (pctxt, &ui, 0, 3);
   if (stat != 0) return stat;
   else pvalue->t = ui + 1;

   switch (ui) {
      /* noSilenceSuppressionLowRate */
      case 0:
         invokeStartElement (pctxt, "noSilenceSuppressionLowRate", -1);

         /* NULL */

         invokeNullValue (pctxt);
         invokeEndElement (pctxt, "noSilenceSuppressionLowRate", -1);

         break;

      /* noSilenceSuppressionHighRate */
      case 1:
         invokeStartElement (pctxt, "noSilenceSuppressionHighRate", -1);

         /* NULL */

         invokeNullValue (pctxt);
         invokeEndElement (pctxt, "noSilenceSuppressionHighRate", -1);

         break;

      /* silenceSuppressionLowRate */
      case 2:
         invokeStartElement (pctxt, "silenceSuppressionLowRate", -1);

         /* NULL */

         invokeNullValue (pctxt);
         invokeEndElement (pctxt, "silenceSuppressionLowRate", -1);

         break;

      /* silenceSuppressionHighRate */
      case 3:
         invokeStartElement (pctxt, "silenceSuppressionHighRate", -1);

         /* NULL */

         invokeNullValue (pctxt);
         invokeEndElement (pctxt, "silenceSuppressionHighRate", -1);

         break;

      default:
         return ASN_E_INVOPT;
   }

   return (stat);
}

EXTERN int asn1PD_H245IS11172AudioMode_audioLayer (OOCTXT* pctxt, H245IS11172AudioMode_audioLayer* pvalue)
{
   int stat = 0;
   OOUINT32 ui;

   stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
   if (stat != 0) return stat;
   else pvalue->t = ui + 1;

   switch (ui) {
      /* audioLayer1 */
      case 0:
         invokeStartElement (pctxt, "audioLayer1", -1);

         /* NULL */

         invokeNullValue (pctxt);
         invokeEndElement (pctxt, "audioLayer1", -1);

         break;

      /* audioLayer2 */
      case 1:
         invokeStartElement (pctxt, "audioLayer2", -1);

         /* NULL */

         invokeNullValue (pctxt);
         invokeEndElement (pctxt, "audioLayer2", -1);

         break;

      /* audioLayer3 */
      case 2:
         invokeStartElement (pctxt, "audioLayer3", -1);

         /* NULL */

         invokeNullValue (pctxt);
         invokeEndElement (pctxt, "audioLayer3", -1);

         break;

      default:
         return ASN_E_INVOPT;
   }

   return (stat);
}

EXTERN int asn1PD_H245IS11172AudioMode_audioSampling (OOCTXT* pctxt, H245IS11172AudioMode_audioSampling* pvalue)
{
   int stat = 0;
   OOUINT32 ui;

   stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
   if (stat != 0) return stat;
   else pvalue->t = ui + 1;

   switch (ui) {
      /* audioSampling32k */
      case 0:
         invokeStartElement (pctxt, "audioSampling32k", -1);

         /* NULL */

         invokeNullValue (pctxt);
         invokeEndElement (pctxt, "audioSampling32k", -1);

         break;

      /* audioSampling44k1 */
      case 1:
         invokeStartElement (pctxt, "audioSampling44k1", -1);

         /* NULL */

         invokeNullValue (pctxt);
         invokeEndElement (pctxt, "audioSampling44k1", -1);

         break;

      /* audioSampling48k */
      case 2:
         invokeStartElement (pctxt, "audioSampling48k", -1);

         /* NULL */

         invokeNullValue (pctxt);
         invokeEndElement (pctxt, "audioSampling48k", -1);

         break;

      default:
         return ASN_E_INVOPT;
   }

   return (stat);
}

EXTERN int asn1PD_H245IS11172AudioMode_multichannelType (OOCTXT* pctxt, H245IS11172AudioMode_multichannelType* pvalue)
{
   int stat = 0;
   OOUINT32 ui;

   stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
   if (stat != 0) return stat;
   else pvalue->t = ui + 1;

   switch (ui) {
      /* singleChannel */
      case 0:
         invokeStartElement (pctxt, "singleChannel", -1);

         /* NULL */

         invokeNullValue (pctxt);
         invokeEndElement (pctxt, "singleChannel", -1);

         break;

      /* twoChannelStereo */
      case 1:
         invokeStartElement (pctxt, "twoChannelStereo", -1);

         /* NULL */

         invokeNullValue (pctxt);
         invokeEndElement (pctxt, "twoChannelStereo", -1);

         break;

      /* twoChannelDual */
      case 2:
         invokeStartElement (pctxt, "twoChannelDual", -1);

         /* NULL */

         invokeNullValue (pctxt);
         invokeEndElement (pctxt, "twoChannelDual", -1);

         break;

      default:
         return ASN_E_INVOPT;
   }

   return (stat);
}

EXTERN int asn1PD_H245IS11172AudioMode (OOCTXT* pctxt, H245IS11172AudioMode* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode audioLayer */
   invokeStartElement (pctxt, "audioLayer", -1);

   stat = asn1PD_H245IS11172AudioMode_audioLayer (pctxt, &pvalue->audioLayer);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "audioLayer", -1);

   /* decode audioSampling */
   invokeStartElement (pctxt, "audioSampling", -1);

   stat = asn1PD_H245IS11172AudioMode_audioSampling (pctxt, &pvalue->audioSampling);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "audioSampling", -1);

   /* decode multichannelType */
   invokeStartElement (pctxt, "multichannelType", -1);

   stat = asn1PD_H245IS11172AudioMode_multichannelType (pctxt, &pvalue->multichannelType);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "multichannelType", -1);

   /* decode bitRate */
   invokeStartElement (pctxt, "bitRate", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->bitRate, 1, 448);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->bitRate);
   invokeEndElement (pctxt, "bitRate", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245IS13818AudioMode_audioLayer (OOCTXT* pctxt, H245IS13818AudioMode_audioLayer* pvalue)
{
   int stat = 0;
   OOUINT32 ui;

   stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
   if (stat != 0) return stat;
   else pvalue->t = ui + 1;

   switch (ui) {
      /* audioLayer1 */
      case 0:
         invokeStartElement (pctxt, "audioLayer1", -1);

         /* NULL */

         invokeNullValue (pctxt);
         invokeEndElement (pctxt, "audioLayer1", -1);

         break;

      /* audioLayer2 */
      case 1:
         invokeStartElement (pctxt, "audioLayer2", -1);

         /* NULL */

         invokeNullValue (pctxt);
         invokeEndElement (pctxt, "audioLayer2", -1);

         break;

      /* audioLayer3 */
      case 2:
         invokeStartElement (pctxt, "audioLayer3", -1);

         /* NULL */

         invokeNullValue (pctxt);
         invokeEndElement (pctxt, "audioLayer3", -1);

         break;

      default:
         return ASN_E_INVOPT;
   }

   return (stat);
}

EXTERN int asn1PD_H245IS13818AudioMode_audioSampling (OOCTXT* pctxt, H245IS13818AudioMode_audioSampling* pvalue)
{
   int stat = 0;
   OOUINT32 ui;

   stat = decodeConsUnsigned (pctxt, &ui, 0, 5);
   if (stat != 0) return stat;
   else pvalue->t = ui + 1;

   switch (ui) {
      /* audioSampling16k */
      case 0:
         invokeStartElement (pctxt, "audioSampling16k", -1);

         /* NULL */

         invokeNullValue (pctxt);
         invokeEndElement (pctxt, "audioSampling16k", -1);

         break;

      /* audioSampling22k05 */
      case 1:
         invokeStartElement (pctxt, "audioSampling22k05", -1);

         /* NULL */

         invokeNullValue (pctxt);
         invokeEndElement (pctxt, "audioSampling22k05", -1);

         break;

      /* audioSampling24k */
      case 2:
         invokeStartElement (pctxt, "audioSampling24k", -1);

         /* NULL */

         invokeNullValue (pctxt);
         invokeEndElement (pctxt, "audioSampling24k", -1);

         break;

      /* audioSampling32k */
      case 3:
         invokeStartElement (pctxt, "audioSampling32k", -1);

         /* NULL */

         invokeNullValue (pctxt);
         invokeEndElement (pctxt, "audioSampling32k", -1);

         break;

      /* audioSampling44k1 */
      case 4:
         invokeStartElement (pctxt, "audioSampling44k1", -1);

         /* NULL */

         invokeNullValue (pctxt);
         invokeEndElement (pctxt, "audioSampling44k1", -1);

         break;

      /* audioSampling48k */
      case 5:
         invokeStartElement (pctxt, "audioSampling48k", -1);

         /* NULL */

         invokeNullValue (pctxt);
         invokeEndElement (pctxt, "audioSampling48k", -1);

         break;

      default:
         return ASN_E_INVOPT;
   }

   return (stat);
}

EXTERN int asn1PD_H245IS13818AudioMode_multichannelType (OOCTXT* pctxt, H245IS13818AudioMode_multichannelType* pvalue)
{
   int stat = 0;
   OOUINT32 ui;

   stat = decodeConsUnsigned (pctxt, &ui, 0, 9);
   if (stat != 0) return stat;
   else pvalue->t = ui + 1;

   switch (ui) {
      /* singleChannel */
      case 0:
         invokeStartElement (pctxt, "singleChannel", -1);

         /* NULL */

         invokeNullValue (pctxt);
         invokeEndElement (pctxt, "singleChannel", -1);

         break;

      /* twoChannelStereo */
      case 1:
         invokeStartElement (pctxt, "twoChannelStereo", -1);

         /* NULL */

         invokeNullValue (pctxt);
         invokeEndElement (pctxt, "twoChannelStereo", -1);

         break;

      /* twoChannelDual */
      case 2:
         invokeStartElement (pctxt, "twoChannelDual", -1);

         /* NULL */

         invokeNullValue (pctxt);
         invokeEndElement (pctxt, "twoChannelDual", -1);

         break;

      /* threeChannels2_1 */
      case 3:
         invokeStartElement (pctxt, "threeChannels2_1", -1);

         /* NULL */

         invokeNullValue (pctxt);
         invokeEndElement (pctxt, "threeChannels2_1", -1);

         break;

      /* threeChannels3_0 */
      case 4:
         invokeStartElement (pctxt, "threeChannels3_0", -1);

         /* NULL */

         invokeNullValue (pctxt);
         invokeEndElement (pctxt, "threeChannels3_0", -1);

         break;

      /* fourChannels2_0_2_0 */
      case 5:
         invokeStartElement (pctxt, "fourChannels2_0_2_0", -1);

         /* NULL */

         invokeNullValue (pctxt);
         invokeEndElement (pctxt, "fourChannels2_0_2_0", -1);

         break;

      /* fourChannels2_2 */
      case 6:
         invokeStartElement (pctxt, "fourChannels2_2", -1);

         /* NULL */

         invokeNullValue (pctxt);
         invokeEndElement (pctxt, "fourChannels2_2", -1);

         break;

      /* fourChannels3_1 */
      case 7:
         invokeStartElement (pctxt, "fourChannels3_1", -1);

         /* NULL */

         invokeNullValue (pctxt);
         invokeEndElement (pctxt, "fourChannels3_1", -1);

         break;

      /* fiveChannels3_0_2_0 */
      case 8:
         invokeStartElement (pctxt, "fiveChannels3_0_2_0", -1);

         /* NULL */

         invokeNullValue (pctxt);
         invokeEndElement (pctxt, "fiveChannels3_0_2_0", -1);

         break;

      /* fiveChannels3_2 */
      case 9:
         invokeStartElement (pctxt, "fiveChannels3_2", -1);

         /* NULL */

         invokeNullValue (pctxt);
         invokeEndElement (pctxt, "fiveChannels3_2", -1);

         break;

      default:
         return ASN_E_INVOPT;
   }

   return (stat);
}

EXTERN int asn1PD_H245IS13818AudioMode (OOCTXT* pctxt, H245IS13818AudioMode* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode audioLayer */
   invokeStartElement (pctxt, "audioLayer", -1);

   stat = asn1PD_H245IS13818AudioMode_audioLayer (pctxt, &pvalue->audioLayer);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "audioLayer", -1);

   /* decode audioSampling */
   invokeStartElement (pctxt, "audioSampling", -1);

   stat = asn1PD_H245IS13818AudioMode_audioSampling (pctxt, &pvalue->audioSampling);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "audioSampling", -1);

   /* decode multichannelType */
   invokeStartElement (pctxt, "multichannelType", -1);

   stat = asn1PD_H245IS13818AudioMode_multichannelType (pctxt, &pvalue->multichannelType);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "multichannelType", -1);

   /* decode lowFrequencyEnhancement */
   invokeStartElement (pctxt, "lowFrequencyEnhancement", -1);

   stat = DECODEBIT (pctxt, &pvalue->lowFrequencyEnhancement);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->lowFrequencyEnhancement);
   invokeEndElement (pctxt, "lowFrequencyEnhancement", -1);

   /* decode multilingual */
   invokeStartElement (pctxt, "multilingual", -1);

   stat = DECODEBIT (pctxt, &pvalue->multilingual);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->multilingual);
   invokeEndElement (pctxt, "multilingual", -1);

   /* decode bitRate */
   invokeStartElement (pctxt, "bitRate", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->bitRate, 1, 1130);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->bitRate);
   invokeEndElement (pctxt, "bitRate", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245G7231AnnexCMode_g723AnnexCAudioMode (OOCTXT* pctxt, H245G7231AnnexCMode_g723AnnexCAudioMode* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode highRateMode0 */
   invokeStartElement (pctxt, "highRateMode0", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->highRateMode0, 27, 78);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->highRateMode0);
   invokeEndElement (pctxt, "highRateMode0", -1);

   /* decode highRateMode1 */
   invokeStartElement (pctxt, "highRateMode1", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->highRateMode1, 27, 78);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->highRateMode1);
   invokeEndElement (pctxt, "highRateMode1", -1);

   /* decode lowRateMode0 */
   invokeStartElement (pctxt, "lowRateMode0", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->lowRateMode0, 23, 66);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->lowRateMode0);
   invokeEndElement (pctxt, "lowRateMode0", -1);

   /* decode lowRateMode1 */
   invokeStartElement (pctxt, "lowRateMode1", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->lowRateMode1, 23, 66);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->lowRateMode1);
   invokeEndElement (pctxt, "lowRateMode1", -1);

   /* decode sidMode0 */
   invokeStartElement (pctxt, "sidMode0", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->sidMode0, 6, 17);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->sidMode0);
   invokeEndElement (pctxt, "sidMode0", -1);

   /* decode sidMode1 */
   invokeStartElement (pctxt, "sidMode1", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->sidMode1, 6, 17);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->sidMode1);
   invokeEndElement (pctxt, "sidMode1", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245G7231AnnexCMode (OOCTXT* pctxt, H245G7231AnnexCMode* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode maxAl_sduAudioFrames */
   invokeStartElement (pctxt, "maxAl_sduAudioFrames", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->maxAl_sduAudioFrames, 1, 256);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->maxAl_sduAudioFrames);
   invokeEndElement (pctxt, "maxAl_sduAudioFrames", -1);

   /* decode silenceSuppression */
   invokeStartElement (pctxt, "silenceSuppression", -1);

   stat = DECODEBIT (pctxt, &pvalue->silenceSuppression);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->silenceSuppression);
   invokeEndElement (pctxt, "silenceSuppression", -1);

   /* decode g723AnnexCAudioMode */
   invokeStartElement (pctxt, "g723AnnexCAudioMode", -1);

   stat = asn1PD_H245G7231AnnexCMode_g723AnnexCAudioMode (pctxt, &pvalue->g723AnnexCAudioMode);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "g723AnnexCAudioMode", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245VBDMode (OOCTXT* pctxt, H245VBDMode* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode type */
   invokeStartElement (pctxt, "type", -1);

   pvalue->type = memAllocTypeZ (pctxt, H245AudioMode);

   stat = asn1PD_H245AudioMode (pctxt, (H245AudioMode*)pvalue->type);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "type", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245AudioMode (OOCTXT* pctxt, H245AudioMode* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 13);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            invokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = memAllocTypeZ (pctxt,
               H245NonStandardParameter);

            stat = asn1PD_H245NonStandardParameter (pctxt, pvalue->u.nonStandard);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* g711Alaw64k */
         case 1:
            invokeStartElement (pctxt, "g711Alaw64k", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "g711Alaw64k", -1);

            break;

         /* g711Alaw56k */
         case 2:
            invokeStartElement (pctxt, "g711Alaw56k", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "g711Alaw56k", -1);

            break;

         /* g711Ulaw64k */
         case 3:
            invokeStartElement (pctxt, "g711Ulaw64k", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "g711Ulaw64k", -1);

            break;

         /* g711Ulaw56k */
         case 4:
            invokeStartElement (pctxt, "g711Ulaw56k", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "g711Ulaw56k", -1);

            break;

         /* g722_64k */
         case 5:
            invokeStartElement (pctxt, "g722_64k", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "g722_64k", -1);

            break;

         /* g722_56k */
         case 6:
            invokeStartElement (pctxt, "g722_56k", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "g722_56k", -1);

            break;

         /* g722_48k */
         case 7:
            invokeStartElement (pctxt, "g722_48k", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "g722_48k", -1);

            break;

         /* g728 */
         case 8:
            invokeStartElement (pctxt, "g728", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "g728", -1);

            break;

         /* g729 */
         case 9:
            invokeStartElement (pctxt, "g729", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "g729", -1);

            break;

         /* g729AnnexA */
         case 10:
            invokeStartElement (pctxt, "g729AnnexA", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "g729AnnexA", -1);

            break;

         /* g7231 */
         case 11:
            invokeStartElement (pctxt, "g7231", -1);

            pvalue->u.g7231 = memAllocTypeZ (pctxt, H245AudioMode_g7231);

            stat = asn1PD_H245AudioMode_g7231 (pctxt, pvalue->u.g7231);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "g7231", -1);

            break;

         /* is11172AudioMode */
         case 12:
            invokeStartElement (pctxt, "is11172AudioMode", -1);

            pvalue->u.is11172AudioMode = memAllocTypeZ (pctxt,
               H245IS11172AudioMode);

            stat = asn1PD_H245IS11172AudioMode (pctxt, pvalue->u.is11172AudioMode);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "is11172AudioMode", -1);

            break;

         /* is13818AudioMode */
         case 13:
            invokeStartElement (pctxt, "is13818AudioMode", -1);

            pvalue->u.is13818AudioMode = memAllocTypeZ (pctxt,
               H245IS13818AudioMode);

            stat = asn1PD_H245IS13818AudioMode (pctxt, pvalue->u.is13818AudioMode);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "is13818AudioMode", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 15;

      if (pvalue->t < 15) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt,
         (ASN1OCTET*)openType.data, openType.numocts);

      switch (pvalue->t) {
         /* g729wAnnexB */
         case 15:
            invokeStartElement (pctxt, "g729wAnnexB", -1);

            stat = decodeConsUInt16 (pctxt, &pvalue->u.g729wAnnexB, 1, 256);
            if (stat != 0) return stat;

            invokeUIntValue (pctxt, pvalue->u.g729wAnnexB);
            invokeEndElement (pctxt, "g729wAnnexB", -1);

            break;

         /* g729AnnexAwAnnexB */
         case 16:
            invokeStartElement (pctxt, "g729AnnexAwAnnexB", -1);

            stat = decodeConsUInt16 (pctxt, &pvalue->u.g729AnnexAwAnnexB, 1, 256);
            if (stat != 0) return stat;

            invokeUIntValue (pctxt, pvalue->u.g729AnnexAwAnnexB);
            invokeEndElement (pctxt, "g729AnnexAwAnnexB", -1);

            break;

         /* g7231AnnexCMode */
         case 17:
            invokeStartElement (pctxt, "g7231AnnexCMode", -1);

            pvalue->u.g7231AnnexCMode = memAllocTypeZ (pctxt,
               H245G7231AnnexCMode);

            stat = asn1PD_H245G7231AnnexCMode (pctxt, pvalue->u.g7231AnnexCMode);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "g7231AnnexCMode", -1);

            break;

         /* gsmFullRate */
         case 18:
            invokeStartElement (pctxt, "gsmFullRate", -1);

            pvalue->u.gsmFullRate = memAllocTypeZ (pctxt,
               H245GSMAudioCapability);

            stat = asn1PD_H245GSMAudioCapability (pctxt, pvalue->u.gsmFullRate);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "gsmFullRate", -1);

            break;

         /* gsmHalfRate */
         case 19:
            invokeStartElement (pctxt, "gsmHalfRate", -1);

            pvalue->u.gsmHalfRate = memAllocTypeZ (pctxt,
               H245GSMAudioCapability);

            stat = asn1PD_H245GSMAudioCapability (pctxt, pvalue->u.gsmHalfRate);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "gsmHalfRate", -1);

            break;

         /* gsmEnhancedFullRate */
         case 20:
            invokeStartElement (pctxt, "gsmEnhancedFullRate", -1);

            pvalue->u.gsmEnhancedFullRate = memAllocTypeZ (pctxt,
               H245GSMAudioCapability);

            stat = asn1PD_H245GSMAudioCapability (pctxt, pvalue->u.gsmEnhancedFullRate);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "gsmEnhancedFullRate", -1);

            break;

         /* genericAudioMode */
         case 21:
            invokeStartElement (pctxt, "genericAudioMode", -1);

            pvalue->u.genericAudioMode = memAllocTypeZ (pctxt,
               H245GenericCapability);

            stat = asn1PD_H245GenericCapability (pctxt, pvalue->u.genericAudioMode);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "genericAudioMode", -1);

            break;

         /* g729Extensions */
         case 22:
            invokeStartElement (pctxt, "g729Extensions", -1);

            pvalue->u.g729Extensions = memAllocTypeZ (pctxt,
               H245G729Extensions);

            stat = asn1PD_H245G729Extensions (pctxt, pvalue->u.g729Extensions);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "g729Extensions", -1);

            break;

         /* vbd */
         case 23:
            invokeStartElement (pctxt, "vbd", -1);

            pvalue->u.vbd = memAllocTypeZ (pctxt, H245VBDMode);

            stat = asn1PD_H245VBDMode (pctxt, pvalue->u.vbd);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "vbd", -1);

            break;

         default:;
      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

EXTERN int asn1PD_H245DataMode_application_nlpid (OOCTXT* pctxt, H245DataMode_application_nlpid* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode nlpidProtocol */
   invokeStartElement (pctxt, "nlpidProtocol", -1);

   stat = asn1PD_H245DataProtocolCapability (pctxt, &pvalue->nlpidProtocol);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "nlpidProtocol", -1);

   /* decode nlpidData */
   invokeStartElement (pctxt, "nlpidData", -1);

   stat = decodeDynOctetString (pctxt, (ASN1DynOctStr*)&pvalue->nlpidData);
   if (stat != 0) return stat;

   invokeOctStrValue (pctxt, pvalue->nlpidData.numocts, pvalue->nlpidData.data);
   invokeEndElement (pctxt, "nlpidData", -1);

   return (stat);
}

EXTERN int asn1PD_H245DataMode_application_t38fax (OOCTXT* pctxt, H245DataMode_application_t38fax* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode t38FaxProtocol */
   invokeStartElement (pctxt, "t38FaxProtocol", -1);

   stat = asn1PD_H245DataProtocolCapability (pctxt, &pvalue->t38FaxProtocol);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "t38FaxProtocol", -1);

   /* decode t38FaxProfile */
   invokeStartElement (pctxt, "t38FaxProfile", -1);

   stat = asn1PD_H245T38FaxProfile (pctxt, &pvalue->t38FaxProfile);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "t38FaxProfile", -1);

   return (stat);
}

EXTERN int asn1PD_H245DataMode_application (OOCTXT* pctxt, H245DataMode_application* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 9);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            invokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = memAllocTypeZ (pctxt,
               H245NonStandardParameter);

            stat = asn1PD_H245NonStandardParameter (pctxt, pvalue->u.nonStandard);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* t120 */
         case 1:
            invokeStartElement (pctxt, "t120", -1);

            pvalue->u.t120 = memAllocTypeZ (pctxt,
               H245DataProtocolCapability);

            stat = asn1PD_H245DataProtocolCapability (pctxt, pvalue->u.t120);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "t120", -1);

            break;

         /* dsm_cc */
         case 2:
            invokeStartElement (pctxt, "dsm_cc", -1);

            pvalue->u.dsm_cc = memAllocTypeZ (pctxt,
               H245DataProtocolCapability);

            stat = asn1PD_H245DataProtocolCapability (pctxt, pvalue->u.dsm_cc);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "dsm_cc", -1);

            break;

         /* userData */
         case 3:
            invokeStartElement (pctxt, "userData", -1);

            pvalue->u.userData = memAllocTypeZ (pctxt,
               H245DataProtocolCapability);

            stat = asn1PD_H245DataProtocolCapability (pctxt, pvalue->u.userData);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "userData", -1);

            break;

         /* t84 */
         case 4:
            invokeStartElement (pctxt, "t84", -1);

            pvalue->u.t84 = memAllocTypeZ (pctxt,
               H245DataProtocolCapability);

            stat = asn1PD_H245DataProtocolCapability (pctxt, pvalue->u.t84);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "t84", -1);

            break;

         /* t434 */
         case 5:
            invokeStartElement (pctxt, "t434", -1);

            pvalue->u.t434 = memAllocTypeZ (pctxt,
               H245DataProtocolCapability);

            stat = asn1PD_H245DataProtocolCapability (pctxt, pvalue->u.t434);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "t434", -1);

            break;

         /* h224 */
         case 6:
            invokeStartElement (pctxt, "h224", -1);

            pvalue->u.h224 = memAllocTypeZ (pctxt,
               H245DataProtocolCapability);

            stat = asn1PD_H245DataProtocolCapability (pctxt, pvalue->u.h224);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "h224", -1);

            break;

         /* nlpid */
         case 7:
            invokeStartElement (pctxt, "nlpid", -1);

            pvalue->u.nlpid = memAllocTypeZ (pctxt,
               H245DataMode_application_nlpid);

            stat = asn1PD_H245DataMode_application_nlpid (pctxt, pvalue->u.nlpid);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "nlpid", -1);

            break;

         /* dsvdControl */
         case 8:
            invokeStartElement (pctxt, "dsvdControl", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "dsvdControl", -1);

            break;

         /* h222DataPartitioning */
         case 9:
            invokeStartElement (pctxt, "h222DataPartitioning", -1);

            pvalue->u.h222DataPartitioning = memAllocTypeZ (pctxt,
               H245DataProtocolCapability);

            stat = asn1PD_H245DataProtocolCapability (pctxt, pvalue->u.h222DataPartitioning);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "h222DataPartitioning", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 11;

      if (pvalue->t < 11) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt,
         (ASN1OCTET*)openType.data, openType.numocts);

      switch (pvalue->t) {
         /* t30fax */
         case 11:
            invokeStartElement (pctxt, "t30fax", -1);

            pvalue->u.t30fax = memAllocTypeZ (pctxt,
               H245DataProtocolCapability);

            stat = asn1PD_H245DataProtocolCapability (pctxt, pvalue->u.t30fax);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "t30fax", -1);

            break;

         /* t140 */
         case 12:
            invokeStartElement (pctxt, "t140", -1);

            pvalue->u.t140 = memAllocTypeZ (pctxt,
               H245DataProtocolCapability);

            stat = asn1PD_H245DataProtocolCapability (pctxt, pvalue->u.t140);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "t140", -1);

            break;

         /* t38fax */
         case 13:
            invokeStartElement (pctxt, "t38fax", -1);

            pvalue->u.t38fax = memAllocTypeZ (pctxt,
               H245DataMode_application_t38fax);

            stat = asn1PD_H245DataMode_application_t38fax (pctxt, pvalue->u.t38fax);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "t38fax", -1);

            break;

         /* genericDataMode */
         case 14:
            invokeStartElement (pctxt, "genericDataMode", -1);

            pvalue->u.genericDataMode = memAllocTypeZ (pctxt,
               H245GenericCapability);

            stat = asn1PD_H245GenericCapability (pctxt, pvalue->u.genericDataMode);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "genericDataMode", -1);

            break;

         default:;
      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

EXTERN int asn1PD_H245DataMode (OOCTXT* pctxt, H245DataMode* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode application */
   invokeStartElement (pctxt, "application", -1);

   stat = asn1PD_H245DataMode_application (pctxt, &pvalue->application);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "application", -1);

   /* decode bitRate */
   invokeStartElement (pctxt, "bitRate", -1);

   stat = decodeConsUnsigned (pctxt, &pvalue->bitRate, 0, OOUINT32_MAX);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->bitRate);
   invokeEndElement (pctxt, "bitRate", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245H235Mode_mediaMode (OOCTXT* pctxt, H245H235Mode_mediaMode* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 3);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            invokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = memAllocTypeZ (pctxt,
               H245NonStandardParameter);

            stat = asn1PD_H245NonStandardParameter (pctxt, pvalue->u.nonStandard);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* videoMode */
         case 1:
            invokeStartElement (pctxt, "videoMode", -1);

            pvalue->u.videoMode = memAllocTypeZ (pctxt, H245VideoMode);

            stat = asn1PD_H245VideoMode (pctxt, pvalue->u.videoMode);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "videoMode", -1);

            break;

         /* audioMode */
         case 2:
            invokeStartElement (pctxt, "audioMode", -1);

            pvalue->u.audioMode = memAllocTypeZ (pctxt, H245AudioMode);

            stat = asn1PD_H245AudioMode (pctxt, pvalue->u.audioMode);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "audioMode", -1);

            break;

         /* dataMode */
         case 3:
            invokeStartElement (pctxt, "dataMode", -1);

            pvalue->u.dataMode = memAllocTypeZ (pctxt, H245DataMode);

            stat = asn1PD_H245DataMode (pctxt, pvalue->u.dataMode);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "dataMode", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 5;

      if (pvalue->t < 5) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245H235Mode (OOCTXT* pctxt, H245H235Mode* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode encryptionAuthenticationAndIntegrity */
   invokeStartElement (pctxt, "encryptionAuthenticationAndIntegrity", -1);

   stat = asn1PD_H245EncryptionAuthenticationAndIntegrity (pctxt, &pvalue->encryptionAuthenticationAndIntegrity);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "encryptionAuthenticationAndIntegrity", -1);

   /* decode mediaMode */
   invokeStartElement (pctxt, "mediaMode", -1);

   stat = asn1PD_H245H235Mode_mediaMode (pctxt, &pvalue->mediaMode);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "mediaMode", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245FECMode_rfc2733Format (OOCTXT* pctxt, H245FECMode_rfc2733Format* pvalue)
{
   int stat = 0;
   OOUINT32 ui;

   stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
   if (stat != 0) return stat;
   else pvalue->t = ui + 1;

   switch (ui) {
      /* rfc2733rfc2198 */
      case 0:
         invokeStartElement (pctxt, "rfc2733rfc2198", -1);

         stat = asn1PD_H245MaxRedundancy (pctxt, &pvalue->u.rfc2733rfc2198);
         if (stat != 0) return stat;

         invokeEndElement (pctxt, "rfc2733rfc2198", -1);

         break;

      /* rfc2733sameport */
      case 1:
         invokeStartElement (pctxt, "rfc2733sameport", -1);

         stat = asn1PD_H245MaxRedundancy (pctxt, &pvalue->u.rfc2733sameport);
         if (stat != 0) return stat;

         invokeEndElement (pctxt, "rfc2733sameport", -1);

         break;

      /* rfc2733diffport */
      case 2:
         invokeStartElement (pctxt, "rfc2733diffport", -1);

         stat = asn1PD_H245MaxRedundancy (pctxt, &pvalue->u.rfc2733diffport);
         if (stat != 0) return stat;

         invokeEndElement (pctxt, "rfc2733diffport", -1);

         break;

      default:
         return ASN_E_INVOPT;
   }

   return (stat);
}

EXTERN int asn1PD_H245FECMode (OOCTXT* pctxt, H245FECMode* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.fecSchemePresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.rfc2733FormatPresent = optbit;

   /* decode root elements */
   /* decode protectedElement */
   invokeStartElement (pctxt, "protectedElement", -1);

   pvalue->protectedElement = memAllocTypeZ (pctxt, H245ModeElementType);

   stat = asn1PD_H245ModeElementType (pctxt, (H245ModeElementType*)pvalue->protectedElement);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "protectedElement", -1);

   /* decode fecScheme */
   if (pvalue->m.fecSchemePresent) {
      invokeStartElement (pctxt, "fecScheme", -1);

      stat = decodeObjectIdentifier (pctxt, &pvalue->fecScheme);
      if (stat != 0) return stat;

      invokeOidValue (pctxt, pvalue->fecScheme.numids, pvalue->fecScheme.subid);
      invokeEndElement (pctxt, "fecScheme", -1);

   }

   /* decode rfc2733Format */
   if (pvalue->m.rfc2733FormatPresent) {
      invokeStartElement (pctxt, "rfc2733Format", -1);

      stat = asn1PD_H245FECMode_rfc2733Format (pctxt, &pvalue->rfc2733Format);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "rfc2733Format", -1);

   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245RedundancyEncodingDTModeElement_type (OOCTXT* pctxt, H245RedundancyEncodingDTModeElement_type* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 5);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            invokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = memAllocTypeZ (pctxt,
               H245NonStandardParameter);

            stat = asn1PD_H245NonStandardParameter (pctxt, pvalue->u.nonStandard);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* videoMode */
         case 1:
            invokeStartElement (pctxt, "videoMode", -1);

            pvalue->u.videoMode = memAllocTypeZ (pctxt, H245VideoMode);

            stat = asn1PD_H245VideoMode (pctxt, pvalue->u.videoMode);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "videoMode", -1);

            break;

         /* audioMode */
         case 2:
            invokeStartElement (pctxt, "audioMode", -1);

            pvalue->u.audioMode = memAllocTypeZ (pctxt, H245AudioMode);

            stat = asn1PD_H245AudioMode (pctxt, pvalue->u.audioMode);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "audioMode", -1);

            break;

         /* dataMode */
         case 3:
            invokeStartElement (pctxt, "dataMode", -1);

            pvalue->u.dataMode = memAllocTypeZ (pctxt, H245DataMode);

            stat = asn1PD_H245DataMode (pctxt, pvalue->u.dataMode);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "dataMode", -1);

            break;

         /* encryptionMode */
         case 4:
            invokeStartElement (pctxt, "encryptionMode", -1);

            pvalue->u.encryptionMode = memAllocTypeZ (pctxt,
               H245EncryptionMode);

            stat = asn1PD_H245EncryptionMode (pctxt, pvalue->u.encryptionMode);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "encryptionMode", -1);

            break;

         /* h235Mode */
         case 5:
            invokeStartElement (pctxt, "h235Mode", -1);

            pvalue->u.h235Mode = memAllocTypeZ (pctxt, H245H235Mode);

            stat = asn1PD_H245H235Mode (pctxt, pvalue->u.h235Mode);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "h235Mode", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 7;

      if (pvalue->t < 7) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt,
         (ASN1OCTET*)openType.data, openType.numocts);

      switch (pvalue->t) {
         /* fecMode */
         case 7:
            invokeStartElement (pctxt, "fecMode", -1);

            pvalue->u.fecMode = memAllocTypeZ (pctxt, H245FECMode);

            stat = asn1PD_H245FECMode (pctxt, pvalue->u.fecMode);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "fecMode", -1);

            break;

         default:;
      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

EXTERN int asn1PD_H245RedundancyEncodingDTModeElement (OOCTXT* pctxt, H245RedundancyEncodingDTModeElement* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode type */
   invokeStartElement (pctxt, "type", -1);

   stat = asn1PD_H245RedundancyEncodingDTModeElement_type (pctxt, &pvalue->type);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "type", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245_SeqOfH245RedundancyEncodingDTModeElement (OOCTXT* pctxt, H245_SeqOfH245RedundancyEncodingDTModeElement* pvalue)
{
   int stat = 0;
   H245RedundancyEncodingDTModeElement* pdata;
   DListNode* pnode;
   OOUINT32 count = 0;
   OOUINT32 xx1 = 0;
   int lstat;
   OOUINT32 total = 0;

   dListInit (pvalue);

   for (;;) {
      /* decode length determinant */

      lstat = decodeLength (pctxt, &count);
      if (lstat != 0 && lstat != ASN_OK_FRAG) {
         return lstat;
      }
      else if (count == 0) break;
      total += count;

      /* decode elements */

      for (; xx1 < total; xx1++) {
         invokeStartElement (pctxt, "elem", xx1);

         dListAllocNodeAndData (pctxt, H245RedundancyEncodingDTModeElement, &pnode, &pdata);

         stat = asn1PD_H245RedundancyEncodingDTModeElement (pctxt, pdata);
         if (stat != 0) return stat;

         invokeEndElement (pctxt, "elem", xx1);

         dListAppendNode2 (pvalue, pnode);
      }

      if (lstat == 0) break;
   }

   return (stat);
}

EXTERN int asn1PD_H245RedundancyEncodingDTMode (OOCTXT* pctxt, H245RedundancyEncodingDTMode* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode redundancyEncodingMethod */
   invokeStartElement (pctxt, "redundancyEncodingMethod", -1);

   stat = asn1PD_H245RedundancyEncodingMethod (pctxt, &pvalue->redundancyEncodingMethod);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "redundancyEncodingMethod", -1);

   /* decode primary */
   invokeStartElement (pctxt, "primary", -1);

   stat = asn1PD_H245RedundancyEncodingDTModeElement (pctxt, &pvalue->primary);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "primary", -1);

   /* decode secondary */
   invokeStartElement (pctxt, "secondary", -1);

   stat = asn1PD_H245_SeqOfH245RedundancyEncodingDTModeElement (pctxt, &pvalue->secondary);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "secondary", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245MultiplePayloadStreamElementMode (OOCTXT* pctxt, H245MultiplePayloadStreamElementMode* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode type */
   invokeStartElement (pctxt, "type", -1);

   pvalue->type = memAllocTypeZ (pctxt, H245ModeElementType);

   stat = asn1PD_H245ModeElementType (pctxt, (H245ModeElementType*)pvalue->type);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "type", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245_SeqOfH245MultiplePayloadStreamElementMode (OOCTXT* pctxt, H245_SeqOfH245MultiplePayloadStreamElementMode* pvalue)
{
   int stat = 0;
   H245MultiplePayloadStreamElementMode* pdata;
   DListNode* pnode;
   OOUINT32 count = 0;
   OOUINT32 xx1 = 0;
   int lstat;
   OOUINT32 total = 0;

   dListInit (pvalue);

   for (;;) {
      /* decode length determinant */

      lstat = decodeLength (pctxt, &count);
      if (lstat != 0 && lstat != ASN_OK_FRAG) {
         return lstat;
      }
      else if (count == 0) break;
      total += count;

      /* decode elements */

      for (; xx1 < total; xx1++) {
         invokeStartElement (pctxt, "elem", xx1);

         dListAllocNodeAndData (pctxt, H245MultiplePayloadStreamElementMode, &pnode, &pdata);

         stat = asn1PD_H245MultiplePayloadStreamElementMode (pctxt, pdata);
         if (stat != 0) return stat;

         invokeEndElement (pctxt, "elem", xx1);

         dListAppendNode2 (pvalue, pnode);
      }

      if (lstat == 0) break;
   }

   return (stat);
}

EXTERN int asn1PD_H245MultiplePayloadStreamMode (OOCTXT* pctxt, H245MultiplePayloadStreamMode* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode elements */
   invokeStartElement (pctxt, "elements", -1);

   stat = asn1PD_H245_SeqOfH245MultiplePayloadStreamElementMode (pctxt, &pvalue->elements);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "elements", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245DepFECMode_rfc2733Mode_mode_separateStream_differentPort (OOCTXT* pctxt, H245DepFECMode_rfc2733Mode_mode_separateStream_differentPort* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.protectedPayloadTypePresent = optbit;

   /* decode root elements */
   /* decode protectedSessionID */
   invokeStartElement (pctxt, "protectedSessionID", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->protectedSessionID, 1, 255);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->protectedSessionID);
   invokeEndElement (pctxt, "protectedSessionID", -1);

   /* decode protectedPayloadType */
   if (pvalue->m.protectedPayloadTypePresent) {
      invokeStartElement (pctxt, "protectedPayloadType", -1);

      stat = decodeConsUInt8 (pctxt, &pvalue->protectedPayloadType, 0, 127);
      if (stat != 0) return stat;

      invokeUIntValue (pctxt, pvalue->protectedPayloadType);
      invokeEndElement (pctxt, "protectedPayloadType", -1);

   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245DepFECMode_rfc2733Mode_mode_separateStream_samePort (OOCTXT* pctxt, H245DepFECMode_rfc2733Mode_mode_separateStream_samePort* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode protectedType */
   invokeStartElement (pctxt, "protectedType", -1);

   pvalue->protectedType = memAllocTypeZ (pctxt, H245ModeElementType);

   stat = asn1PD_H245ModeElementType (pctxt, (H245ModeElementType*)pvalue->protectedType);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "protectedType", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245DepFECMode_rfc2733Mode_mode_separateStream (OOCTXT* pctxt, H245DepFECMode_rfc2733Mode_mode_separateStream* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* differentPort */
         case 0:
            invokeStartElement (pctxt, "differentPort", -1);

            pvalue->u.differentPort = memAllocTypeZ (pctxt,
               H245DepFECMode_rfc2733Mode_mode_separateStream_differentPort);

            stat = asn1PD_H245DepFECMode_rfc2733Mode_mode_separateStream_differentPort (pctxt, pvalue->u.differentPort);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "differentPort", -1);

            break;

         /* samePort */
         case 1:
            invokeStartElement (pctxt, "samePort", -1);

            pvalue->u.samePort = memAllocTypeZ (pctxt,
               H245DepFECMode_rfc2733Mode_mode_separateStream_samePort);

            stat = asn1PD_H245DepFECMode_rfc2733Mode_mode_separateStream_samePort (pctxt, pvalue->u.samePort);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "samePort", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245DepFECMode_rfc2733Mode_mode (OOCTXT* pctxt, H245DepFECMode_rfc2733Mode_mode* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* redundancyEncoding */
         case 0:
            invokeStartElement (pctxt, "redundancyEncoding", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "redundancyEncoding", -1);

            break;

         /* separateStream */
         case 1:
            invokeStartElement (pctxt, "separateStream", -1);

            pvalue->u.separateStream = memAllocTypeZ (pctxt,
               H245DepFECMode_rfc2733Mode_mode_separateStream);

            stat = asn1PD_H245DepFECMode_rfc2733Mode_mode_separateStream (pctxt, pvalue->u.separateStream);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "separateStream", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245DepFECMode_rfc2733Mode (OOCTXT* pctxt, H245DepFECMode_rfc2733Mode* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode mode */
   invokeStartElement (pctxt, "mode", -1);

   stat = asn1PD_H245DepFECMode_rfc2733Mode_mode (pctxt, &pvalue->mode);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "mode", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245DepFECMode (OOCTXT* pctxt, H245DepFECMode* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 0);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* rfc2733Mode */
         case 0:
            invokeStartElement (pctxt, "rfc2733Mode", -1);

            pvalue->u.rfc2733Mode = memAllocTypeZ (pctxt,
               H245DepFECMode_rfc2733Mode);

            stat = asn1PD_H245DepFECMode_rfc2733Mode (pctxt, pvalue->u.rfc2733Mode);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "rfc2733Mode", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 2;

      if (pvalue->t < 2) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245ModeElementType (OOCTXT* pctxt, H245ModeElementType* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 4);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            invokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = memAllocTypeZ (pctxt,
               H245NonStandardParameter);

            stat = asn1PD_H245NonStandardParameter (pctxt, pvalue->u.nonStandard);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* videoMode */
         case 1:
            invokeStartElement (pctxt, "videoMode", -1);

            pvalue->u.videoMode = memAllocTypeZ (pctxt, H245VideoMode);

            stat = asn1PD_H245VideoMode (pctxt, pvalue->u.videoMode);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "videoMode", -1);

            break;

         /* audioMode */
         case 2:
            invokeStartElement (pctxt, "audioMode", -1);

            pvalue->u.audioMode = memAllocTypeZ (pctxt, H245AudioMode);

            stat = asn1PD_H245AudioMode (pctxt, pvalue->u.audioMode);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "audioMode", -1);

            break;

         /* dataMode */
         case 3:
            invokeStartElement (pctxt, "dataMode", -1);

            pvalue->u.dataMode = memAllocTypeZ (pctxt, H245DataMode);

            stat = asn1PD_H245DataMode (pctxt, pvalue->u.dataMode);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "dataMode", -1);

            break;

         /* encryptionMode */
         case 4:
            invokeStartElement (pctxt, "encryptionMode", -1);

            pvalue->u.encryptionMode = memAllocTypeZ (pctxt,
               H245EncryptionMode);

            stat = asn1PD_H245EncryptionMode (pctxt, pvalue->u.encryptionMode);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "encryptionMode", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 6;

      if (pvalue->t < 6) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt,
         (ASN1OCTET*)openType.data, openType.numocts);

      switch (pvalue->t) {
         /* h235Mode */
         case 6:
            invokeStartElement (pctxt, "h235Mode", -1);

            pvalue->u.h235Mode = memAllocTypeZ (pctxt, H245H235Mode);

            stat = asn1PD_H245H235Mode (pctxt, pvalue->u.h235Mode);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "h235Mode", -1);

            break;

         /* multiplexedStreamMode */
         case 7:
            invokeStartElement (pctxt, "multiplexedStreamMode", -1);

            pvalue->u.multiplexedStreamMode = memAllocTypeZ (pctxt,
               H245MultiplexedStreamParameter);

            stat = asn1PD_H245MultiplexedStreamParameter (pctxt, pvalue->u.multiplexedStreamMode);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "multiplexedStreamMode", -1);

            break;

         /* redundancyEncodingDTMode */
         case 8:
            invokeStartElement (pctxt, "redundancyEncodingDTMode", -1);

            pvalue->u.redundancyEncodingDTMode = memAllocTypeZ (pctxt,
               H245RedundancyEncodingDTMode);

            stat = asn1PD_H245RedundancyEncodingDTMode (pctxt, pvalue->u.redundancyEncodingDTMode);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "redundancyEncodingDTMode", -1);

            break;

         /* multiplePayloadStreamMode */
         case 9:
            invokeStartElement (pctxt, "multiplePayloadStreamMode", -1);

            pvalue->u.multiplePayloadStreamMode = memAllocTypeZ (pctxt,
               H245MultiplePayloadStreamMode);

            stat = asn1PD_H245MultiplePayloadStreamMode (pctxt, pvalue->u.multiplePayloadStreamMode);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "multiplePayloadStreamMode", -1);

            break;

         /* depFecMode */
         case 10:
            invokeStartElement (pctxt, "depFecMode", -1);

            pvalue->u.depFecMode = memAllocTypeZ (pctxt, H245DepFECMode);

            stat = asn1PD_H245DepFECMode (pctxt, pvalue->u.depFecMode);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "depFecMode", -1);

            break;

         /* fecMode */
         case 11:
            invokeStartElement (pctxt, "fecMode", -1);

            pvalue->u.fecMode = memAllocTypeZ (pctxt, H245FECMode);

            stat = asn1PD_H245FECMode (pctxt, pvalue->u.fecMode);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "fecMode", -1);

            break;

         default:;
      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

EXTERN int asn1PD_H245H223ModeParameters_adaptationLayerType_al3 (OOCTXT* pctxt, H245H223ModeParameters_adaptationLayerType_al3* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode controlFieldOctets */
   invokeStartElement (pctxt, "controlFieldOctets", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->controlFieldOctets, 0, 2);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->controlFieldOctets);
   invokeEndElement (pctxt, "controlFieldOctets", -1);

   /* decode sendBufferSize */
   invokeStartElement (pctxt, "sendBufferSize", -1);

   stat = decodeConsUnsigned (pctxt, &pvalue->sendBufferSize, 0, 16777215);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->sendBufferSize);
   invokeEndElement (pctxt, "sendBufferSize", -1);

   return (stat);
}

EXTERN int asn1PD_H245H223ModeParameters_adaptationLayerType (OOCTXT* pctxt, H245H223ModeParameters_adaptationLayerType* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 5);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            invokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = memAllocTypeZ (pctxt,
               H245NonStandardParameter);

            stat = asn1PD_H245NonStandardParameter (pctxt, pvalue->u.nonStandard);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* al1Framed */
         case 1:
            invokeStartElement (pctxt, "al1Framed", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "al1Framed", -1);

            break;

         /* al1NotFramed */
         case 2:
            invokeStartElement (pctxt, "al1NotFramed", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "al1NotFramed", -1);

            break;

         /* al2WithoutSequenceNumbers */
         case 3:
            invokeStartElement (pctxt, "al2WithoutSequenceNumbers", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "al2WithoutSequenceNumbers", -1);

            break;

         /* al2WithSequenceNumbers */
         case 4:
            invokeStartElement (pctxt, "al2WithSequenceNumbers", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "al2WithSequenceNumbers", -1);

            break;

         /* al3 */
         case 5:
            invokeStartElement (pctxt, "al3", -1);

            pvalue->u.al3 = memAllocTypeZ (pctxt,
               H245H223ModeParameters_adaptationLayerType_al3);

            stat = asn1PD_H245H223ModeParameters_adaptationLayerType_al3 (pctxt, pvalue->u.al3);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "al3", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 7;

      if (pvalue->t < 7) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt,
         (ASN1OCTET*)openType.data, openType.numocts);

      switch (pvalue->t) {
         /* al1M */
         case 7:
            invokeStartElement (pctxt, "al1M", -1);

            pvalue->u.al1M = memAllocTypeZ (pctxt, H245H223AL1MParameters);

            stat = asn1PD_H245H223AL1MParameters (pctxt, pvalue->u.al1M);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "al1M", -1);

            break;

         /* al2M */
         case 8:
            invokeStartElement (pctxt, "al2M", -1);

            pvalue->u.al2M = memAllocTypeZ (pctxt, H245H223AL2MParameters);

            stat = asn1PD_H245H223AL2MParameters (pctxt, pvalue->u.al2M);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "al2M", -1);

            break;

         /* al3M */
         case 9:
            invokeStartElement (pctxt, "al3M", -1);

            pvalue->u.al3M = memAllocTypeZ (pctxt, H245H223AL3MParameters);

            stat = asn1PD_H245H223AL3MParameters (pctxt, pvalue->u.al3M);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "al3M", -1);

            break;

         default:;
      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

EXTERN int asn1PD_H245H223ModeParameters (OOCTXT* pctxt, H245H223ModeParameters* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode adaptationLayerType */
   invokeStartElement (pctxt, "adaptationLayerType", -1);

   stat = asn1PD_H245H223ModeParameters_adaptationLayerType (pctxt, &pvalue->adaptationLayerType);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "adaptationLayerType", -1);

   /* decode segmentableFlag */
   invokeStartElement (pctxt, "segmentableFlag", -1);

   stat = DECODEBIT (pctxt, &pvalue->segmentableFlag);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->segmentableFlag);
   invokeEndElement (pctxt, "segmentableFlag", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245V76ModeParameters (OOCTXT* pctxt, H245V76ModeParameters* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* suspendResumewAddress */
         case 0:
            invokeStartElement (pctxt, "suspendResumewAddress", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "suspendResumewAddress", -1);

            break;

         /* suspendResumewoAddress */
         case 1:
            invokeStartElement (pctxt, "suspendResumewoAddress", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "suspendResumewoAddress", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245RedundancyEncodingMode_secondaryEncoding (OOCTXT* pctxt, H245RedundancyEncodingMode_secondaryEncoding* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            invokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = memAllocTypeZ (pctxt,
               H245NonStandardParameter);

            stat = asn1PD_H245NonStandardParameter (pctxt, pvalue->u.nonStandard);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* audioData */
         case 1:
            invokeStartElement (pctxt, "audioData", -1);

            pvalue->u.audioData = memAllocTypeZ (pctxt, H245AudioMode);

            stat = asn1PD_H245AudioMode (pctxt, pvalue->u.audioData);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "audioData", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245RedundancyEncodingMode (OOCTXT* pctxt, H245RedundancyEncodingMode* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.secondaryEncodingPresent = optbit;

   /* decode root elements */
   /* decode redundancyEncodingMethod */
   invokeStartElement (pctxt, "redundancyEncodingMethod", -1);

   stat = asn1PD_H245RedundancyEncodingMethod (pctxt, &pvalue->redundancyEncodingMethod);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "redundancyEncodingMethod", -1);

   /* decode secondaryEncoding */
   if (pvalue->m.secondaryEncodingPresent) {
      invokeStartElement (pctxt, "secondaryEncoding", -1);

      stat = asn1PD_H245RedundancyEncodingMode_secondaryEncoding (pctxt, &pvalue->secondaryEncoding);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "secondaryEncoding", -1);

   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245H2250ModeParameters (OOCTXT* pctxt, H245H2250ModeParameters* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.redundancyEncodingModePresent = optbit;

   /* decode root elements */
   /* decode redundancyEncodingMode */
   if (pvalue->m.redundancyEncodingModePresent) {
      invokeStartElement (pctxt, "redundancyEncodingMode", -1);

      stat = asn1PD_H245RedundancyEncodingMode (pctxt, &pvalue->redundancyEncodingMode);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "redundancyEncodingMode", -1);

   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245MultiplexedStreamModeParameters (OOCTXT* pctxt, H245MultiplexedStreamModeParameters* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode logicalChannelNumber */
   invokeStartElement (pctxt, "logicalChannelNumber", -1);

   stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->logicalChannelNumber);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "logicalChannelNumber", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245ModeElement (OOCTXT* pctxt, H245ModeElement* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.h223ModeParametersPresent = optbit;

   /* decode root elements */
   /* decode type */
   invokeStartElement (pctxt, "type", -1);

   stat = asn1PD_H245ModeElementType (pctxt, &pvalue->type);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "type", -1);

   /* decode h223ModeParameters */
   if (pvalue->m.h223ModeParametersPresent) {
      invokeStartElement (pctxt, "h223ModeParameters", -1);

      stat = asn1PD_H245H223ModeParameters (pctxt, &pvalue->h223ModeParameters);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "h223ModeParameters", -1);

   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return stat;

            if (i < 5) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt,
                  (ASN1OCTET*)openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     if (openType.numocts == 0) break;

                     pvalue->m.v76ModeParametersPresent = 1;

                     invokeStartElement (pctxt, "v76ModeParameters", -1);

                     stat = asn1PD_H245V76ModeParameters (pctxt, &pvalue->v76ModeParameters);
                     if (stat != 0) return stat;

                     invokeEndElement (pctxt, "v76ModeParameters", -1);

                     break;

                  case 1:
                     if (openType.numocts == 0) break;

                     pvalue->m.h2250ModeParametersPresent = 1;

                     invokeStartElement (pctxt, "h2250ModeParameters", -1);

                     stat = asn1PD_H245H2250ModeParameters (pctxt, &pvalue->h2250ModeParameters);
                     if (stat != 0) return stat;

                     invokeEndElement (pctxt, "h2250ModeParameters", -1);

                     break;

                  case 2:
                     if (openType.numocts == 0) break;

                     pvalue->m.genericModeParametersPresent = 1;

                     invokeStartElement (pctxt, "genericModeParameters", -1);

                     stat = asn1PD_H245GenericCapability (pctxt, &pvalue->genericModeParameters);
                     if (stat != 0) return stat;

                     invokeEndElement (pctxt, "genericModeParameters", -1);

                     break;

                  case 3:
                     if (openType.numocts == 0) break;

                     pvalue->m.multiplexedStreamModeParametersPresent = 1;

                     invokeStartElement (pctxt, "multiplexedStreamModeParameters", -1);

                     stat = asn1PD_H245MultiplexedStreamModeParameters (pctxt, &pvalue->multiplexedStreamModeParameters);
                     if (stat != 0) return stat;

                     invokeEndElement (pctxt, "multiplexedStreamModeParameters", -1);

                     break;

                  case 4:
                     if (openType.numocts == 0) break;

                     pvalue->m.logicalChannelNumberPresent = 1;

                     invokeStartElement (pctxt, "logicalChannelNumber", -1);

                     stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->logicalChannelNumber);
                     if (stat != 0) return stat;

                     invokeEndElement (pctxt, "logicalChannelNumber", -1);

                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245ModeDescription (OOCTXT* pctxt, H245ModeDescription* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 256, 0 };
   int stat = 0;
   H245ModeElement* pdata;
   DListNode* pnode;
   OOUINT32 count = 0;
   OOUINT32 xx1 = 0;

   /* decode length determinant */

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeLength (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      invokeStartElement (pctxt, "elem", xx1);

      dListAllocNodeAndData (pctxt, H245ModeElement, &pnode, &pdata);

      stat = asn1PD_H245ModeElement (pctxt, pdata);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "elem", xx1);

      dListAppendNode2 (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1PD_H245RequestMode_requestedModes (OOCTXT* pctxt, H245RequestMode_requestedModes* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 256, 0 };
   int stat = 0;
   H245ModeDescription* pdata;
   DListNode* pnode;
   OOUINT32 count = 0;
   OOUINT32 xx1 = 0;

   /* decode length determinant */

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeLength (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      invokeStartElement (pctxt, "elem", xx1);

      dListAllocNodeAndData (pctxt, H245ModeDescription, &pnode, &pdata);

      stat = asn1PD_H245ModeDescription (pctxt, pdata);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "elem", xx1);

      dListAppendNode2 (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1PD_H245RequestMode (OOCTXT* pctxt, H245RequestMode* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode sequenceNumber */
   invokeStartElement (pctxt, "sequenceNumber", -1);

   stat = asn1PD_H245SequenceNumber (pctxt, &pvalue->sequenceNumber);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "sequenceNumber", -1);

   /* decode requestedModes */
   invokeStartElement (pctxt, "requestedModes", -1);

   stat = asn1PD_H245RequestMode_requestedModes (pctxt, &pvalue->requestedModes);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "requestedModes", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245RoundTripDelayRequest (OOCTXT* pctxt, H245RoundTripDelayRequest* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode sequenceNumber */
   invokeStartElement (pctxt, "sequenceNumber", -1);

   stat = asn1PD_H245SequenceNumber (pctxt, &pvalue->sequenceNumber);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "sequenceNumber", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245MaintenanceLoopRequest_type (OOCTXT* pctxt, H245MaintenanceLoopRequest_type* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* systemLoop */
         case 0:
            invokeStartElement (pctxt, "systemLoop", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "systemLoop", -1);

            break;

         /* mediaLoop */
         case 1:
            invokeStartElement (pctxt, "mediaLoop", -1);

            stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->u.mediaLoop);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "mediaLoop", -1);

            break;

         /* logicalChannelLoop */
         case 2:
            invokeStartElement (pctxt, "logicalChannelLoop", -1);

            stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->u.logicalChannelLoop);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "logicalChannelLoop", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 4;

      if (pvalue->t < 4) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245MaintenanceLoopRequest (OOCTXT* pctxt, H245MaintenanceLoopRequest* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode type */
   invokeStartElement (pctxt, "type", -1);

   stat = asn1PD_H245MaintenanceLoopRequest_type (pctxt, &pvalue->type);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "type", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245CommunicationModeRequest (OOCTXT* pctxt, H245CommunicationModeRequest* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245Criteria (OOCTXT* pctxt, H245Criteria* pvalue)
{
   static Asn1SizeCnst value_lsize1 = { 0, 1, 65535, 0 };
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode field */
   invokeStartElement (pctxt, "field", -1);

   stat = decodeObjectIdentifier (pctxt, &pvalue->field);
   if (stat != 0) return stat;

   invokeOidValue (pctxt, pvalue->field.numids, pvalue->field.subid);
   invokeEndElement (pctxt, "field", -1);

   /* decode value */
   invokeStartElement (pctxt, "value", -1);

   addSizeConstraint (pctxt, &value_lsize1);

   stat = decodeDynOctetString (pctxt, (ASN1DynOctStr*)&pvalue->value);
   if (stat != 0) return stat;

   invokeOctStrValue (pctxt, pvalue->value.numocts, pvalue->value.data);
   invokeEndElement (pctxt, "value", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245CertSelectionCriteria (OOCTXT* pctxt, H245CertSelectionCriteria* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 16, 0 };
   int stat = 0;
   H245Criteria* pdata;
   DListNode* pnode;
   OOUINT32 count = 0;
   OOUINT32 xx1 = 0;

   /* decode length determinant */

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeLength (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      invokeStartElement (pctxt, "elem", xx1);

      dListAllocNodeAndData (pctxt, H245Criteria, &pnode, &pdata);

      stat = asn1PD_H245Criteria (pctxt, pdata);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "elem", xx1);

      dListAppendNode2 (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1PD_H245ConferenceRequest_requestTerminalCertificate (OOCTXT* pctxt, H245ConferenceRequest_requestTerminalCertificate* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;
   OOUINT32 j = 0;
   OOBOOL optbits[3];

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   for (i = 0; i < 3; i++) {
      stat = DECODEBIT (pctxt, &optbits[i]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i = 0; i < 3; i++) {
      switch (i) {
         case 0:
         /* decode terminalLabel */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "terminalLabel", -1);

            stat = asn1PD_H245TerminalLabel (pctxt, &pvalue->terminalLabel);

            pvalue->m.terminalLabelPresent = 1;
            invokeEndElement (pctxt, "terminalLabel", -1);

         }
         break;

         case 1:
         /* decode certSelectionCriteria */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "certSelectionCriteria", -1);

            stat = asn1PD_H245CertSelectionCriteria (pctxt, &pvalue->certSelectionCriteria);

            pvalue->m.certSelectionCriteriaPresent = 1;
            invokeEndElement (pctxt, "certSelectionCriteria", -1);

         }
         break;

         case 2:
         /* decode sRandom */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "sRandom", -1);

            stat = decodeConsUnsigned (pctxt, &pvalue->sRandom, 1, OOUINT32_MAX);

            invokeUIntValue (pctxt, pvalue->sRandom);
            pvalue->m.sRandomPresent = 1;
            invokeEndElement (pctxt, "sRandom", -1);

         }
         break;

         default: j++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245RemoteMCRequest (OOCTXT* pctxt, H245RemoteMCRequest* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* masterActivate */
         case 0:
            invokeStartElement (pctxt, "masterActivate", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "masterActivate", -1);

            break;

         /* slaveActivate */
         case 1:
            invokeStartElement (pctxt, "slaveActivate", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "slaveActivate", -1);

            break;

         /* deActivate */
         case 2:
            invokeStartElement (pctxt, "deActivate", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "deActivate", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 4;

      if (pvalue->t < 4) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245ConferenceRequest (OOCTXT* pctxt, H245ConferenceRequest* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 7);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* terminalListRequest */
         case 0:
            invokeStartElement (pctxt, "terminalListRequest", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "terminalListRequest", -1);

            break;

         /* makeMeChair */
         case 1:
            invokeStartElement (pctxt, "makeMeChair", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "makeMeChair", -1);

            break;

         /* cancelMakeMeChair */
         case 2:
            invokeStartElement (pctxt, "cancelMakeMeChair", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "cancelMakeMeChair", -1);

            break;

         /* dropTerminal */
         case 3:
            invokeStartElement (pctxt, "dropTerminal", -1);

            pvalue->u.dropTerminal = memAllocTypeZ (pctxt,
               H245TerminalLabel);

            stat = asn1PD_H245TerminalLabel (pctxt, pvalue->u.dropTerminal);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "dropTerminal", -1);

            break;

         /* requestTerminalID */
         case 4:
            invokeStartElement (pctxt, "requestTerminalID", -1);

            pvalue->u.requestTerminalID = memAllocTypeZ (pctxt,
               H245TerminalLabel);

            stat = asn1PD_H245TerminalLabel (pctxt, pvalue->u.requestTerminalID);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "requestTerminalID", -1);

            break;

         /* enterH243Password */
         case 5:
            invokeStartElement (pctxt, "enterH243Password", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "enterH243Password", -1);

            break;

         /* enterH243TerminalID */
         case 6:
            invokeStartElement (pctxt, "enterH243TerminalID", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "enterH243TerminalID", -1);

            break;

         /* enterH243ConferenceID */
         case 7:
            invokeStartElement (pctxt, "enterH243ConferenceID", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "enterH243ConferenceID", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 9;

      if (pvalue->t < 9) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt,
         (ASN1OCTET*)openType.data, openType.numocts);

      switch (pvalue->t) {
         /* enterExtensionAddress */
         case 9:
            invokeStartElement (pctxt, "enterExtensionAddress", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "enterExtensionAddress", -1);

            break;

         /* requestChairTokenOwner */
         case 10:
            invokeStartElement (pctxt, "requestChairTokenOwner", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "requestChairTokenOwner", -1);

            break;

         /* requestTerminalCertificate */
         case 11:
            invokeStartElement (pctxt, "requestTerminalCertificate", -1);

            pvalue->u.requestTerminalCertificate = memAllocTypeZ (pctxt,
               H245ConferenceRequest_requestTerminalCertificate);

            stat = asn1PD_H245ConferenceRequest_requestTerminalCertificate (pctxt, pvalue->u.requestTerminalCertificate);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "requestTerminalCertificate", -1);

            break;

         /* broadcastMyLogicalChannel */
         case 12:
            invokeStartElement (pctxt, "broadcastMyLogicalChannel", -1);

            stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->u.broadcastMyLogicalChannel);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "broadcastMyLogicalChannel", -1);

            break;

         /* makeTerminalBroadcaster */
         case 13:
            invokeStartElement (pctxt, "makeTerminalBroadcaster", -1);

            pvalue->u.makeTerminalBroadcaster = memAllocTypeZ (pctxt,
               H245TerminalLabel);

            stat = asn1PD_H245TerminalLabel (pctxt, pvalue->u.makeTerminalBroadcaster);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "makeTerminalBroadcaster", -1);

            break;

         /* sendThisSource */
         case 14:
            invokeStartElement (pctxt, "sendThisSource", -1);

            pvalue->u.sendThisSource = memAllocTypeZ (pctxt,
               H245TerminalLabel);

            stat = asn1PD_H245TerminalLabel (pctxt, pvalue->u.sendThisSource);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "sendThisSource", -1);

            break;

         /* requestAllTerminalIDs */
         case 15:
            invokeStartElement (pctxt, "requestAllTerminalIDs", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "requestAllTerminalIDs", -1);

            break;

         /* remoteMCRequest */
         case 16:
            invokeStartElement (pctxt, "remoteMCRequest", -1);

            pvalue->u.remoteMCRequest = memAllocTypeZ (pctxt,
               H245RemoteMCRequest);

            stat = asn1PD_H245RemoteMCRequest (pctxt, pvalue->u.remoteMCRequest);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "remoteMCRequest", -1);

            break;

         default:;
      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

EXTERN int asn1PD_H245MultilinkRequest_callInformation (OOCTXT* pctxt, H245MultilinkRequest_callInformation* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode maxNumberOfAdditionalConnections */
   invokeStartElement (pctxt, "maxNumberOfAdditionalConnections", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->maxNumberOfAdditionalConnections, 1, 65535);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->maxNumberOfAdditionalConnections);
   invokeEndElement (pctxt, "maxNumberOfAdditionalConnections", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245DialingInformationNetworkType (OOCTXT* pctxt, H245DialingInformationNetworkType* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            invokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = memAllocTypeZ (pctxt,
               H245NonStandardMessage);

            stat = asn1PD_H245NonStandardMessage (pctxt, pvalue->u.nonStandard);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* n_isdn */
         case 1:
            invokeStartElement (pctxt, "n_isdn", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "n_isdn", -1);

            break;

         /* gstn */
         case 2:
            invokeStartElement (pctxt, "gstn", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "gstn", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 4;

      if (pvalue->t < 4) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt,
         (ASN1OCTET*)openType.data, openType.numocts);

      switch (pvalue->t) {
         /* mobile */
         case 4:
            invokeStartElement (pctxt, "mobile", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "mobile", -1);

            break;

         default:;
      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

EXTERN int asn1PD_H245DialingInformationNumber_networkType (OOCTXT* pctxt, H245DialingInformationNumber_networkType* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 255, 0 };
   int stat = 0;
   H245DialingInformationNetworkType* pdata;
   DListNode* pnode;
   OOUINT32 count = 0;
   OOUINT32 xx1 = 0;

   /* decode length determinant */

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeLength (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      invokeStartElement (pctxt, "elem", xx1);

      dListAllocNodeAndData (pctxt, H245DialingInformationNetworkType, &pnode, &pdata);

      stat = asn1PD_H245DialingInformationNetworkType (pctxt, pdata);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "elem", xx1);

      dListAppendNode2 (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1PD_H245DialingInformationNumber (OOCTXT* pctxt, H245DialingInformationNumber* pvalue)
{
   static Asn1SizeCnst networkAddress_lsize1 = { 0, 0, 40, 0 };
   static Asn1SizeCnst subAddress_lsize1 = { 0, 1, 40, 0 };
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.subAddressPresent = optbit;

   /* decode root elements */
   /* decode networkAddress */
   invokeStartElement (pctxt, "networkAddress", -1);

   addSizeConstraint (pctxt, &networkAddress_lsize1);

   stat = decodeConstrainedStringEx (pctxt, &pvalue->networkAddress, NUM_CANSET, 4, 4, 4);
   if (stat != 0) return stat;

   invokeCharStrValue (pctxt, pvalue->networkAddress);
   invokeEndElement (pctxt, "networkAddress", -1);

   /* decode subAddress */
   if (pvalue->m.subAddressPresent) {
      invokeStartElement (pctxt, "subAddress", -1);

      addSizeConstraint (pctxt, &subAddress_lsize1);

      stat = decodeConstrainedStringEx (pctxt, &pvalue->subAddress, 0, 8, 7, 7);
      if (stat != 0) return stat;

      invokeCharStrValue (pctxt, pvalue->subAddress);
      invokeEndElement (pctxt, "subAddress", -1);

   }

   /* decode networkType */
   invokeStartElement (pctxt, "networkType", -1);

   stat = asn1PD_H245DialingInformationNumber_networkType (pctxt, &pvalue->networkType);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "networkType", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245DialingInformation_differential (OOCTXT* pctxt, H245DialingInformation_differential* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 65535, 0 };
   int stat = 0;
   H245DialingInformationNumber* pdata;
   DListNode* pnode;
   OOUINT32 count = 0;
   OOUINT32 xx1 = 0;

   /* decode length determinant */

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeLength (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      invokeStartElement (pctxt, "elem", xx1);

      dListAllocNodeAndData (pctxt, H245DialingInformationNumber, &pnode, &pdata);

      stat = asn1PD_H245DialingInformationNumber (pctxt, pdata);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "elem", xx1);

      dListAppendNode2 (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1PD_H245DialingInformation (OOCTXT* pctxt, H245DialingInformation* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            invokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = memAllocTypeZ (pctxt,
               H245NonStandardMessage);

            stat = asn1PD_H245NonStandardMessage (pctxt, pvalue->u.nonStandard);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* differential */
         case 1:
            invokeStartElement (pctxt, "differential", -1);

            pvalue->u.differential = memAllocTypeZ (pctxt,
               H245DialingInformation_differential);

            stat = asn1PD_H245DialingInformation_differential (pctxt, pvalue->u.differential);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "differential", -1);

            break;

         /* infoNotAvailable */
         case 2:
            invokeStartElement (pctxt, "infoNotAvailable", -1);

            stat = decodeConsUInt16 (pctxt, &pvalue->u.infoNotAvailable, 1, 65535);
            if (stat != 0) return stat;

            invokeUIntValue (pctxt, pvalue->u.infoNotAvailable);
            invokeEndElement (pctxt, "infoNotAvailable", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 4;

      if (pvalue->t < 4) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245MultilinkRequest_addConnection (OOCTXT* pctxt, H245MultilinkRequest_addConnection* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode sequenceNumber */
   invokeStartElement (pctxt, "sequenceNumber", -1);

   stat = asn1PD_H245SequenceNumber (pctxt, &pvalue->sequenceNumber);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "sequenceNumber", -1);

   /* decode dialingInformation */
   invokeStartElement (pctxt, "dialingInformation", -1);

   stat = asn1PD_H245DialingInformation (pctxt, &pvalue->dialingInformation);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "dialingInformation", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245ConnectionIdentifier (OOCTXT* pctxt, H245ConnectionIdentifier* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode channelTag */
   invokeStartElement (pctxt, "channelTag", -1);

   stat = decodeConsUnsigned (pctxt, &pvalue->channelTag, 0, OOUINT32_MAX);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->channelTag);
   invokeEndElement (pctxt, "channelTag", -1);

   /* decode sequenceNumber */
   invokeStartElement (pctxt, "sequenceNumber", -1);

   stat = decodeConsUnsigned (pctxt, &pvalue->sequenceNumber, 0, OOUINT32_MAX);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->sequenceNumber);
   invokeEndElement (pctxt, "sequenceNumber", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245MultilinkRequest_removeConnection (OOCTXT* pctxt, H245MultilinkRequest_removeConnection* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode connectionIdentifier */
   invokeStartElement (pctxt, "connectionIdentifier", -1);

   stat = asn1PD_H245ConnectionIdentifier (pctxt, &pvalue->connectionIdentifier);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "connectionIdentifier", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245MultilinkRequest_maximumHeaderInterval_requestType (OOCTXT* pctxt, H245MultilinkRequest_maximumHeaderInterval_requestType* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* currentIntervalInformation */
         case 0:
            invokeStartElement (pctxt, "currentIntervalInformation", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "currentIntervalInformation", -1);

            break;

         /* requestedInterval */
         case 1:
            invokeStartElement (pctxt, "requestedInterval", -1);

            stat = decodeConsUInt16 (pctxt, &pvalue->u.requestedInterval, 0, 65535);
            if (stat != 0) return stat;

            invokeUIntValue (pctxt, pvalue->u.requestedInterval);
            invokeEndElement (pctxt, "requestedInterval", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245MultilinkRequest_maximumHeaderInterval (OOCTXT* pctxt, H245MultilinkRequest_maximumHeaderInterval* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode requestType */
   invokeStartElement (pctxt, "requestType", -1);

   stat = asn1PD_H245MultilinkRequest_maximumHeaderInterval_requestType (pctxt, &pvalue->requestType);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "requestType", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245MultilinkRequest (OOCTXT* pctxt, H245MultilinkRequest* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 4);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            invokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = memAllocTypeZ (pctxt,
               H245NonStandardMessage);

            stat = asn1PD_H245NonStandardMessage (pctxt, pvalue->u.nonStandard);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* callInformation */
         case 1:
            invokeStartElement (pctxt, "callInformation", -1);

            pvalue->u.callInformation = memAllocTypeZ (pctxt,
               H245MultilinkRequest_callInformation);

            stat = asn1PD_H245MultilinkRequest_callInformation (pctxt, pvalue->u.callInformation);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "callInformation", -1);

            break;

         /* addConnection */
         case 2:
            invokeStartElement (pctxt, "addConnection", -1);

            pvalue->u.addConnection = memAllocTypeZ (pctxt,
               H245MultilinkRequest_addConnection);

            stat = asn1PD_H245MultilinkRequest_addConnection (pctxt, pvalue->u.addConnection);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "addConnection", -1);

            break;

         /* removeConnection */
         case 3:
            invokeStartElement (pctxt, "removeConnection", -1);

            pvalue->u.removeConnection = memAllocTypeZ (pctxt,
               H245MultilinkRequest_removeConnection);

            stat = asn1PD_H245MultilinkRequest_removeConnection (pctxt, pvalue->u.removeConnection);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "removeConnection", -1);

            break;

         /* maximumHeaderInterval */
         case 4:
            invokeStartElement (pctxt, "maximumHeaderInterval", -1);

            pvalue->u.maximumHeaderInterval = memAllocTypeZ (pctxt,
               H245MultilinkRequest_maximumHeaderInterval);

            stat = asn1PD_H245MultilinkRequest_maximumHeaderInterval (pctxt, pvalue->u.maximumHeaderInterval);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "maximumHeaderInterval", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 6;

      if (pvalue->t < 6) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245LogicalChannelRateRequest (OOCTXT* pctxt, H245LogicalChannelRateRequest* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode sequenceNumber */
   invokeStartElement (pctxt, "sequenceNumber", -1);

   stat = asn1PD_H245SequenceNumber (pctxt, &pvalue->sequenceNumber);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "sequenceNumber", -1);

   /* decode logicalChannelNumber */
   invokeStartElement (pctxt, "logicalChannelNumber", -1);

   stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->logicalChannelNumber);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "logicalChannelNumber", -1);

   /* decode maximumBitRate */
   invokeStartElement (pctxt, "maximumBitRate", -1);

   stat = asn1PD_H245MaximumBitRate (pctxt, &pvalue->maximumBitRate);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "maximumBitRate", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245RequestMessage (OOCTXT* pctxt, H245RequestMessage* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 10);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            invokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = memAllocTypeZ (pctxt,
               H245NonStandardMessage);

            stat = asn1PD_H245NonStandardMessage (pctxt, pvalue->u.nonStandard);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* masterSlaveDetermination */
         case 1:
            invokeStartElement (pctxt, "masterSlaveDetermination", -1);

            pvalue->u.masterSlaveDetermination = memAllocTypeZ (pctxt,
               H245MasterSlaveDetermination);

            stat = asn1PD_H245MasterSlaveDetermination (pctxt, pvalue->u.masterSlaveDetermination);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "masterSlaveDetermination", -1);

            break;

         /* terminalCapabilitySet */
         case 2:
            invokeStartElement (pctxt, "terminalCapabilitySet", -1);

            pvalue->u.terminalCapabilitySet = memAllocTypeZ (pctxt,
               H245TerminalCapabilitySet);

            stat = asn1PD_H245TerminalCapabilitySet (pctxt, pvalue->u.terminalCapabilitySet);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "terminalCapabilitySet", -1);

            break;

         /* openLogicalChannel */
         case 3:
            invokeStartElement (pctxt, "openLogicalChannel", -1);

            pvalue->u.openLogicalChannel = memAllocTypeZ (pctxt,
               H245OpenLogicalChannel);

            stat = asn1PD_H245OpenLogicalChannel (pctxt, pvalue->u.openLogicalChannel);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "openLogicalChannel", -1);

            break;

         /* closeLogicalChannel */
         case 4:
            invokeStartElement (pctxt, "closeLogicalChannel", -1);

            pvalue->u.closeLogicalChannel = memAllocTypeZ (pctxt,
               H245CloseLogicalChannel);

            stat = asn1PD_H245CloseLogicalChannel (pctxt, pvalue->u.closeLogicalChannel);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "closeLogicalChannel", -1);

            break;

         /* requestChannelClose */
         case 5:
            invokeStartElement (pctxt, "requestChannelClose", -1);

            pvalue->u.requestChannelClose = memAllocTypeZ (pctxt,
               H245RequestChannelClose);

            stat = asn1PD_H245RequestChannelClose (pctxt, pvalue->u.requestChannelClose);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "requestChannelClose", -1);

            break;

         /* multiplexEntrySend */
         case 6:
            invokeStartElement (pctxt, "multiplexEntrySend", -1);

            pvalue->u.multiplexEntrySend = memAllocTypeZ (pctxt,
               H245MultiplexEntrySend);

            stat = asn1PD_H245MultiplexEntrySend (pctxt, pvalue->u.multiplexEntrySend);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "multiplexEntrySend", -1);

            break;

         /* requestMultiplexEntry */
         case 7:
            invokeStartElement (pctxt, "requestMultiplexEntry", -1);

            pvalue->u.requestMultiplexEntry = memAllocTypeZ (pctxt,
               H245RequestMultiplexEntry);

            stat = asn1PD_H245RequestMultiplexEntry (pctxt, pvalue->u.requestMultiplexEntry);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "requestMultiplexEntry", -1);

            break;

         /* requestMode */
         case 8:
            invokeStartElement (pctxt, "requestMode", -1);

            pvalue->u.requestMode = memAllocTypeZ (pctxt, H245RequestMode);

            stat = asn1PD_H245RequestMode (pctxt, pvalue->u.requestMode);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "requestMode", -1);

            break;

         /* roundTripDelayRequest */
         case 9:
            invokeStartElement (pctxt, "roundTripDelayRequest", -1);

            pvalue->u.roundTripDelayRequest = memAllocTypeZ (pctxt,
               H245RoundTripDelayRequest);

            stat = asn1PD_H245RoundTripDelayRequest (pctxt, pvalue->u.roundTripDelayRequest);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "roundTripDelayRequest", -1);

            break;

         /* maintenanceLoopRequest */
         case 10:
            invokeStartElement (pctxt, "maintenanceLoopRequest", -1);

            pvalue->u.maintenanceLoopRequest = memAllocTypeZ (pctxt,
               H245MaintenanceLoopRequest);

            stat = asn1PD_H245MaintenanceLoopRequest (pctxt, pvalue->u.maintenanceLoopRequest);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "maintenanceLoopRequest", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 12;

      if (pvalue->t < 12) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt,
         (ASN1OCTET*)openType.data, openType.numocts);

      switch (pvalue->t) {
         /* communicationModeRequest */
         case 12:
            invokeStartElement (pctxt, "communicationModeRequest", -1);

            pvalue->u.communicationModeRequest = memAllocTypeZ (pctxt,
               H245CommunicationModeRequest);

            stat = asn1PD_H245CommunicationModeRequest (pctxt, pvalue->u.communicationModeRequest);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "communicationModeRequest", -1);

            break;

         /* conferenceRequest */
         case 13:
            invokeStartElement (pctxt, "conferenceRequest", -1);

            pvalue->u.conferenceRequest = memAllocTypeZ (pctxt,
               H245ConferenceRequest);

            stat = asn1PD_H245ConferenceRequest (pctxt, pvalue->u.conferenceRequest);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "conferenceRequest", -1);

            break;

         /* multilinkRequest */
         case 14:
            invokeStartElement (pctxt, "multilinkRequest", -1);

            pvalue->u.multilinkRequest = memAllocTypeZ (pctxt,
               H245MultilinkRequest);

            stat = asn1PD_H245MultilinkRequest (pctxt, pvalue->u.multilinkRequest);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "multilinkRequest", -1);

            break;

         /* logicalChannelRateRequest */
         case 15:
            invokeStartElement (pctxt, "logicalChannelRateRequest", -1);

            pvalue->u.logicalChannelRateRequest = memAllocTypeZ (pctxt,
               H245LogicalChannelRateRequest);

            stat = asn1PD_H245LogicalChannelRateRequest (pctxt, pvalue->u.logicalChannelRateRequest);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "logicalChannelRateRequest", -1);

            break;

         /* genericRequest */
         case 16:
            invokeStartElement (pctxt, "genericRequest", -1);

            pvalue->u.genericRequest = memAllocTypeZ (pctxt,
               H245GenericMessage);

            stat = asn1PD_H245GenericMessage (pctxt, pvalue->u.genericRequest);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "genericRequest", -1);

            break;

         default:;
      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

EXTERN int asn1PD_H245MasterSlaveDeterminationAck_decision (OOCTXT* pctxt, H245MasterSlaveDeterminationAck_decision* pvalue)
{
   int stat = 0;
   OOUINT32 ui;

   stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
   if (stat != 0) return stat;
   else pvalue->t = ui + 1;

   switch (ui) {
      /* master */
      case 0:
         invokeStartElement (pctxt, "master", -1);

         /* NULL */

         invokeNullValue (pctxt);
         invokeEndElement (pctxt, "master", -1);

         break;

      /* slave */
      case 1:
         invokeStartElement (pctxt, "slave", -1);

         /* NULL */

         invokeNullValue (pctxt);
         invokeEndElement (pctxt, "slave", -1);

         break;

      default:
         return ASN_E_INVOPT;
   }

   return (stat);
}

EXTERN int asn1PD_H245MasterSlaveDeterminationAck (OOCTXT* pctxt, H245MasterSlaveDeterminationAck* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode decision */
   invokeStartElement (pctxt, "decision", -1);

   stat = asn1PD_H245MasterSlaveDeterminationAck_decision (pctxt, &pvalue->decision);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "decision", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245MasterSlaveDeterminationReject_cause (OOCTXT* pctxt, H245MasterSlaveDeterminationReject_cause* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 0);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* identicalNumbers */
         case 0:
            invokeStartElement (pctxt, "identicalNumbers", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "identicalNumbers", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 2;

      if (pvalue->t < 2) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245MasterSlaveDeterminationReject (OOCTXT* pctxt, H245MasterSlaveDeterminationReject* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode cause */
   invokeStartElement (pctxt, "cause", -1);

   stat = asn1PD_H245MasterSlaveDeterminationReject_cause (pctxt, &pvalue->cause);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "cause", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245TerminalCapabilitySetAck (OOCTXT* pctxt, H245TerminalCapabilitySetAck* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   /* decode root elements */
   /* decode sequenceNumber */
   invokeStartElement (pctxt, "sequenceNumber", -1);

   stat = asn1PD_H245SequenceNumber (pctxt, &pvalue->sequenceNumber);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "sequenceNumber", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return stat;

            if (i < 1) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt,
                  (ASN1OCTET*)openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     if (openType.numocts == 0) break;

                     pvalue->m.genericInformationPresent = 1;

                     invokeStartElement (pctxt, "genericInformation", -1);

                     stat = asn1PD_H245_SeqOfH245GenericInformation (pctxt, &pvalue->genericInformation);
                     if (stat != 0) return stat;

                     invokeEndElement (pctxt, "genericInformation", -1);

                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded (OOCTXT* pctxt, H245TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded* pvalue)
{
   int stat = 0;
   OOUINT32 ui;

   stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
   if (stat != 0) return stat;
   else pvalue->t = ui + 1;

   switch (ui) {
      /* highestEntryNumberProcessed */
      case 0:
         invokeStartElement (pctxt, "highestEntryNumberProcessed", -1);

         stat = asn1PD_H245CapabilityTableEntryNumber (pctxt, &pvalue->u.highestEntryNumberProcessed);
         if (stat != 0) return stat;

         invokeEndElement (pctxt, "highestEntryNumberProcessed", -1);

         break;

      /* noneProcessed */
      case 1:
         invokeStartElement (pctxt, "noneProcessed", -1);

         /* NULL */

         invokeNullValue (pctxt);
         invokeEndElement (pctxt, "noneProcessed", -1);

         break;

      default:
         return ASN_E_INVOPT;
   }

   return (stat);
}

EXTERN int asn1PD_H245TerminalCapabilitySetReject_cause (OOCTXT* pctxt, H245TerminalCapabilitySetReject_cause* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 3);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* unspecified */
         case 0:
            invokeStartElement (pctxt, "unspecified", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "unspecified", -1);

            break;

         /* undefinedTableEntryUsed */
         case 1:
            invokeStartElement (pctxt, "undefinedTableEntryUsed", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "undefinedTableEntryUsed", -1);

            break;

         /* descriptorCapacityExceeded */
         case 2:
            invokeStartElement (pctxt, "descriptorCapacityExceeded", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "descriptorCapacityExceeded", -1);

            break;

         /* tableEntryCapacityExceeded */
         case 3:
            invokeStartElement (pctxt, "tableEntryCapacityExceeded", -1);

            pvalue->u.tableEntryCapacityExceeded = memAllocTypeZ (pctxt,
               H245TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded);

            stat = asn1PD_H245TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded (pctxt, pvalue->u.tableEntryCapacityExceeded);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "tableEntryCapacityExceeded", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 5;

      if (pvalue->t < 5) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245TerminalCapabilitySetReject (OOCTXT* pctxt, H245TerminalCapabilitySetReject* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   /* decode root elements */
   /* decode sequenceNumber */
   invokeStartElement (pctxt, "sequenceNumber", -1);

   stat = asn1PD_H245SequenceNumber (pctxt, &pvalue->sequenceNumber);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "sequenceNumber", -1);

   /* decode cause */
   invokeStartElement (pctxt, "cause", -1);

   stat = asn1PD_H245TerminalCapabilitySetReject_cause (pctxt, &pvalue->cause);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "cause", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return stat;

            if (i < 1) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt,
                  (ASN1OCTET*)openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     if (openType.numocts == 0) break;

                     pvalue->m.genericInformationPresent = 1;

                     invokeStartElement (pctxt, "genericInformation", -1);

                     stat = asn1PD_H245_SeqOfH245GenericInformation (pctxt, &pvalue->genericInformation);
                     if (stat != 0) return stat;

                     invokeEndElement (pctxt, "genericInformation", -1);

                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters (OOCTXT* pctxt, H245OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 0);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* h222LogicalChannelParameters */
         case 0:
            invokeStartElement (pctxt, "h222LogicalChannelParameters", -1);

            pvalue->u.h222LogicalChannelParameters = memAllocTypeZ (pctxt,
               H245H222LogicalChannelParameters);

            stat = asn1PD_H245H222LogicalChannelParameters (pctxt, pvalue->u.h222LogicalChannelParameters);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "h222LogicalChannelParameters", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 2;

      if (pvalue->t < 2) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt,
         (ASN1OCTET*)openType.data, openType.numocts);

      switch (pvalue->t) {
         /* h2250LogicalChannelParameters */
         case 2:
            invokeStartElement (pctxt, "h2250LogicalChannelParameters", -1);

            pvalue->u.h2250LogicalChannelParameters = memAllocTypeZ (pctxt,
               H245H2250LogicalChannelParameters);

            stat = asn1PD_H245H2250LogicalChannelParameters (pctxt, pvalue->u.h2250LogicalChannelParameters);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "h2250LogicalChannelParameters", -1);

            break;

         default:;
      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

EXTERN int asn1PD_H245OpenLogicalChannelAck_reverseLogicalChannelParameters (OOCTXT* pctxt, H245OpenLogicalChannelAck_reverseLogicalChannelParameters* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.portNumberPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.multiplexParametersPresent = optbit;

   /* decode root elements */
   /* decode reverseLogicalChannelNumber */
   invokeStartElement (pctxt, "reverseLogicalChannelNumber", -1);

   stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->reverseLogicalChannelNumber);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "reverseLogicalChannelNumber", -1);

   /* decode portNumber */
   if (pvalue->m.portNumberPresent) {
      invokeStartElement (pctxt, "portNumber", -1);

      stat = decodeConsUInt16 (pctxt, &pvalue->portNumber, 0, 65535);
      if (stat != 0) return stat;

      invokeUIntValue (pctxt, pvalue->portNumber);
      invokeEndElement (pctxt, "portNumber", -1);

   }

   /* decode multiplexParameters */
   if (pvalue->m.multiplexParametersPresent) {
      invokeStartElement (pctxt, "multiplexParameters", -1);

      stat = asn1PD_H245OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters (pctxt, &pvalue->multiplexParameters);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "multiplexParameters", -1);

   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return stat;

            if (i < 1) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt,
                  (ASN1OCTET*)openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     if (openType.numocts == 0) break;

                     pvalue->m.replacementForPresent = 1;

                     invokeStartElement (pctxt, "replacementFor", -1);

                     stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->replacementFor);
                     if (stat != 0) return stat;

                     invokeEndElement (pctxt, "replacementFor", -1);

                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245H2250LogicalChannelAckParameters (OOCTXT* pctxt, H245H2250LogicalChannelAckParameters* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;
   OOUINT32 j = 0;
   OOBOOL optbits[5];

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   for (i = 0; i < 5; i++) {
      stat = DECODEBIT (pctxt, &optbits[i]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i = 0; i < 5; i++) {
      switch (i) {
         case 0:
         /* decode nonStandard */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "nonStandard", -1);

            stat = asn1PD_H245_SeqOfH245NonStandardParameter (pctxt, &pvalue->nonStandard);

            pvalue->m.nonStandardPresent = 1;
            invokeEndElement (pctxt, "nonStandard", -1);

         }
         break;

         case 1:
         /* decode sessionID */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "sessionID", -1);

            stat = decodeConsUInt8 (pctxt, &pvalue->sessionID, 1, 255);

            invokeUIntValue (pctxt, pvalue->sessionID);
            pvalue->m.sessionIDPresent = 1;
            invokeEndElement (pctxt, "sessionID", -1);

         }
         break;

         case 2:
         /* decode mediaChannel */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "mediaChannel", -1);

            stat = asn1PD_H245TransportAddress (pctxt, &pvalue->mediaChannel);

            pvalue->m.mediaChannelPresent = 1;
            invokeEndElement (pctxt, "mediaChannel", -1);

         }
         break;

         case 3:
         /* decode mediaControlChannel */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "mediaControlChannel", -1);

            stat = asn1PD_H245TransportAddress (pctxt, &pvalue->mediaControlChannel);

            pvalue->m.mediaControlChannelPresent = 1;
            invokeEndElement (pctxt, "mediaControlChannel", -1);

         }
         break;

         case 4:
         /* decode dynamicRTPPayloadType */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "dynamicRTPPayloadType", -1);

            stat = decodeConsUInt8 (pctxt, &pvalue->dynamicRTPPayloadType, 96, 127);

            invokeUIntValue (pctxt, pvalue->dynamicRTPPayloadType);
            pvalue->m.dynamicRTPPayloadTypePresent = 1;
            invokeEndElement (pctxt, "dynamicRTPPayloadType", -1);

         }
         break;

         default: j++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return stat;

            if (i < 2) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt,
                  (ASN1OCTET*)openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     if (openType.numocts == 0) break;

                     pvalue->m.flowControlToZeroPresent = 1;

                     invokeStartElement (pctxt, "flowControlToZero", -1);

                     stat = DECODEBIT (pctxt, &pvalue->flowControlToZero);
                     if (stat != 0) return stat;

                     invokeBoolValue (pctxt, pvalue->flowControlToZero);
                     invokeEndElement (pctxt, "flowControlToZero", -1);

                     break;

                  case 1:
                     if (openType.numocts == 0) break;

                     pvalue->m.portNumberPresent = 1;

                     invokeStartElement (pctxt, "portNumber", -1);

                     stat = decodeConsUInt16 (pctxt, &pvalue->portNumber, 0, 65535);
                     if (stat != 0) return stat;

                     invokeUIntValue (pctxt, pvalue->portNumber);
                     invokeEndElement (pctxt, "portNumber", -1);

                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245OpenLogicalChannelAck_forwardMultiplexAckParameters (OOCTXT* pctxt, H245OpenLogicalChannelAck_forwardMultiplexAckParameters* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 0);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* h2250LogicalChannelAckParameters */
         case 0:
            invokeStartElement (pctxt, "h2250LogicalChannelAckParameters", -1);

            pvalue->u.h2250LogicalChannelAckParameters
                = memAllocTypeZ (pctxt,
               H245H2250LogicalChannelAckParameters);

            stat = asn1PD_H245H2250LogicalChannelAckParameters (pctxt, pvalue->u.h2250LogicalChannelAckParameters);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "h2250LogicalChannelAckParameters", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 2;

      if (pvalue->t < 2) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245OpenLogicalChannelAck (OOCTXT* pctxt, H245OpenLogicalChannelAck* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.reverseLogicalChannelParametersPresent = optbit;

   /* decode root elements */
   /* decode forwardLogicalChannelNumber */
   invokeStartElement (pctxt, "forwardLogicalChannelNumber", -1);

   stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->forwardLogicalChannelNumber);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "forwardLogicalChannelNumber", -1);

   /* decode reverseLogicalChannelParameters */
   if (pvalue->m.reverseLogicalChannelParametersPresent) {
      invokeStartElement (pctxt, "reverseLogicalChannelParameters", -1);

      stat = asn1PD_H245OpenLogicalChannelAck_reverseLogicalChannelParameters (pctxt, &pvalue->reverseLogicalChannelParameters);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "reverseLogicalChannelParameters", -1);

   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return stat;

            if (i < 4) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt,
                  (ASN1OCTET*)openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     if (openType.numocts == 0) break;

                     pvalue->m.separateStackPresent = 1;

                     invokeStartElement (pctxt, "separateStack", -1);

                     stat = asn1PD_H245NetworkAccessParameters (pctxt, &pvalue->separateStack);
                     if (stat != 0) return stat;

                     invokeEndElement (pctxt, "separateStack", -1);

                     break;

                  case 1:
                     if (openType.numocts == 0) break;

                     pvalue->m.forwardMultiplexAckParametersPresent = 1;

                     invokeStartElement (pctxt, "forwardMultiplexAckParameters", -1);

                     stat = asn1PD_H245OpenLogicalChannelAck_forwardMultiplexAckParameters (pctxt, &pvalue->forwardMultiplexAckParameters);
                     if (stat != 0) return stat;

                     invokeEndElement (pctxt, "forwardMultiplexAckParameters", -1);

                     break;

                  case 2:
                     if (openType.numocts == 0) break;

                     pvalue->m.encryptionSyncPresent = 1;

                     invokeStartElement (pctxt, "encryptionSync", -1);

                     stat = asn1PD_H245EncryptionSync (pctxt, &pvalue->encryptionSync);
                     if (stat != 0) return stat;

                     invokeEndElement (pctxt, "encryptionSync", -1);

                     break;

                  case 3:
                     if (openType.numocts == 0) break;

                     pvalue->m.genericInformationPresent = 1;

                     invokeStartElement (pctxt, "genericInformation", -1);

                     stat = asn1PD_H245_SeqOfH245GenericInformation (pctxt, &pvalue->genericInformation);
                     if (stat != 0) return stat;

                     invokeEndElement (pctxt, "genericInformation", -1);

                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245OpenLogicalChannelReject_cause (OOCTXT* pctxt, H245OpenLogicalChannelReject_cause* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 5);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* unspecified */
         case 0:
            invokeStartElement (pctxt, "unspecified", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "unspecified", -1);

            break;

         /* unsuitableReverseParameters */
         case 1:
            invokeStartElement (pctxt, "unsuitableReverseParameters", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "unsuitableReverseParameters", -1);

            break;

         /* dataTypeNotSupported */
         case 2:
            invokeStartElement (pctxt, "dataTypeNotSupported", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "dataTypeNotSupported", -1);

            break;

         /* dataTypeNotAvailable */
         case 3:
            invokeStartElement (pctxt, "dataTypeNotAvailable", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "dataTypeNotAvailable", -1);

            break;

         /* unknownDataType */
         case 4:
            invokeStartElement (pctxt, "unknownDataType", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "unknownDataType", -1);

            break;

         /* dataTypeALCombinationNotSupported */
         case 5:
            invokeStartElement (pctxt, "dataTypeALCombinationNotSupported", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "dataTypeALCombinationNotSupported", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 7;

      if (pvalue->t < 7) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt,
         (ASN1OCTET*)openType.data, openType.numocts);

      switch (pvalue->t) {
         /* multicastChannelNotAllowed */
         case 7:
            invokeStartElement (pctxt, "multicastChannelNotAllowed", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "multicastChannelNotAllowed", -1);

            break;

         /* insufficientBandwidth */
         case 8:
            invokeStartElement (pctxt, "insufficientBandwidth", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "insufficientBandwidth", -1);

            break;

         /* separateStackEstablishmentFailed */
         case 9:
            invokeStartElement (pctxt, "separateStackEstablishmentFailed", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "separateStackEstablishmentFailed", -1);

            break;

         /* invalidSessionID */
         case 10:
            invokeStartElement (pctxt, "invalidSessionID", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "invalidSessionID", -1);

            break;

         /* masterSlaveConflict */
         case 11:
            invokeStartElement (pctxt, "masterSlaveConflict", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "masterSlaveConflict", -1);

            break;

         /* waitForCommunicationMode */
         case 12:
            invokeStartElement (pctxt, "waitForCommunicationMode", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "waitForCommunicationMode", -1);

            break;

         /* invalidDependentChannel */
         case 13:
            invokeStartElement (pctxt, "invalidDependentChannel", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "invalidDependentChannel", -1);

            break;

         /* replacementForRejected */
         case 14:
            invokeStartElement (pctxt, "replacementForRejected", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "replacementForRejected", -1);

            break;

         /* securityDenied */
         case 15:
            invokeStartElement (pctxt, "securityDenied", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "securityDenied", -1);

            break;

         default:;
      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

EXTERN int asn1PD_H245OpenLogicalChannelReject (OOCTXT* pctxt, H245OpenLogicalChannelReject* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   /* decode root elements */
   /* decode forwardLogicalChannelNumber */
   invokeStartElement (pctxt, "forwardLogicalChannelNumber", -1);

   stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->forwardLogicalChannelNumber);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "forwardLogicalChannelNumber", -1);

   /* decode cause */
   invokeStartElement (pctxt, "cause", -1);

   stat = asn1PD_H245OpenLogicalChannelReject_cause (pctxt, &pvalue->cause);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "cause", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return stat;

            if (i < 1) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt,
                  (ASN1OCTET*)openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     if (openType.numocts == 0) break;

                     pvalue->m.genericInformationPresent = 1;

                     invokeStartElement (pctxt, "genericInformation", -1);

                     stat = asn1PD_H245_SeqOfH245GenericInformation (pctxt, &pvalue->genericInformation);
                     if (stat != 0) return stat;

                     invokeEndElement (pctxt, "genericInformation", -1);

                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245CloseLogicalChannelAck (OOCTXT* pctxt, H245CloseLogicalChannelAck* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode forwardLogicalChannelNumber */
   invokeStartElement (pctxt, "forwardLogicalChannelNumber", -1);

   stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->forwardLogicalChannelNumber);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "forwardLogicalChannelNumber", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245RequestChannelCloseAck (OOCTXT* pctxt, H245RequestChannelCloseAck* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode forwardLogicalChannelNumber */
   invokeStartElement (pctxt, "forwardLogicalChannelNumber", -1);

   stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->forwardLogicalChannelNumber);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "forwardLogicalChannelNumber", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245RequestChannelCloseReject_cause (OOCTXT* pctxt, H245RequestChannelCloseReject_cause* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 0);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* unspecified */
         case 0:
            invokeStartElement (pctxt, "unspecified", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "unspecified", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 2;

      if (pvalue->t < 2) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245RequestChannelCloseReject (OOCTXT* pctxt, H245RequestChannelCloseReject* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode forwardLogicalChannelNumber */
   invokeStartElement (pctxt, "forwardLogicalChannelNumber", -1);

   stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->forwardLogicalChannelNumber);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "forwardLogicalChannelNumber", -1);

   /* decode cause */
   invokeStartElement (pctxt, "cause", -1);

   stat = asn1PD_H245RequestChannelCloseReject_cause (pctxt, &pvalue->cause);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "cause", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245MultiplexEntrySendAck_multiplexTableEntryNumber (OOCTXT* pctxt, H245MultiplexEntrySendAck_multiplexTableEntryNumber* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 15, 0 };
   int stat = 0;
   OOUINT32 xx1 = 0;

   /* decode length determinant */

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeLength (pctxt, &pvalue->n);
   if (stat != 0) return stat;

   /* decode elements */

   if (15 < pvalue->n) {
      return stat;
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      invokeStartElement (pctxt, "elem", xx1);

      stat = asn1PD_H245MultiplexTableEntryNumber (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "elem", xx1);

   }

   return (stat);
}

EXTERN int asn1PD_H245MultiplexEntrySendAck (OOCTXT* pctxt, H245MultiplexEntrySendAck* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode sequenceNumber */
   invokeStartElement (pctxt, "sequenceNumber", -1);

   stat = asn1PD_H245SequenceNumber (pctxt, &pvalue->sequenceNumber);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "sequenceNumber", -1);

   /* decode multiplexTableEntryNumber */
   invokeStartElement (pctxt, "multiplexTableEntryNumber", -1);

   stat = asn1PD_H245MultiplexEntrySendAck_multiplexTableEntryNumber (pctxt, &pvalue->multiplexTableEntryNumber);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "multiplexTableEntryNumber", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245MultiplexEntryRejectionDescriptions_cause (OOCTXT* pctxt, H245MultiplexEntryRejectionDescriptions_cause* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* unspecifiedCause */
         case 0:
            invokeStartElement (pctxt, "unspecifiedCause", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "unspecifiedCause", -1);

            break;

         /* descriptorTooComplex */
         case 1:
            invokeStartElement (pctxt, "descriptorTooComplex", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "descriptorTooComplex", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245MultiplexEntryRejectionDescriptions (OOCTXT* pctxt, H245MultiplexEntryRejectionDescriptions* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode multiplexTableEntryNumber */
   invokeStartElement (pctxt, "multiplexTableEntryNumber", -1);

   stat = asn1PD_H245MultiplexTableEntryNumber (pctxt, &pvalue->multiplexTableEntryNumber);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "multiplexTableEntryNumber", -1);

   /* decode cause */
   invokeStartElement (pctxt, "cause", -1);

   stat = asn1PD_H245MultiplexEntryRejectionDescriptions_cause (pctxt, &pvalue->cause);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "cause", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245MultiplexEntrySendReject_rejectionDescriptions (OOCTXT* pctxt, H245MultiplexEntrySendReject_rejectionDescriptions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 15, 0 };
   int stat = 0;
   H245MultiplexEntryRejectionDescriptions* pdata;
   DListNode* pnode;
   OOUINT32 count = 0;
   OOUINT32 xx1 = 0;

   /* decode length determinant */

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeLength (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      invokeStartElement (pctxt, "elem", xx1);

      dListAllocNodeAndData (pctxt, H245MultiplexEntryRejectionDescriptions, &pnode, &pdata);

      stat = asn1PD_H245MultiplexEntryRejectionDescriptions (pctxt, pdata);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "elem", xx1);

      dListAppendNode2 (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1PD_H245MultiplexEntrySendReject (OOCTXT* pctxt, H245MultiplexEntrySendReject* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode sequenceNumber */
   invokeStartElement (pctxt, "sequenceNumber", -1);

   stat = asn1PD_H245SequenceNumber (pctxt, &pvalue->sequenceNumber);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "sequenceNumber", -1);

   /* decode rejectionDescriptions */
   invokeStartElement (pctxt, "rejectionDescriptions", -1);

   stat = asn1PD_H245MultiplexEntrySendReject_rejectionDescriptions (pctxt, &pvalue->rejectionDescriptions);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "rejectionDescriptions", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245RequestMultiplexEntryAck_entryNumbers (OOCTXT* pctxt, H245RequestMultiplexEntryAck_entryNumbers* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 15, 0 };
   int stat = 0;
   OOUINT32 xx1 = 0;

   /* decode length determinant */

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeLength (pctxt, &pvalue->n);
   if (stat != 0) return stat;

   /* decode elements */

   if (15 < pvalue->n) {
      return stat;
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      invokeStartElement (pctxt, "elem", xx1);

      stat = asn1PD_H245MultiplexTableEntryNumber (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "elem", xx1);

   }

   return (stat);
}

EXTERN int asn1PD_H245RequestMultiplexEntryAck (OOCTXT* pctxt, H245RequestMultiplexEntryAck* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode entryNumbers */
   invokeStartElement (pctxt, "entryNumbers", -1);

   stat = asn1PD_H245RequestMultiplexEntryAck_entryNumbers (pctxt, &pvalue->entryNumbers);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "entryNumbers", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245RequestMultiplexEntryReject_entryNumbers (OOCTXT* pctxt, H245RequestMultiplexEntryReject_entryNumbers* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 15, 0 };
   int stat = 0;
   OOUINT32 xx1 = 0;

   /* decode length determinant */

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeLength (pctxt, &pvalue->n);
   if (stat != 0) return stat;

   /* decode elements */

   if (15 < pvalue->n) {
      return stat;
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      invokeStartElement (pctxt, "elem", xx1);

      stat = asn1PD_H245MultiplexTableEntryNumber (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "elem", xx1);

   }

   return (stat);
}

EXTERN int asn1PD_H245RequestMultiplexEntryRejectionDescriptions_cause (OOCTXT* pctxt, H245RequestMultiplexEntryRejectionDescriptions_cause* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 0);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* unspecifiedCause */
         case 0:
            invokeStartElement (pctxt, "unspecifiedCause", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "unspecifiedCause", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 2;

      if (pvalue->t < 2) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245RequestMultiplexEntryRejectionDescriptions (OOCTXT* pctxt, H245RequestMultiplexEntryRejectionDescriptions* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode multiplexTableEntryNumber */
   invokeStartElement (pctxt, "multiplexTableEntryNumber", -1);

   stat = asn1PD_H245MultiplexTableEntryNumber (pctxt, &pvalue->multiplexTableEntryNumber);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "multiplexTableEntryNumber", -1);

   /* decode cause */
   invokeStartElement (pctxt, "cause", -1);

   stat = asn1PD_H245RequestMultiplexEntryRejectionDescriptions_cause (pctxt, &pvalue->cause);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "cause", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245RequestMultiplexEntryReject_rejectionDescriptions (OOCTXT* pctxt, H245RequestMultiplexEntryReject_rejectionDescriptions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 15, 0 };
   int stat = 0;
   H245RequestMultiplexEntryRejectionDescriptions* pdata;
   DListNode* pnode;
   OOUINT32 count = 0;
   OOUINT32 xx1 = 0;

   /* decode length determinant */

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeLength (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      invokeStartElement (pctxt, "elem", xx1);

      dListAllocNodeAndData (pctxt, H245RequestMultiplexEntryRejectionDescriptions, &pnode, &pdata);

      stat = asn1PD_H245RequestMultiplexEntryRejectionDescriptions (pctxt, pdata);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "elem", xx1);

      dListAppendNode2 (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1PD_H245RequestMultiplexEntryReject (OOCTXT* pctxt, H245RequestMultiplexEntryReject* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode entryNumbers */
   invokeStartElement (pctxt, "entryNumbers", -1);

   stat = asn1PD_H245RequestMultiplexEntryReject_entryNumbers (pctxt, &pvalue->entryNumbers);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "entryNumbers", -1);

   /* decode rejectionDescriptions */
   invokeStartElement (pctxt, "rejectionDescriptions", -1);

   stat = asn1PD_H245RequestMultiplexEntryReject_rejectionDescriptions (pctxt, &pvalue->rejectionDescriptions);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "rejectionDescriptions", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245RequestModeAck_response (OOCTXT* pctxt, H245RequestModeAck_response* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* willTransmitMostPreferredMode */
         case 0:
            invokeStartElement (pctxt, "willTransmitMostPreferredMode", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "willTransmitMostPreferredMode", -1);

            break;

         /* willTransmitLessPreferredMode */
         case 1:
            invokeStartElement (pctxt, "willTransmitLessPreferredMode", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "willTransmitLessPreferredMode", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245RequestModeAck (OOCTXT* pctxt, H245RequestModeAck* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode sequenceNumber */
   invokeStartElement (pctxt, "sequenceNumber", -1);

   stat = asn1PD_H245SequenceNumber (pctxt, &pvalue->sequenceNumber);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "sequenceNumber", -1);

   /* decode response */
   invokeStartElement (pctxt, "response", -1);

   stat = asn1PD_H245RequestModeAck_response (pctxt, &pvalue->response);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "response", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245RequestModeReject_cause (OOCTXT* pctxt, H245RequestModeReject_cause* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* modeUnavailable */
         case 0:
            invokeStartElement (pctxt, "modeUnavailable", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "modeUnavailable", -1);

            break;

         /* multipointConstraint */
         case 1:
            invokeStartElement (pctxt, "multipointConstraint", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "multipointConstraint", -1);

            break;

         /* requestDenied */
         case 2:
            invokeStartElement (pctxt, "requestDenied", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "requestDenied", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 4;

      if (pvalue->t < 4) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245RequestModeReject (OOCTXT* pctxt, H245RequestModeReject* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode sequenceNumber */
   invokeStartElement (pctxt, "sequenceNumber", -1);

   stat = asn1PD_H245SequenceNumber (pctxt, &pvalue->sequenceNumber);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "sequenceNumber", -1);

   /* decode cause */
   invokeStartElement (pctxt, "cause", -1);

   stat = asn1PD_H245RequestModeReject_cause (pctxt, &pvalue->cause);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "cause", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245RoundTripDelayResponse (OOCTXT* pctxt, H245RoundTripDelayResponse* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode sequenceNumber */
   invokeStartElement (pctxt, "sequenceNumber", -1);

   stat = asn1PD_H245SequenceNumber (pctxt, &pvalue->sequenceNumber);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "sequenceNumber", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245MaintenanceLoopAck_type (OOCTXT* pctxt, H245MaintenanceLoopAck_type* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* systemLoop */
         case 0:
            invokeStartElement (pctxt, "systemLoop", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "systemLoop", -1);

            break;

         /* mediaLoop */
         case 1:
            invokeStartElement (pctxt, "mediaLoop", -1);

            stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->u.mediaLoop);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "mediaLoop", -1);

            break;

         /* logicalChannelLoop */
         case 2:
            invokeStartElement (pctxt, "logicalChannelLoop", -1);

            stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->u.logicalChannelLoop);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "logicalChannelLoop", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 4;

      if (pvalue->t < 4) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245MaintenanceLoopAck (OOCTXT* pctxt, H245MaintenanceLoopAck* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode type */
   invokeStartElement (pctxt, "type", -1);

   stat = asn1PD_H245MaintenanceLoopAck_type (pctxt, &pvalue->type);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "type", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245MaintenanceLoopReject_type (OOCTXT* pctxt, H245MaintenanceLoopReject_type* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* systemLoop */
         case 0:
            invokeStartElement (pctxt, "systemLoop", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "systemLoop", -1);

            break;

         /* mediaLoop */
         case 1:
            invokeStartElement (pctxt, "mediaLoop", -1);

            stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->u.mediaLoop);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "mediaLoop", -1);

            break;

         /* logicalChannelLoop */
         case 2:
            invokeStartElement (pctxt, "logicalChannelLoop", -1);

            stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->u.logicalChannelLoop);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "logicalChannelLoop", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 4;

      if (pvalue->t < 4) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245MaintenanceLoopReject_cause (OOCTXT* pctxt, H245MaintenanceLoopReject_cause* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 0);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* canNotPerformLoop */
         case 0:
            invokeStartElement (pctxt, "canNotPerformLoop", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "canNotPerformLoop", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 2;

      if (pvalue->t < 2) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245MaintenanceLoopReject (OOCTXT* pctxt, H245MaintenanceLoopReject* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode type */
   invokeStartElement (pctxt, "type", -1);

   stat = asn1PD_H245MaintenanceLoopReject_type (pctxt, &pvalue->type);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "type", -1);

   /* decode cause */
   invokeStartElement (pctxt, "cause", -1);

   stat = asn1PD_H245MaintenanceLoopReject_cause (pctxt, &pvalue->cause);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "cause", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245CommunicationModeTableEntry_dataType (OOCTXT* pctxt, H245CommunicationModeTableEntry_dataType* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* videoData */
         case 0:
            invokeStartElement (pctxt, "videoData", -1);

            pvalue->u.videoData = memAllocTypeZ (pctxt,
               H245VideoCapability);

            stat = asn1PD_H245VideoCapability (pctxt, pvalue->u.videoData);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "videoData", -1);

            break;

         /* audioData */
         case 1:
            invokeStartElement (pctxt, "audioData", -1);

            pvalue->u.audioData = memAllocTypeZ (pctxt,
               H245AudioCapability);

            stat = asn1PD_H245AudioCapability (pctxt, pvalue->u.audioData);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "audioData", -1);

            break;

         /* data */
         case 2:
            invokeStartElement (pctxt, "data", -1);

            pvalue->u.data = memAllocTypeZ (pctxt,
               H245DataApplicationCapability);

            stat = asn1PD_H245DataApplicationCapability (pctxt, pvalue->u.data);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "data", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 4;

      if (pvalue->t < 4) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245CommunicationModeTableEntry (OOCTXT* pctxt, H245CommunicationModeTableEntry* pvalue)
{
   static Asn1SizeCnst sessionDescription_lsize1 = { 0, 1, 128, 0 };
   int stat = 0;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;
   OOUINT32 j = 0;
   OOBOOL optbits[7];

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   for (i = 0; i < 7; i++) {
      stat = DECODEBIT (pctxt, &optbits[i]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i = 0; i < 10; i++) {
      switch (i) {
         case 0:
         /* decode nonStandard */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "nonStandard", -1);

            stat = asn1PD_H245_SeqOfH245NonStandardParameter (pctxt, &pvalue->nonStandard);

            pvalue->m.nonStandardPresent = 1;
            invokeEndElement (pctxt, "nonStandard", -1);

         }
         break;

         case 1:
         /* decode sessionID */
         invokeStartElement (pctxt, "sessionID", -1);

         stat = decodeConsUInt8 (pctxt, &pvalue->sessionID, 1, 255);

         invokeUIntValue (pctxt, pvalue->sessionID);
         invokeEndElement (pctxt, "sessionID", -1);

         break;

         case 2:
         /* decode associatedSessionID */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "associatedSessionID", -1);

            stat = decodeConsUInt8 (pctxt, &pvalue->associatedSessionID, 1, 255);

            invokeUIntValue (pctxt, pvalue->associatedSessionID);
            pvalue->m.associatedSessionIDPresent = 1;
            invokeEndElement (pctxt, "associatedSessionID", -1);

         }
         break;

         case 3:
         /* decode terminalLabel */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "terminalLabel", -1);

            stat = asn1PD_H245TerminalLabel (pctxt, &pvalue->terminalLabel);

            pvalue->m.terminalLabelPresent = 1;
            invokeEndElement (pctxt, "terminalLabel", -1);

         }
         break;

         case 4:
         /* decode sessionDescription */
         invokeStartElement (pctxt, "sessionDescription", -1);

         addSizeConstraint (pctxt, &sessionDescription_lsize1);

         stat = decodeBMPString (pctxt, &pvalue->sessionDescription, 0);

         invokeCharStr16BitValue (pctxt, pvalue->sessionDescription.nchars, pvalue->sessionDescription.data);
         invokeEndElement (pctxt, "sessionDescription", -1);

         break;

         case 5:
         /* decode dataType */
         invokeStartElement (pctxt, "dataType", -1);

         stat = asn1PD_H245CommunicationModeTableEntry_dataType (pctxt, &pvalue->dataType);

         invokeEndElement (pctxt, "dataType", -1);

         break;

         case 6:
         /* decode mediaChannel */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "mediaChannel", -1);

            stat = asn1PD_H245TransportAddress (pctxt, &pvalue->mediaChannel);

            pvalue->m.mediaChannelPresent = 1;
            invokeEndElement (pctxt, "mediaChannel", -1);

         }
         break;

         case 7:
         /* decode mediaGuaranteedDelivery */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "mediaGuaranteedDelivery", -1);

            stat = DECODEBIT (pctxt, &pvalue->mediaGuaranteedDelivery);

            invokeBoolValue (pctxt, pvalue->mediaGuaranteedDelivery);
            pvalue->m.mediaGuaranteedDeliveryPresent = 1;
            invokeEndElement (pctxt, "mediaGuaranteedDelivery", -1);

         }
         break;

         case 8:
         /* decode mediaControlChannel */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "mediaControlChannel", -1);

            stat = asn1PD_H245TransportAddress (pctxt, &pvalue->mediaControlChannel);

            pvalue->m.mediaControlChannelPresent = 1;
            invokeEndElement (pctxt, "mediaControlChannel", -1);

         }
         break;

         case 9:
         /* decode mediaControlGuaranteedDelivery */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "mediaControlGuaranteedDelivery", -1);

            stat = DECODEBIT (pctxt, &pvalue->mediaControlGuaranteedDelivery);

            invokeBoolValue (pctxt, pvalue->mediaControlGuaranteedDelivery);
            pvalue->m.mediaControlGuaranteedDeliveryPresent = 1;
            invokeEndElement (pctxt, "mediaControlGuaranteedDelivery", -1);

         }
         break;

         default: j++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return stat;

            if (i < 3) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt,
                  (ASN1OCTET*)openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     if (openType.numocts == 0) break;

                     pvalue->m.redundancyEncodingPresent = 1;

                     invokeStartElement (pctxt, "redundancyEncoding", -1);

                     stat = asn1PD_H245RedundancyEncoding (pctxt, &pvalue->redundancyEncoding);
                     if (stat != 0) return stat;

                     invokeEndElement (pctxt, "redundancyEncoding", -1);

                     break;

                  case 1:
                     if (openType.numocts == 0) break;

                     pvalue->m.sessionDependencyPresent = 1;

                     invokeStartElement (pctxt, "sessionDependency", -1);

                     stat = decodeConsUInt8 (pctxt, &pvalue->sessionDependency, 1, 255);
                     if (stat != 0) return stat;

                     invokeUIntValue (pctxt, pvalue->sessionDependency);
                     invokeEndElement (pctxt, "sessionDependency", -1);

                     break;

                  case 2:
                     if (openType.numocts == 0) break;

                     pvalue->m.destinationPresent = 1;

                     invokeStartElement (pctxt, "destination", -1);

                     stat = asn1PD_H245TerminalLabel (pctxt, &pvalue->destination);
                     if (stat != 0) return stat;

                     invokeEndElement (pctxt, "destination", -1);

                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245CommunicationModeResponse_communicationModeTable (OOCTXT* pctxt, H245CommunicationModeResponse_communicationModeTable* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 256, 0 };
   int stat = 0;
   H245CommunicationModeTableEntry* pdata;
   DListNode* pnode;
   OOUINT32 count = 0;
   OOUINT32 xx1 = 0;

   /* decode length determinant */

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeLength (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      invokeStartElement (pctxt, "elem", xx1);

      dListAllocNodeAndData (pctxt, H245CommunicationModeTableEntry, &pnode, &pdata);

      stat = asn1PD_H245CommunicationModeTableEntry (pctxt, pdata);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "elem", xx1);

      dListAppendNode2 (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1PD_H245CommunicationModeResponse (OOCTXT* pctxt, H245CommunicationModeResponse* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 0);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* communicationModeTable */
         case 0:
            invokeStartElement (pctxt, "communicationModeTable", -1);

            pvalue->u.communicationModeTable = memAllocTypeZ (pctxt,
               H245CommunicationModeResponse_communicationModeTable);

            stat = asn1PD_H245CommunicationModeResponse_communicationModeTable (pctxt, pvalue->u.communicationModeTable);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "communicationModeTable", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 2;

      if (pvalue->t < 2) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245ConferenceResponse_mCTerminalIDResponse (OOCTXT* pctxt, H245ConferenceResponse_mCTerminalIDResponse* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode terminalLabel */
   invokeStartElement (pctxt, "terminalLabel", -1);

   stat = asn1PD_H245TerminalLabel (pctxt, &pvalue->terminalLabel);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "terminalLabel", -1);

   /* decode terminalID */
   invokeStartElement (pctxt, "terminalID", -1);

   stat = asn1PD_H245TerminalID (pctxt, &pvalue->terminalID);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "terminalID", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245ConferenceResponse_terminalIDResponse (OOCTXT* pctxt, H245ConferenceResponse_terminalIDResponse* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode terminalLabel */
   invokeStartElement (pctxt, "terminalLabel", -1);

   stat = asn1PD_H245TerminalLabel (pctxt, &pvalue->terminalLabel);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "terminalLabel", -1);

   /* decode terminalID */
   invokeStartElement (pctxt, "terminalID", -1);

   stat = asn1PD_H245TerminalID (pctxt, &pvalue->terminalID);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "terminalID", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245ConferenceResponse_conferenceIDResponse (OOCTXT* pctxt, H245ConferenceResponse_conferenceIDResponse* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode terminalLabel */
   invokeStartElement (pctxt, "terminalLabel", -1);

   stat = asn1PD_H245TerminalLabel (pctxt, &pvalue->terminalLabel);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "terminalLabel", -1);

   /* decode conferenceID */
   invokeStartElement (pctxt, "conferenceID", -1);

   stat = asn1PD_H245ConferenceID (pctxt, &pvalue->conferenceID);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "conferenceID", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245ConferenceResponse_passwordResponse (OOCTXT* pctxt, H245ConferenceResponse_passwordResponse* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode terminalLabel */
   invokeStartElement (pctxt, "terminalLabel", -1);

   stat = asn1PD_H245TerminalLabel (pctxt, &pvalue->terminalLabel);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "terminalLabel", -1);

   /* decode password */
   invokeStartElement (pctxt, "password", -1);

   stat = asn1PD_H245Password (pctxt, &pvalue->password);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "password", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245ConferenceResponse_terminalListResponse (OOCTXT* pctxt, H245ConferenceResponse_terminalListResponse* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 256, 0 };
   int stat = 0;
   H245TerminalLabel* pdata;
   DListNode* pnode;
   OOUINT32 count = 0;
   OOUINT32 xx1 = 0;

   /* decode length determinant */

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeLength (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      invokeStartElement (pctxt, "elem", xx1);

      dListAllocNodeAndData (pctxt, H245TerminalLabel, &pnode, &pdata);

      stat = asn1PD_H245TerminalLabel (pctxt, pdata);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "elem", xx1);

      dListAppendNode2 (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1PD_H245ConferenceResponse_makeMeChairResponse (OOCTXT* pctxt, H245ConferenceResponse_makeMeChairResponse* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* grantedChairToken */
         case 0:
            invokeStartElement (pctxt, "grantedChairToken", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "grantedChairToken", -1);

            break;

         /* deniedChairToken */
         case 1:
            invokeStartElement (pctxt, "deniedChairToken", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "deniedChairToken", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245ConferenceResponse_extensionAddressResponse (OOCTXT* pctxt, H245ConferenceResponse_extensionAddressResponse* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode extensionAddress */
   invokeStartElement (pctxt, "extensionAddress", -1);

   stat = asn1PD_H245TerminalID (pctxt, &pvalue->extensionAddress);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "extensionAddress", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245ConferenceResponse_chairTokenOwnerResponse (OOCTXT* pctxt, H245ConferenceResponse_chairTokenOwnerResponse* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode terminalLabel */
   invokeStartElement (pctxt, "terminalLabel", -1);

   stat = asn1PD_H245TerminalLabel (pctxt, &pvalue->terminalLabel);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "terminalLabel", -1);

   /* decode terminalID */
   invokeStartElement (pctxt, "terminalID", -1);

   stat = asn1PD_H245TerminalID (pctxt, &pvalue->terminalID);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "terminalID", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245ConferenceResponse_terminalCertificateResponse (OOCTXT* pctxt, H245ConferenceResponse_terminalCertificateResponse* pvalue)
{
   static Asn1SizeCnst certificateResponse_lsize1 = { 0, 1, 65535, 0 };
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.terminalLabelPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.certificateResponsePresent = optbit;

   /* decode root elements */
   /* decode terminalLabel */
   if (pvalue->m.terminalLabelPresent) {
      invokeStartElement (pctxt, "terminalLabel", -1);

      stat = asn1PD_H245TerminalLabel (pctxt, &pvalue->terminalLabel);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "terminalLabel", -1);

   }

   /* decode certificateResponse */
   if (pvalue->m.certificateResponsePresent) {
      invokeStartElement (pctxt, "certificateResponse", -1);

      addSizeConstraint (pctxt, &certificateResponse_lsize1);

      stat = decodeDynOctetString (pctxt, (ASN1DynOctStr*)&pvalue->certificateResponse);
      if (stat != 0) return stat;

      invokeOctStrValue (pctxt, pvalue->certificateResponse.numocts, pvalue->certificateResponse.data);
      invokeEndElement (pctxt, "certificateResponse", -1);

   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245ConferenceResponse_broadcastMyLogicalChannelResponse (OOCTXT* pctxt, H245ConferenceResponse_broadcastMyLogicalChannelResponse* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* grantedBroadcastMyLogicalChannel */
         case 0:
            invokeStartElement (pctxt, "grantedBroadcastMyLogicalChannel", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "grantedBroadcastMyLogicalChannel", -1);

            break;

         /* deniedBroadcastMyLogicalChannel */
         case 1:
            invokeStartElement (pctxt, "deniedBroadcastMyLogicalChannel", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "deniedBroadcastMyLogicalChannel", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245ConferenceResponse_makeTerminalBroadcasterResponse (OOCTXT* pctxt, H245ConferenceResponse_makeTerminalBroadcasterResponse* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* grantedMakeTerminalBroadcaster */
         case 0:
            invokeStartElement (pctxt, "grantedMakeTerminalBroadcaster", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "grantedMakeTerminalBroadcaster", -1);

            break;

         /* deniedMakeTerminalBroadcaster */
         case 1:
            invokeStartElement (pctxt, "deniedMakeTerminalBroadcaster", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "deniedMakeTerminalBroadcaster", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245ConferenceResponse_sendThisSourceResponse (OOCTXT* pctxt, H245ConferenceResponse_sendThisSourceResponse* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* grantedSendThisSource */
         case 0:
            invokeStartElement (pctxt, "grantedSendThisSource", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "grantedSendThisSource", -1);

            break;

         /* deniedSendThisSource */
         case 1:
            invokeStartElement (pctxt, "deniedSendThisSource", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "deniedSendThisSource", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245TerminalInformation (OOCTXT* pctxt, H245TerminalInformation* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode terminalLabel */
   invokeStartElement (pctxt, "terminalLabel", -1);

   stat = asn1PD_H245TerminalLabel (pctxt, &pvalue->terminalLabel);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "terminalLabel", -1);

   /* decode terminalID */
   invokeStartElement (pctxt, "terminalID", -1);

   stat = asn1PD_H245TerminalID (pctxt, &pvalue->terminalID);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "terminalID", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245_SeqOfH245TerminalInformation (OOCTXT* pctxt, H245_SeqOfH245TerminalInformation* pvalue)
{
   int stat = 0;
   H245TerminalInformation* pdata;
   DListNode* pnode;
   OOUINT32 count = 0;
   OOUINT32 xx1 = 0;
   int lstat;
   OOUINT32 total = 0;

   dListInit (pvalue);

   for (;;) {
      /* decode length determinant */

      lstat = decodeLength (pctxt, &count);
      if (lstat != 0 && lstat != ASN_OK_FRAG) {
         return lstat;
      }
      else if (count == 0) break;
      total += count;

      /* decode elements */

      for (; xx1 < total; xx1++) {
         invokeStartElement (pctxt, "elem", xx1);

         dListAllocNodeAndData (pctxt, H245TerminalInformation, &pnode, &pdata);

         stat = asn1PD_H245TerminalInformation (pctxt, pdata);
         if (stat != 0) return stat;

         invokeEndElement (pctxt, "elem", xx1);

         dListAppendNode2 (pvalue, pnode);
      }

      if (lstat == 0) break;
   }

   return (stat);
}

EXTERN int asn1PD_H245RequestAllTerminalIDsResponse (OOCTXT* pctxt, H245RequestAllTerminalIDsResponse* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode terminalInformation */
   invokeStartElement (pctxt, "terminalInformation", -1);

   stat = asn1PD_H245_SeqOfH245TerminalInformation (pctxt, &pvalue->terminalInformation);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "terminalInformation", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245RemoteMCResponse_reject (OOCTXT* pctxt, H245RemoteMCResponse_reject* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* unspecified */
         case 0:
            invokeStartElement (pctxt, "unspecified", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "unspecified", -1);

            break;

         /* functionNotSupported */
         case 1:
            invokeStartElement (pctxt, "functionNotSupported", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "functionNotSupported", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245RemoteMCResponse (OOCTXT* pctxt, H245RemoteMCResponse* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* accept */
         case 0:
            invokeStartElement (pctxt, "accept", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "accept", -1);

            break;

         /* reject */
         case 1:
            invokeStartElement (pctxt, "reject", -1);

            pvalue->u.reject = memAllocTypeZ (pctxt,
               H245RemoteMCResponse_reject);

            stat = asn1PD_H245RemoteMCResponse_reject (pctxt, pvalue->u.reject);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "reject", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245ConferenceResponse (OOCTXT* pctxt, H245ConferenceResponse* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 7);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* mCTerminalIDResponse */
         case 0:
            invokeStartElement (pctxt, "mCTerminalIDResponse", -1);

            pvalue->u.mCTerminalIDResponse = memAllocTypeZ (pctxt,
               H245ConferenceResponse_mCTerminalIDResponse);

            stat = asn1PD_H245ConferenceResponse_mCTerminalIDResponse (pctxt, pvalue->u.mCTerminalIDResponse);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "mCTerminalIDResponse", -1);

            break;

         /* terminalIDResponse */
         case 1:
            invokeStartElement (pctxt, "terminalIDResponse", -1);

            pvalue->u.terminalIDResponse = memAllocTypeZ (pctxt,
               H245ConferenceResponse_terminalIDResponse);

            stat = asn1PD_H245ConferenceResponse_terminalIDResponse (pctxt, pvalue->u.terminalIDResponse);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "terminalIDResponse", -1);

            break;

         /* conferenceIDResponse */
         case 2:
            invokeStartElement (pctxt, "conferenceIDResponse", -1);

            pvalue->u.conferenceIDResponse = memAllocTypeZ (pctxt,
               H245ConferenceResponse_conferenceIDResponse);

            stat = asn1PD_H245ConferenceResponse_conferenceIDResponse (pctxt, pvalue->u.conferenceIDResponse);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "conferenceIDResponse", -1);

            break;

         /* passwordResponse */
         case 3:
            invokeStartElement (pctxt, "passwordResponse", -1);

            pvalue->u.passwordResponse = memAllocTypeZ (pctxt,
               H245ConferenceResponse_passwordResponse);

            stat = asn1PD_H245ConferenceResponse_passwordResponse (pctxt, pvalue->u.passwordResponse);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "passwordResponse", -1);

            break;

         /* terminalListResponse */
         case 4:
            invokeStartElement (pctxt, "terminalListResponse", -1);

            pvalue->u.terminalListResponse = memAllocTypeZ (pctxt,
               H245ConferenceResponse_terminalListResponse);

            stat = asn1PD_H245ConferenceResponse_terminalListResponse (pctxt, pvalue->u.terminalListResponse);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "terminalListResponse", -1);

            break;

         /* videoCommandReject */
         case 5:
            invokeStartElement (pctxt, "videoCommandReject", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "videoCommandReject", -1);

            break;

         /* terminalDropReject */
         case 6:
            invokeStartElement (pctxt, "terminalDropReject", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "terminalDropReject", -1);

            break;

         /* makeMeChairResponse */
         case 7:
            invokeStartElement (pctxt, "makeMeChairResponse", -1);

            pvalue->u.makeMeChairResponse = memAllocTypeZ (pctxt,
               H245ConferenceResponse_makeMeChairResponse);

            stat = asn1PD_H245ConferenceResponse_makeMeChairResponse (pctxt, pvalue->u.makeMeChairResponse);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "makeMeChairResponse", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 9;

      if (pvalue->t < 9) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt,
         (ASN1OCTET*)openType.data, openType.numocts);

      switch (pvalue->t) {
         /* extensionAddressResponse */
         case 9:
            invokeStartElement (pctxt, "extensionAddressResponse", -1);

            pvalue->u.extensionAddressResponse = memAllocTypeZ (pctxt,
               H245ConferenceResponse_extensionAddressResponse);

            stat = asn1PD_H245ConferenceResponse_extensionAddressResponse (pctxt, pvalue->u.extensionAddressResponse);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "extensionAddressResponse", -1);

            break;

         /* chairTokenOwnerResponse */
         case 10:
            invokeStartElement (pctxt, "chairTokenOwnerResponse", -1);

            pvalue->u.chairTokenOwnerResponse = memAllocTypeZ (pctxt,
               H245ConferenceResponse_chairTokenOwnerResponse);

            stat = asn1PD_H245ConferenceResponse_chairTokenOwnerResponse (pctxt, pvalue->u.chairTokenOwnerResponse);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "chairTokenOwnerResponse", -1);

            break;

         /* terminalCertificateResponse */
         case 11:
            invokeStartElement (pctxt, "terminalCertificateResponse", -1);

            pvalue->u.terminalCertificateResponse = memAllocTypeZ (pctxt,
               H245ConferenceResponse_terminalCertificateResponse);

            stat = asn1PD_H245ConferenceResponse_terminalCertificateResponse (pctxt, pvalue->u.terminalCertificateResponse);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "terminalCertificateResponse", -1);

            break;

         /* broadcastMyLogicalChannelResponse */
         case 12:
            invokeStartElement (pctxt, "broadcastMyLogicalChannelResponse", -1);

            pvalue->u.broadcastMyLogicalChannelResponse
                = memAllocTypeZ (pctxt,
               H245ConferenceResponse_broadcastMyLogicalChannelResponse);

            stat = asn1PD_H245ConferenceResponse_broadcastMyLogicalChannelResponse (pctxt, pvalue->u.broadcastMyLogicalChannelResponse);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "broadcastMyLogicalChannelResponse", -1);

            break;

         /* makeTerminalBroadcasterResponse */
         case 13:
            invokeStartElement (pctxt, "makeTerminalBroadcasterResponse", -1);

            pvalue->u.makeTerminalBroadcasterResponse
                = memAllocTypeZ (pctxt,
               H245ConferenceResponse_makeTerminalBroadcasterResponse);

            stat = asn1PD_H245ConferenceResponse_makeTerminalBroadcasterResponse (pctxt, pvalue->u.makeTerminalBroadcasterResponse);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "makeTerminalBroadcasterResponse", -1);

            break;

         /* sendThisSourceResponse */
         case 14:
            invokeStartElement (pctxt, "sendThisSourceResponse", -1);

            pvalue->u.sendThisSourceResponse = memAllocTypeZ (pctxt,
               H245ConferenceResponse_sendThisSourceResponse);

            stat = asn1PD_H245ConferenceResponse_sendThisSourceResponse (pctxt, pvalue->u.sendThisSourceResponse);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "sendThisSourceResponse", -1);

            break;

         /* requestAllTerminalIDsResponse */
         case 15:
            invokeStartElement (pctxt, "requestAllTerminalIDsResponse", -1);

            pvalue->u.requestAllTerminalIDsResponse = memAllocTypeZ (pctxt,
               H245RequestAllTerminalIDsResponse);

            stat = asn1PD_H245RequestAllTerminalIDsResponse (pctxt, pvalue->u.requestAllTerminalIDsResponse);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "requestAllTerminalIDsResponse", -1);

            break;

         /* remoteMCResponse */
         case 16:
            invokeStartElement (pctxt, "remoteMCResponse", -1);

            pvalue->u.remoteMCResponse = memAllocTypeZ (pctxt,
               H245RemoteMCResponse);

            stat = asn1PD_H245RemoteMCResponse (pctxt, pvalue->u.remoteMCResponse);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "remoteMCResponse", -1);

            break;

         default:;
      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

EXTERN int asn1PD_H245MultilinkResponse_callInformation (OOCTXT* pctxt, H245MultilinkResponse_callInformation* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode dialingInformation */
   invokeStartElement (pctxt, "dialingInformation", -1);

   stat = asn1PD_H245DialingInformation (pctxt, &pvalue->dialingInformation);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "dialingInformation", -1);

   /* decode callAssociationNumber */
   invokeStartElement (pctxt, "callAssociationNumber", -1);

   stat = decodeConsUnsigned (pctxt, &pvalue->callAssociationNumber, 0, OOUINT32_MAX);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->callAssociationNumber);
   invokeEndElement (pctxt, "callAssociationNumber", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245MultilinkResponse_addConnection_responseCode_rejected (OOCTXT* pctxt, H245MultilinkResponse_addConnection_responseCode_rejected* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* connectionsNotAvailable */
         case 0:
            invokeStartElement (pctxt, "connectionsNotAvailable", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "connectionsNotAvailable", -1);

            break;

         /* userRejected */
         case 1:
            invokeStartElement (pctxt, "userRejected", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "userRejected", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245MultilinkResponse_addConnection_responseCode (OOCTXT* pctxt, H245MultilinkResponse_addConnection_responseCode* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* accepted */
         case 0:
            invokeStartElement (pctxt, "accepted", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "accepted", -1);

            break;

         /* rejected */
         case 1:
            invokeStartElement (pctxt, "rejected", -1);

            pvalue->u.rejected = memAllocTypeZ (pctxt,
               H245MultilinkResponse_addConnection_responseCode_rejected);

            stat = asn1PD_H245MultilinkResponse_addConnection_responseCode_rejected (pctxt, pvalue->u.rejected);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "rejected", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245MultilinkResponse_addConnection (OOCTXT* pctxt, H245MultilinkResponse_addConnection* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode sequenceNumber */
   invokeStartElement (pctxt, "sequenceNumber", -1);

   stat = asn1PD_H245SequenceNumber (pctxt, &pvalue->sequenceNumber);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "sequenceNumber", -1);

   /* decode responseCode */
   invokeStartElement (pctxt, "responseCode", -1);

   stat = asn1PD_H245MultilinkResponse_addConnection_responseCode (pctxt, &pvalue->responseCode);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "responseCode", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245MultilinkResponse_removeConnection (OOCTXT* pctxt, H245MultilinkResponse_removeConnection* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode connectionIdentifier */
   invokeStartElement (pctxt, "connectionIdentifier", -1);

   stat = asn1PD_H245ConnectionIdentifier (pctxt, &pvalue->connectionIdentifier);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "connectionIdentifier", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245MultilinkResponse_maximumHeaderInterval (OOCTXT* pctxt, H245MultilinkResponse_maximumHeaderInterval* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode currentInterval */
   invokeStartElement (pctxt, "currentInterval", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->currentInterval, 0, 65535);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->currentInterval);
   invokeEndElement (pctxt, "currentInterval", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245MultilinkResponse (OOCTXT* pctxt, H245MultilinkResponse* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 4);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            invokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = memAllocTypeZ (pctxt,
               H245NonStandardMessage);

            stat = asn1PD_H245NonStandardMessage (pctxt, pvalue->u.nonStandard);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* callInformation */
         case 1:
            invokeStartElement (pctxt, "callInformation", -1);

            pvalue->u.callInformation = memAllocTypeZ (pctxt,
               H245MultilinkResponse_callInformation);

            stat = asn1PD_H245MultilinkResponse_callInformation (pctxt, pvalue->u.callInformation);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "callInformation", -1);

            break;

         /* addConnection */
         case 2:
            invokeStartElement (pctxt, "addConnection", -1);

            pvalue->u.addConnection = memAllocTypeZ (pctxt,
               H245MultilinkResponse_addConnection);

            stat = asn1PD_H245MultilinkResponse_addConnection (pctxt, pvalue->u.addConnection);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "addConnection", -1);

            break;

         /* removeConnection */
         case 3:
            invokeStartElement (pctxt, "removeConnection", -1);

            pvalue->u.removeConnection = memAllocTypeZ (pctxt,
               H245MultilinkResponse_removeConnection);

            stat = asn1PD_H245MultilinkResponse_removeConnection (pctxt, pvalue->u.removeConnection);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "removeConnection", -1);

            break;

         /* maximumHeaderInterval */
         case 4:
            invokeStartElement (pctxt, "maximumHeaderInterval", -1);

            pvalue->u.maximumHeaderInterval = memAllocTypeZ (pctxt,
               H245MultilinkResponse_maximumHeaderInterval);

            stat = asn1PD_H245MultilinkResponse_maximumHeaderInterval (pctxt, pvalue->u.maximumHeaderInterval);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "maximumHeaderInterval", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 6;

      if (pvalue->t < 6) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245LogicalChannelRateAcknowledge (OOCTXT* pctxt, H245LogicalChannelRateAcknowledge* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode sequenceNumber */
   invokeStartElement (pctxt, "sequenceNumber", -1);

   stat = asn1PD_H245SequenceNumber (pctxt, &pvalue->sequenceNumber);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "sequenceNumber", -1);

   /* decode logicalChannelNumber */
   invokeStartElement (pctxt, "logicalChannelNumber", -1);

   stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->logicalChannelNumber);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "logicalChannelNumber", -1);

   /* decode maximumBitRate */
   invokeStartElement (pctxt, "maximumBitRate", -1);

   stat = asn1PD_H245MaximumBitRate (pctxt, &pvalue->maximumBitRate);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "maximumBitRate", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245LogicalChannelRateRejectReason (OOCTXT* pctxt, H245LogicalChannelRateRejectReason* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* undefinedReason */
         case 0:
            invokeStartElement (pctxt, "undefinedReason", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "undefinedReason", -1);

            break;

         /* insufficientResources */
         case 1:
            invokeStartElement (pctxt, "insufficientResources", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "insufficientResources", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245LogicalChannelRateReject (OOCTXT* pctxt, H245LogicalChannelRateReject* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.currentMaximumBitRatePresent = optbit;

   /* decode root elements */
   /* decode sequenceNumber */
   invokeStartElement (pctxt, "sequenceNumber", -1);

   stat = asn1PD_H245SequenceNumber (pctxt, &pvalue->sequenceNumber);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "sequenceNumber", -1);

   /* decode logicalChannelNumber */
   invokeStartElement (pctxt, "logicalChannelNumber", -1);

   stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->logicalChannelNumber);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "logicalChannelNumber", -1);

   /* decode rejectReason */
   invokeStartElement (pctxt, "rejectReason", -1);

   stat = asn1PD_H245LogicalChannelRateRejectReason (pctxt, &pvalue->rejectReason);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "rejectReason", -1);

   /* decode currentMaximumBitRate */
   if (pvalue->m.currentMaximumBitRatePresent) {
      invokeStartElement (pctxt, "currentMaximumBitRate", -1);

      stat = asn1PD_H245MaximumBitRate (pctxt, &pvalue->currentMaximumBitRate);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "currentMaximumBitRate", -1);

   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245ResponseMessage (OOCTXT* pctxt, H245ResponseMessage* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 18);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            invokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = memAllocTypeZ (pctxt,
               H245NonStandardMessage);

            stat = asn1PD_H245NonStandardMessage (pctxt, pvalue->u.nonStandard);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* masterSlaveDeterminationAck */
         case 1:
            invokeStartElement (pctxt, "masterSlaveDeterminationAck", -1);

            pvalue->u.masterSlaveDeterminationAck = memAllocTypeZ (pctxt,
               H245MasterSlaveDeterminationAck);

            stat = asn1PD_H245MasterSlaveDeterminationAck (pctxt, pvalue->u.masterSlaveDeterminationAck);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "masterSlaveDeterminationAck", -1);

            break;

         /* masterSlaveDeterminationReject */
         case 2:
            invokeStartElement (pctxt, "masterSlaveDeterminationReject", -1);

            pvalue->u.masterSlaveDeterminationReject
                = memAllocTypeZ (pctxt,
               H245MasterSlaveDeterminationReject);

            stat = asn1PD_H245MasterSlaveDeterminationReject (pctxt, pvalue->u.masterSlaveDeterminationReject);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "masterSlaveDeterminationReject", -1);

            break;

         /* terminalCapabilitySetAck */
         case 3:
            invokeStartElement (pctxt, "terminalCapabilitySetAck", -1);

            pvalue->u.terminalCapabilitySetAck = memAllocTypeZ (pctxt,
               H245TerminalCapabilitySetAck);

            stat = asn1PD_H245TerminalCapabilitySetAck (pctxt, pvalue->u.terminalCapabilitySetAck);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "terminalCapabilitySetAck", -1);

            break;

         /* terminalCapabilitySetReject */
         case 4:
            invokeStartElement (pctxt, "terminalCapabilitySetReject", -1);

            pvalue->u.terminalCapabilitySetReject = memAllocTypeZ (pctxt,
               H245TerminalCapabilitySetReject);

            stat = asn1PD_H245TerminalCapabilitySetReject (pctxt, pvalue->u.terminalCapabilitySetReject);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "terminalCapabilitySetReject", -1);

            break;

         /* openLogicalChannelAck */
         case 5:
            invokeStartElement (pctxt, "openLogicalChannelAck", -1);

            pvalue->u.openLogicalChannelAck = memAllocTypeZ (pctxt,
               H245OpenLogicalChannelAck);

            stat = asn1PD_H245OpenLogicalChannelAck (pctxt, pvalue->u.openLogicalChannelAck);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "openLogicalChannelAck", -1);

            break;

         /* openLogicalChannelReject */
         case 6:
            invokeStartElement (pctxt, "openLogicalChannelReject", -1);

            pvalue->u.openLogicalChannelReject = memAllocTypeZ (pctxt,
               H245OpenLogicalChannelReject);

            stat = asn1PD_H245OpenLogicalChannelReject (pctxt, pvalue->u.openLogicalChannelReject);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "openLogicalChannelReject", -1);

            break;

         /* closeLogicalChannelAck */
         case 7:
            invokeStartElement (pctxt, "closeLogicalChannelAck", -1);

            pvalue->u.closeLogicalChannelAck = memAllocTypeZ (pctxt,
               H245CloseLogicalChannelAck);

            stat = asn1PD_H245CloseLogicalChannelAck (pctxt, pvalue->u.closeLogicalChannelAck);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "closeLogicalChannelAck", -1);

            break;

         /* requestChannelCloseAck */
         case 8:
            invokeStartElement (pctxt, "requestChannelCloseAck", -1);

            pvalue->u.requestChannelCloseAck = memAllocTypeZ (pctxt,
               H245RequestChannelCloseAck);

            stat = asn1PD_H245RequestChannelCloseAck (pctxt, pvalue->u.requestChannelCloseAck);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "requestChannelCloseAck", -1);

            break;

         /* requestChannelCloseReject */
         case 9:
            invokeStartElement (pctxt, "requestChannelCloseReject", -1);

            pvalue->u.requestChannelCloseReject = memAllocTypeZ (pctxt,
               H245RequestChannelCloseReject);

            stat = asn1PD_H245RequestChannelCloseReject (pctxt, pvalue->u.requestChannelCloseReject);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "requestChannelCloseReject", -1);

            break;

         /* multiplexEntrySendAck */
         case 10:
            invokeStartElement (pctxt, "multiplexEntrySendAck", -1);

            pvalue->u.multiplexEntrySendAck = memAllocTypeZ (pctxt,
               H245MultiplexEntrySendAck);

            stat = asn1PD_H245MultiplexEntrySendAck (pctxt, pvalue->u.multiplexEntrySendAck);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "multiplexEntrySendAck", -1);

            break;

         /* multiplexEntrySendReject */
         case 11:
            invokeStartElement (pctxt, "multiplexEntrySendReject", -1);

            pvalue->u.multiplexEntrySendReject = memAllocTypeZ (pctxt,
               H245MultiplexEntrySendReject);

            stat = asn1PD_H245MultiplexEntrySendReject (pctxt, pvalue->u.multiplexEntrySendReject);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "multiplexEntrySendReject", -1);

            break;

         /* requestMultiplexEntryAck */
         case 12:
            invokeStartElement (pctxt, "requestMultiplexEntryAck", -1);

            pvalue->u.requestMultiplexEntryAck = memAllocTypeZ (pctxt,
               H245RequestMultiplexEntryAck);

            stat = asn1PD_H245RequestMultiplexEntryAck (pctxt, pvalue->u.requestMultiplexEntryAck);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "requestMultiplexEntryAck", -1);

            break;

         /* requestMultiplexEntryReject */
         case 13:
            invokeStartElement (pctxt, "requestMultiplexEntryReject", -1);

            pvalue->u.requestMultiplexEntryReject = memAllocTypeZ (pctxt,
               H245RequestMultiplexEntryReject);

            stat = asn1PD_H245RequestMultiplexEntryReject (pctxt, pvalue->u.requestMultiplexEntryReject);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "requestMultiplexEntryReject", -1);

            break;

         /* requestModeAck */
         case 14:
            invokeStartElement (pctxt, "requestModeAck", -1);

            pvalue->u.requestModeAck = memAllocTypeZ (pctxt,
               H245RequestModeAck);

            stat = asn1PD_H245RequestModeAck (pctxt, pvalue->u.requestModeAck);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "requestModeAck", -1);

            break;

         /* requestModeReject */
         case 15:
            invokeStartElement (pctxt, "requestModeReject", -1);

            pvalue->u.requestModeReject = memAllocTypeZ (pctxt,
               H245RequestModeReject);

            stat = asn1PD_H245RequestModeReject (pctxt, pvalue->u.requestModeReject);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "requestModeReject", -1);

            break;

         /* roundTripDelayResponse */
         case 16:
            invokeStartElement (pctxt, "roundTripDelayResponse", -1);

            pvalue->u.roundTripDelayResponse = memAllocTypeZ (pctxt,
               H245RoundTripDelayResponse);

            stat = asn1PD_H245RoundTripDelayResponse (pctxt, pvalue->u.roundTripDelayResponse);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "roundTripDelayResponse", -1);

            break;

         /* maintenanceLoopAck */
         case 17:
            invokeStartElement (pctxt, "maintenanceLoopAck", -1);

            pvalue->u.maintenanceLoopAck = memAllocTypeZ (pctxt,
               H245MaintenanceLoopAck);

            stat = asn1PD_H245MaintenanceLoopAck (pctxt, pvalue->u.maintenanceLoopAck);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "maintenanceLoopAck", -1);

            break;

         /* maintenanceLoopReject */
         case 18:
            invokeStartElement (pctxt, "maintenanceLoopReject", -1);

            pvalue->u.maintenanceLoopReject = memAllocTypeZ (pctxt,
               H245MaintenanceLoopReject);

            stat = asn1PD_H245MaintenanceLoopReject (pctxt, pvalue->u.maintenanceLoopReject);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "maintenanceLoopReject", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 20;

      if (pvalue->t < 20) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt,
         (ASN1OCTET*)openType.data, openType.numocts);

      switch (pvalue->t) {
         /* communicationModeResponse */
         case 20:
            invokeStartElement (pctxt, "communicationModeResponse", -1);

            pvalue->u.communicationModeResponse = memAllocTypeZ (pctxt,
               H245CommunicationModeResponse);

            stat = asn1PD_H245CommunicationModeResponse (pctxt, pvalue->u.communicationModeResponse);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "communicationModeResponse", -1);

            break;

         /* conferenceResponse */
         case 21:
            invokeStartElement (pctxt, "conferenceResponse", -1);

            pvalue->u.conferenceResponse = memAllocTypeZ (pctxt,
               H245ConferenceResponse);

            stat = asn1PD_H245ConferenceResponse (pctxt, pvalue->u.conferenceResponse);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "conferenceResponse", -1);

            break;

         /* multilinkResponse */
         case 22:
            invokeStartElement (pctxt, "multilinkResponse", -1);

            pvalue->u.multilinkResponse = memAllocTypeZ (pctxt,
               H245MultilinkResponse);

            stat = asn1PD_H245MultilinkResponse (pctxt, pvalue->u.multilinkResponse);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "multilinkResponse", -1);

            break;

         /* logicalChannelRateAcknowledge */
         case 23:
            invokeStartElement (pctxt, "logicalChannelRateAcknowledge", -1);

            pvalue->u.logicalChannelRateAcknowledge = memAllocTypeZ (pctxt,
               H245LogicalChannelRateAcknowledge);

            stat = asn1PD_H245LogicalChannelRateAcknowledge (pctxt, pvalue->u.logicalChannelRateAcknowledge);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "logicalChannelRateAcknowledge", -1);

            break;

         /* logicalChannelRateReject */
         case 24:
            invokeStartElement (pctxt, "logicalChannelRateReject", -1);

            pvalue->u.logicalChannelRateReject = memAllocTypeZ (pctxt,
               H245LogicalChannelRateReject);

            stat = asn1PD_H245LogicalChannelRateReject (pctxt, pvalue->u.logicalChannelRateReject);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "logicalChannelRateReject", -1);

            break;

         /* genericResponse */
         case 25:
            invokeStartElement (pctxt, "genericResponse", -1);

            pvalue->u.genericResponse = memAllocTypeZ (pctxt,
               H245GenericMessage);

            stat = asn1PD_H245GenericMessage (pctxt, pvalue->u.genericResponse);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "genericResponse", -1);

            break;

         default:;
      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

EXTERN int asn1PD_H245MaintenanceLoopOffCommand (OOCTXT* pctxt, H245MaintenanceLoopOffCommand* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers (OOCTXT* pctxt, H245SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 65535, 0 };
   int stat = 0;
   OOUINT32 xx1 = 0;

   /* decode length determinant */

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeLength (pctxt, &pvalue->n);
   if (stat != 0) return stat;

   /* decode elements */

   ALLOC_ASN1ARRAY (pctxt, pvalue, H245CapabilityTableEntryNumber);

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      invokeStartElement (pctxt, "elem", xx1);

      stat = asn1PD_H245CapabilityTableEntryNumber (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "elem", xx1);

   }

   return (stat);
}

EXTERN int asn1PD_H245SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers (OOCTXT* pctxt, H245SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 256, 0 };
   int stat = 0;
   OOUINT32 xx1 = 0;

   /* decode length determinant */

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeLength (pctxt, &pvalue->n);
   if (stat != 0) return stat;

   /* decode elements */

   if (256 < pvalue->n) {
      return stat;
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      invokeStartElement (pctxt, "elem", xx1);

      stat = asn1PD_H245CapabilityDescriptorNumber (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "elem", xx1);

   }

   return (stat);
}

EXTERN int asn1PD_H245SendTerminalCapabilitySet_specificRequest (OOCTXT* pctxt, H245SendTerminalCapabilitySet_specificRequest* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.capabilityTableEntryNumbersPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.capabilityDescriptorNumbersPresent = optbit;

   /* decode root elements */
   /* decode multiplexCapability */
   invokeStartElement (pctxt, "multiplexCapability", -1);

   stat = DECODEBIT (pctxt, &pvalue->multiplexCapability);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->multiplexCapability);
   invokeEndElement (pctxt, "multiplexCapability", -1);

   /* decode capabilityTableEntryNumbers */
   if (pvalue->m.capabilityTableEntryNumbersPresent) {
      invokeStartElement (pctxt, "capabilityTableEntryNumbers", -1);

      stat = asn1PD_H245SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers (pctxt, &pvalue->capabilityTableEntryNumbers);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "capabilityTableEntryNumbers", -1);

   }

   /* decode capabilityDescriptorNumbers */
   if (pvalue->m.capabilityDescriptorNumbersPresent) {
      invokeStartElement (pctxt, "capabilityDescriptorNumbers", -1);

      stat = asn1PD_H245SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers (pctxt, &pvalue->capabilityDescriptorNumbers);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "capabilityDescriptorNumbers", -1);

   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245SendTerminalCapabilitySet (OOCTXT* pctxt, H245SendTerminalCapabilitySet* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* specificRequest */
         case 0:
            invokeStartElement (pctxt, "specificRequest", -1);

            pvalue->u.specificRequest = memAllocTypeZ (pctxt,
               H245SendTerminalCapabilitySet_specificRequest);

            stat = asn1PD_H245SendTerminalCapabilitySet_specificRequest (pctxt, pvalue->u.specificRequest);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "specificRequest", -1);

            break;

         /* genericRequest */
         case 1:
            invokeStartElement (pctxt, "genericRequest", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "genericRequest", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245EncryptionCommand_encryptionAlgorithmID (OOCTXT* pctxt, H245EncryptionCommand_encryptionAlgorithmID* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode h233AlgorithmIdentifier */
   invokeStartElement (pctxt, "h233AlgorithmIdentifier", -1);

   stat = asn1PD_H245SequenceNumber (pctxt, &pvalue->h233AlgorithmIdentifier);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "h233AlgorithmIdentifier", -1);

   /* decode associatedAlgorithm */
   invokeStartElement (pctxt, "associatedAlgorithm", -1);

   stat = asn1PD_H245NonStandardParameter (pctxt, &pvalue->associatedAlgorithm);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "associatedAlgorithm", -1);

   return (stat);
}

EXTERN int asn1PD_H245EncryptionCommand (OOCTXT* pctxt, H245EncryptionCommand* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* encryptionSE */
         case 0:
            invokeStartElement (pctxt, "encryptionSE", -1);

            pvalue->u.encryptionSE = memAllocTypeZ (pctxt, ASN1DynOctStr);

            stat = decodeDynOctetString (pctxt, (ASN1DynOctStr*)pvalue->u.encryptionSE);
            if (stat != 0) return stat;

            invokeOctStrValue (pctxt, pvalue->u.encryptionSE->numocts, pvalue->u.encryptionSE->data);
            invokeEndElement (pctxt, "encryptionSE", -1);

            break;

         /* encryptionIVRequest */
         case 1:
            invokeStartElement (pctxt, "encryptionIVRequest", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "encryptionIVRequest", -1);

            break;

         /* encryptionAlgorithmID */
         case 2:
            invokeStartElement (pctxt, "encryptionAlgorithmID", -1);

            pvalue->u.encryptionAlgorithmID = memAllocTypeZ (pctxt,
               H245EncryptionCommand_encryptionAlgorithmID);

            stat = asn1PD_H245EncryptionCommand_encryptionAlgorithmID (pctxt, pvalue->u.encryptionAlgorithmID);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "encryptionAlgorithmID", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 4;

      if (pvalue->t < 4) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245FlowControlCommand_scope (OOCTXT* pctxt, H245FlowControlCommand_scope* pvalue)
{
   int stat = 0;
   OOUINT32 ui;

   stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
   if (stat != 0) return stat;
   else pvalue->t = ui + 1;

   switch (ui) {
      /* logicalChannelNumber */
      case 0:
         invokeStartElement (pctxt, "logicalChannelNumber", -1);

         stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->u.logicalChannelNumber);
         if (stat != 0) return stat;

         invokeEndElement (pctxt, "logicalChannelNumber", -1);

         break;

      /* resourceID */
      case 1:
         invokeStartElement (pctxt, "resourceID", -1);

         stat = decodeConsUInt16 (pctxt, &pvalue->u.resourceID, 0, 65535);
         if (stat != 0) return stat;

         invokeUIntValue (pctxt, pvalue->u.resourceID);
         invokeEndElement (pctxt, "resourceID", -1);

         break;

      /* wholeMultiplex */
      case 2:
         invokeStartElement (pctxt, "wholeMultiplex", -1);

         /* NULL */

         invokeNullValue (pctxt);
         invokeEndElement (pctxt, "wholeMultiplex", -1);

         break;

      default:
         return ASN_E_INVOPT;
   }

   return (stat);
}

EXTERN int asn1PD_H245FlowControlCommand_restriction (OOCTXT* pctxt, H245FlowControlCommand_restriction* pvalue)
{
   int stat = 0;
   OOUINT32 ui;

   stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
   if (stat != 0) return stat;
   else pvalue->t = ui + 1;

   switch (ui) {
      /* maximumBitRate */
      case 0:
         invokeStartElement (pctxt, "maximumBitRate", -1);

         stat = decodeConsUnsigned (pctxt, &pvalue->u.maximumBitRate, 0, 16777215);
         if (stat != 0) return stat;

         invokeUIntValue (pctxt, pvalue->u.maximumBitRate);
         invokeEndElement (pctxt, "maximumBitRate", -1);

         break;

      /* noRestriction */
      case 1:
         invokeStartElement (pctxt, "noRestriction", -1);

         /* NULL */

         invokeNullValue (pctxt);
         invokeEndElement (pctxt, "noRestriction", -1);

         break;

      default:
         return ASN_E_INVOPT;
   }

   return (stat);
}

EXTERN int asn1PD_H245FlowControlCommand (OOCTXT* pctxt, H245FlowControlCommand* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode scope */
   invokeStartElement (pctxt, "scope", -1);

   stat = asn1PD_H245FlowControlCommand_scope (pctxt, &pvalue->scope);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "scope", -1);

   /* decode restriction */
   invokeStartElement (pctxt, "restriction", -1);

   stat = asn1PD_H245FlowControlCommand_restriction (pctxt, &pvalue->restriction);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "restriction", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245EndSessionCommand_gstnOptions (OOCTXT* pctxt, H245EndSessionCommand_gstnOptions* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 4);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* telephonyMode */
         case 0:
            invokeStartElement (pctxt, "telephonyMode", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "telephonyMode", -1);

            break;

         /* v8bis */
         case 1:
            invokeStartElement (pctxt, "v8bis", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "v8bis", -1);

            break;

         /* v34DSVD */
         case 2:
            invokeStartElement (pctxt, "v34DSVD", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "v34DSVD", -1);

            break;

         /* v34DuplexFAX */
         case 3:
            invokeStartElement (pctxt, "v34DuplexFAX", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "v34DuplexFAX", -1);

            break;

         /* v34H324 */
         case 4:
            invokeStartElement (pctxt, "v34H324", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "v34H324", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 6;

      if (pvalue->t < 6) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245EndSessionCommand_isdnOptions (OOCTXT* pctxt, H245EndSessionCommand_isdnOptions* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* telephonyMode */
         case 0:
            invokeStartElement (pctxt, "telephonyMode", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "telephonyMode", -1);

            break;

         /* v140 */
         case 1:
            invokeStartElement (pctxt, "v140", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "v140", -1);

            break;

         /* terminalOnHold */
         case 2:
            invokeStartElement (pctxt, "terminalOnHold", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "terminalOnHold", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 4;

      if (pvalue->t < 4) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245EndSessionCommand (OOCTXT* pctxt, H245EndSessionCommand* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            invokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = memAllocTypeZ (pctxt,
               H245NonStandardParameter);

            stat = asn1PD_H245NonStandardParameter (pctxt, pvalue->u.nonStandard);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* disconnect */
         case 1:
            invokeStartElement (pctxt, "disconnect", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "disconnect", -1);

            break;

         /* gstnOptions */
         case 2:
            invokeStartElement (pctxt, "gstnOptions", -1);

            pvalue->u.gstnOptions = memAllocTypeZ (pctxt,
               H245EndSessionCommand_gstnOptions);

            stat = asn1PD_H245EndSessionCommand_gstnOptions (pctxt, pvalue->u.gstnOptions);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "gstnOptions", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 4;

      if (pvalue->t < 4) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt,
         (ASN1OCTET*)openType.data, openType.numocts);

      switch (pvalue->t) {
         /* isdnOptions */
         case 4:
            invokeStartElement (pctxt, "isdnOptions", -1);

            pvalue->u.isdnOptions = memAllocTypeZ (pctxt,
               H245EndSessionCommand_isdnOptions);

            stat = asn1PD_H245EndSessionCommand_isdnOptions (pctxt, pvalue->u.isdnOptions);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "isdnOptions", -1);

            break;

         /* genericInformation */
         case 5:
            invokeStartElement (pctxt, "genericInformation", -1);

            pvalue->u.genericInformation = memAllocTypeZ (pctxt,
               H245_SeqOfH245GenericInformation);

            stat = asn1PD_H245_SeqOfH245GenericInformation (pctxt, pvalue->u.genericInformation);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "genericInformation", -1);

            break;

         default:;
      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

EXTERN int asn1PD_H245MiscellaneousCommand_type_videoFastUpdateGOB (OOCTXT* pctxt, H245MiscellaneousCommand_type_videoFastUpdateGOB* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode firstGOB */
   invokeStartElement (pctxt, "firstGOB", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->firstGOB, 0, 17);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->firstGOB);
   invokeEndElement (pctxt, "firstGOB", -1);

   /* decode numberOfGOBs */
   invokeStartElement (pctxt, "numberOfGOBs", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->numberOfGOBs, 1, 18);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->numberOfGOBs);
   invokeEndElement (pctxt, "numberOfGOBs", -1);

   return (stat);
}

EXTERN int asn1PD_H245MiscellaneousCommand_type_videoFastUpdateMB (OOCTXT* pctxt, H245MiscellaneousCommand_type_videoFastUpdateMB* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.firstGOBPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.firstMBPresent = optbit;

   /* decode root elements */
   /* decode firstGOB */
   if (pvalue->m.firstGOBPresent) {
      invokeStartElement (pctxt, "firstGOB", -1);

      stat = decodeConsUInt8 (pctxt, &pvalue->firstGOB, 0, 255);
      if (stat != 0) return stat;

      invokeUIntValue (pctxt, pvalue->firstGOB);
      invokeEndElement (pctxt, "firstGOB", -1);

   }

   /* decode firstMB */
   if (pvalue->m.firstMBPresent) {
      invokeStartElement (pctxt, "firstMB", -1);

      stat = decodeConsUInt16 (pctxt, &pvalue->firstMB, 1, 8192);
      if (stat != 0) return stat;

      invokeUIntValue (pctxt, pvalue->firstMB);
      invokeEndElement (pctxt, "firstMB", -1);

   }

   /* decode numberOfMBs */
   invokeStartElement (pctxt, "numberOfMBs", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->numberOfMBs, 1, 8192);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->numberOfMBs);
   invokeEndElement (pctxt, "numberOfMBs", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245KeyProtectionMethod (OOCTXT* pctxt, H245KeyProtectionMethod* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode secureChannel */
   invokeStartElement (pctxt, "secureChannel", -1);

   stat = DECODEBIT (pctxt, &pvalue->secureChannel);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->secureChannel);
   invokeEndElement (pctxt, "secureChannel", -1);

   /* decode sharedSecret */
   invokeStartElement (pctxt, "sharedSecret", -1);

   stat = DECODEBIT (pctxt, &pvalue->sharedSecret);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->sharedSecret);
   invokeEndElement (pctxt, "sharedSecret", -1);

   /* decode certProtectedKey */
   invokeStartElement (pctxt, "certProtectedKey", -1);

   stat = DECODEBIT (pctxt, &pvalue->certProtectedKey);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->certProtectedKey);
   invokeEndElement (pctxt, "certProtectedKey", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245EncryptionUpdateRequest (OOCTXT* pctxt, H245EncryptionUpdateRequest* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.keyProtectionMethodPresent = optbit;

   /* decode root elements */
   /* decode keyProtectionMethod */
   if (pvalue->m.keyProtectionMethodPresent) {
      invokeStartElement (pctxt, "keyProtectionMethod", -1);

      stat = asn1PD_H245KeyProtectionMethod (pctxt, &pvalue->keyProtectionMethod);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "keyProtectionMethod", -1);

   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return stat;

            if (i < 1) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt,
                  (ASN1OCTET*)openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     if (openType.numocts == 0) break;

                     pvalue->m.synchFlagPresent = 1;

                     invokeStartElement (pctxt, "synchFlag", -1);

                     stat = decodeConsUInt8 (pctxt, &pvalue->synchFlag, 0, 255);
                     if (stat != 0) return stat;

                     invokeUIntValue (pctxt, pvalue->synchFlag);
                     invokeEndElement (pctxt, "synchFlag", -1);

                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245MiscellaneousCommand_type_progressiveRefinementStart_repeatCount (OOCTXT* pctxt, H245MiscellaneousCommand_type_progressiveRefinementStart_repeatCount* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 3);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* doOneProgression */
         case 0:
            invokeStartElement (pctxt, "doOneProgression", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "doOneProgression", -1);

            break;

         /* doContinuousProgressions */
         case 1:
            invokeStartElement (pctxt, "doContinuousProgressions", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "doContinuousProgressions", -1);

            break;

         /* doOneIndependentProgression */
         case 2:
            invokeStartElement (pctxt, "doOneIndependentProgression", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "doOneIndependentProgression", -1);

            break;

         /* doContinuousIndependentProgressions */
         case 3:
            invokeStartElement (pctxt, "doContinuousIndependentProgressions", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "doContinuousIndependentProgressions", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 5;

      if (pvalue->t < 5) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245MiscellaneousCommand_type_progressiveRefinementStart (OOCTXT* pctxt, H245MiscellaneousCommand_type_progressiveRefinementStart* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode repeatCount */
   invokeStartElement (pctxt, "repeatCount", -1);

   stat = asn1PD_H245MiscellaneousCommand_type_progressiveRefinementStart_repeatCount (pctxt, &pvalue->repeatCount);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "repeatCount", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245MiscellaneousCommand_type_videoBadMBs (OOCTXT* pctxt, H245MiscellaneousCommand_type_videoBadMBs* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode firstMB */
   invokeStartElement (pctxt, "firstMB", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->firstMB, 1, 9216);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->firstMB);
   invokeEndElement (pctxt, "firstMB", -1);

   /* decode numberOfMBs */
   invokeStartElement (pctxt, "numberOfMBs", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->numberOfMBs, 1, 9216);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->numberOfMBs);
   invokeEndElement (pctxt, "numberOfMBs", -1);

   /* decode temporalReference */
   invokeStartElement (pctxt, "temporalReference", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->temporalReference, 0, 1023);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->temporalReference);
   invokeEndElement (pctxt, "temporalReference", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245PictureReference (OOCTXT* pctxt, H245PictureReference* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* pictureNumber */
         case 0:
            invokeStartElement (pctxt, "pictureNumber", -1);

            stat = decodeConsUInt16 (pctxt, &pvalue->u.pictureNumber, 0, 1023);
            if (stat != 0) return stat;

            invokeUIntValue (pctxt, pvalue->u.pictureNumber);
            invokeEndElement (pctxt, "pictureNumber", -1);

            break;

         /* longTermPictureIndex */
         case 1:
            invokeStartElement (pctxt, "longTermPictureIndex", -1);

            stat = decodeConsUInt8 (pctxt, &pvalue->u.longTermPictureIndex, 0, 255);
            if (stat != 0) return stat;

            invokeUIntValue (pctxt, pvalue->u.longTermPictureIndex);
            invokeEndElement (pctxt, "longTermPictureIndex", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245_SeqOfH245PictureReference (OOCTXT* pctxt, H245_SeqOfH245PictureReference* pvalue)
{
   int stat = 0;
   H245PictureReference* pdata;
   DListNode* pnode;
   OOUINT32 count = 0;
   OOUINT32 xx1 = 0;
   int lstat;
   OOUINT32 total = 0;

   dListInit (pvalue);

   for (;;) {
      /* decode length determinant */

      lstat = decodeLength (pctxt, &count);
      if (lstat != 0 && lstat != ASN_OK_FRAG) {
         return lstat;
      }
      else if (count == 0) break;
      total += count;

      /* decode elements */

      for (; xx1 < total; xx1++) {
         invokeStartElement (pctxt, "elem", xx1);

         dListAllocNodeAndData (pctxt, H245PictureReference, &pnode, &pdata);

         stat = asn1PD_H245PictureReference (pctxt, pdata);
         if (stat != 0) return stat;

         invokeEndElement (pctxt, "elem", xx1);

         dListAppendNode2 (pvalue, pnode);
      }

      if (lstat == 0) break;
   }

   return (stat);
}

EXTERN int asn1PD_H245MiscellaneousCommand_type_lostPartialPicture (OOCTXT* pctxt, H245MiscellaneousCommand_type_lostPartialPicture* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode pictureReference */
   invokeStartElement (pctxt, "pictureReference", -1);

   stat = asn1PD_H245PictureReference (pctxt, &pvalue->pictureReference);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "pictureReference", -1);

   /* decode firstMB */
   invokeStartElement (pctxt, "firstMB", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->firstMB, 1, 9216);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->firstMB);
   invokeEndElement (pctxt, "firstMB", -1);

   /* decode numberOfMBs */
   invokeStartElement (pctxt, "numberOfMBs", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->numberOfMBs, 1, 9216);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->numberOfMBs);
   invokeEndElement (pctxt, "numberOfMBs", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245MiscellaneousCommand_type_encryptionUpdateCommand (OOCTXT* pctxt, H245MiscellaneousCommand_type_encryptionUpdateCommand* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.multiplePayloadStreamPresent = optbit;

   /* decode root elements */
   /* decode encryptionSync */
   invokeStartElement (pctxt, "encryptionSync", -1);

   stat = asn1PD_H245EncryptionSync (pctxt, &pvalue->encryptionSync);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "encryptionSync", -1);

   /* decode multiplePayloadStream */
   if (pvalue->m.multiplePayloadStreamPresent) {
      invokeStartElement (pctxt, "multiplePayloadStream", -1);

      stat = asn1PD_H245MultiplePayloadStream (pctxt, &pvalue->multiplePayloadStream);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "multiplePayloadStream", -1);

   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245MiscellaneousCommand_type_encryptionUpdateAck (OOCTXT* pctxt, H245MiscellaneousCommand_type_encryptionUpdateAck* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode synchFlag */
   invokeStartElement (pctxt, "synchFlag", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->synchFlag, 0, 255);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->synchFlag);
   invokeEndElement (pctxt, "synchFlag", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245MiscellaneousCommand_type (OOCTXT* pctxt, H245MiscellaneousCommand_type* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 9);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* equaliseDelay */
         case 0:
            invokeStartElement (pctxt, "equaliseDelay", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "equaliseDelay", -1);

            break;

         /* zeroDelay */
         case 1:
            invokeStartElement (pctxt, "zeroDelay", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "zeroDelay", -1);

            break;

         /* multipointModeCommand */
         case 2:
            invokeStartElement (pctxt, "multipointModeCommand", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "multipointModeCommand", -1);

            break;

         /* cancelMultipointModeCommand */
         case 3:
            invokeStartElement (pctxt, "cancelMultipointModeCommand", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "cancelMultipointModeCommand", -1);

            break;

         /* videoFreezePicture */
         case 4:
            invokeStartElement (pctxt, "videoFreezePicture", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "videoFreezePicture", -1);

            break;

         /* videoFastUpdatePicture */
         case 5:
            invokeStartElement (pctxt, "videoFastUpdatePicture", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "videoFastUpdatePicture", -1);

            break;

         /* videoFastUpdateGOB */
         case 6:
            invokeStartElement (pctxt, "videoFastUpdateGOB", -1);

            pvalue->u.videoFastUpdateGOB = memAllocTypeZ (pctxt,
               H245MiscellaneousCommand_type_videoFastUpdateGOB);

            stat = asn1PD_H245MiscellaneousCommand_type_videoFastUpdateGOB (pctxt, pvalue->u.videoFastUpdateGOB);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "videoFastUpdateGOB", -1);

            break;

         /* videoTemporalSpatialTradeOff */
         case 7:
            invokeStartElement (pctxt, "videoTemporalSpatialTradeOff", -1);

            stat = decodeConsUInt8 (pctxt, &pvalue->u.videoTemporalSpatialTradeOff, 0, 31);
            if (stat != 0) return stat;

            invokeUIntValue (pctxt, pvalue->u.videoTemporalSpatialTradeOff);
            invokeEndElement (pctxt, "videoTemporalSpatialTradeOff", -1);

            break;

         /* videoSendSyncEveryGOB */
         case 8:
            invokeStartElement (pctxt, "videoSendSyncEveryGOB", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "videoSendSyncEveryGOB", -1);

            break;

         /* videoSendSyncEveryGOBCancel */
         case 9:
            invokeStartElement (pctxt, "videoSendSyncEveryGOBCancel", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "videoSendSyncEveryGOBCancel", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 11;

      if (pvalue->t < 11) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt,
         (ASN1OCTET*)openType.data, openType.numocts);

      switch (pvalue->t) {
         /* videoFastUpdateMB */
         case 11:
            invokeStartElement (pctxt, "videoFastUpdateMB", -1);

            pvalue->u.videoFastUpdateMB = memAllocTypeZ (pctxt,
               H245MiscellaneousCommand_type_videoFastUpdateMB);

            stat = asn1PD_H245MiscellaneousCommand_type_videoFastUpdateMB (pctxt, pvalue->u.videoFastUpdateMB);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "videoFastUpdateMB", -1);

            break;

         /* maxH223MUXPDUsize */
         case 12:
            invokeStartElement (pctxt, "maxH223MUXPDUsize", -1);

            stat = decodeConsUInt16 (pctxt, &pvalue->u.maxH223MUXPDUsize, 1, 65535);
            if (stat != 0) return stat;

            invokeUIntValue (pctxt, pvalue->u.maxH223MUXPDUsize);
            invokeEndElement (pctxt, "maxH223MUXPDUsize", -1);

            break;

         /* encryptionUpdate */
         case 13:
            invokeStartElement (pctxt, "encryptionUpdate", -1);

            pvalue->u.encryptionUpdate = memAllocTypeZ (pctxt,
               H245EncryptionSync);

            stat = asn1PD_H245EncryptionSync (pctxt, pvalue->u.encryptionUpdate);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "encryptionUpdate", -1);

            break;

         /* encryptionUpdateRequest */
         case 14:
            invokeStartElement (pctxt, "encryptionUpdateRequest", -1);

            pvalue->u.encryptionUpdateRequest = memAllocTypeZ (pctxt,
               H245EncryptionUpdateRequest);

            stat = asn1PD_H245EncryptionUpdateRequest (pctxt, pvalue->u.encryptionUpdateRequest);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "encryptionUpdateRequest", -1);

            break;

         /* switchReceiveMediaOff */
         case 15:
            invokeStartElement (pctxt, "switchReceiveMediaOff", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "switchReceiveMediaOff", -1);

            break;

         /* switchReceiveMediaOn */
         case 16:
            invokeStartElement (pctxt, "switchReceiveMediaOn", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "switchReceiveMediaOn", -1);

            break;

         /* progressiveRefinementStart */
         case 17:
            invokeStartElement (pctxt, "progressiveRefinementStart", -1);

            pvalue->u.progressiveRefinementStart = memAllocTypeZ (pctxt,
               H245MiscellaneousCommand_type_progressiveRefinementStart);

            stat = asn1PD_H245MiscellaneousCommand_type_progressiveRefinementStart (pctxt, pvalue->u.progressiveRefinementStart);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "progressiveRefinementStart", -1);

            break;

         /* progressiveRefinementAbortOne */
         case 18:
            invokeStartElement (pctxt, "progressiveRefinementAbortOne", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "progressiveRefinementAbortOne", -1);

            break;

         /* progressiveRefinementAbortContinuous */
         case 19:
            invokeStartElement (pctxt, "progressiveRefinementAbortContinuous", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "progressiveRefinementAbortContinuous", -1);

            break;

         /* videoBadMBs */
         case 20:
            invokeStartElement (pctxt, "videoBadMBs", -1);

            pvalue->u.videoBadMBs = memAllocTypeZ (pctxt,
               H245MiscellaneousCommand_type_videoBadMBs);

            stat = asn1PD_H245MiscellaneousCommand_type_videoBadMBs (pctxt, pvalue->u.videoBadMBs);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "videoBadMBs", -1);

            break;

         /* lostPicture */
         case 21:
            invokeStartElement (pctxt, "lostPicture", -1);

            pvalue->u.lostPicture = memAllocTypeZ (pctxt,
               H245_SeqOfH245PictureReference);

            stat = asn1PD_H245_SeqOfH245PictureReference (pctxt, pvalue->u.lostPicture);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "lostPicture", -1);

            break;

         /* lostPartialPicture */
         case 22:
            invokeStartElement (pctxt, "lostPartialPicture", -1);

            pvalue->u.lostPartialPicture = memAllocTypeZ (pctxt,
               H245MiscellaneousCommand_type_lostPartialPicture);

            stat = asn1PD_H245MiscellaneousCommand_type_lostPartialPicture (pctxt, pvalue->u.lostPartialPicture);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "lostPartialPicture", -1);

            break;

         /* recoveryReferencePicture */
         case 23:
            invokeStartElement (pctxt, "recoveryReferencePicture", -1);

            pvalue->u.recoveryReferencePicture = memAllocTypeZ (pctxt,
               H245_SeqOfH245PictureReference);

            stat = asn1PD_H245_SeqOfH245PictureReference (pctxt, pvalue->u.recoveryReferencePicture);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "recoveryReferencePicture", -1);

            break;

         /* encryptionUpdateCommand */
         case 24:
            invokeStartElement (pctxt, "encryptionUpdateCommand", -1);

            pvalue->u.encryptionUpdateCommand = memAllocTypeZ (pctxt,
               H245MiscellaneousCommand_type_encryptionUpdateCommand);

            stat = asn1PD_H245MiscellaneousCommand_type_encryptionUpdateCommand (pctxt, pvalue->u.encryptionUpdateCommand);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "encryptionUpdateCommand", -1);

            break;

         /* encryptionUpdateAck */
         case 25:
            invokeStartElement (pctxt, "encryptionUpdateAck", -1);

            pvalue->u.encryptionUpdateAck = memAllocTypeZ (pctxt,
               H245MiscellaneousCommand_type_encryptionUpdateAck);

            stat = asn1PD_H245MiscellaneousCommand_type_encryptionUpdateAck (pctxt, pvalue->u.encryptionUpdateAck);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "encryptionUpdateAck", -1);

            break;

         default:;
      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

EXTERN int asn1PD_H245EncryptionUpdateDirection (OOCTXT* pctxt, H245EncryptionUpdateDirection* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* masterToSlave */
         case 0:
            invokeStartElement (pctxt, "masterToSlave", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "masterToSlave", -1);

            break;

         /* slaveToMaster */
         case 1:
            invokeStartElement (pctxt, "slaveToMaster", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "slaveToMaster", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245MiscellaneousCommand (OOCTXT* pctxt, H245MiscellaneousCommand* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   /* decode root elements */
   /* decode logicalChannelNumber */
   invokeStartElement (pctxt, "logicalChannelNumber", -1);

   stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->logicalChannelNumber);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "logicalChannelNumber", -1);

   /* decode type */
   invokeStartElement (pctxt, "type", -1);

   stat = asn1PD_H245MiscellaneousCommand_type (pctxt, &pvalue->type);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "type", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return stat;

            if (i < 1) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt,
                  (ASN1OCTET*)openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     if (openType.numocts == 0) break;

                     pvalue->m.directionPresent = 1;

                     invokeStartElement (pctxt, "direction", -1);

                     stat = asn1PD_H245EncryptionUpdateDirection (pctxt, &pvalue->direction);
                     if (stat != 0) return stat;

                     invokeEndElement (pctxt, "direction", -1);

                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245CommunicationModeCommand_communicationModeTable (OOCTXT* pctxt, H245CommunicationModeCommand_communicationModeTable* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 256, 0 };
   int stat = 0;
   H245CommunicationModeTableEntry* pdata;
   DListNode* pnode;
   OOUINT32 count = 0;
   OOUINT32 xx1 = 0;

   /* decode length determinant */

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeLength (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      invokeStartElement (pctxt, "elem", xx1);

      dListAllocNodeAndData (pctxt, H245CommunicationModeTableEntry, &pnode, &pdata);

      stat = asn1PD_H245CommunicationModeTableEntry (pctxt, pdata);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "elem", xx1);

      dListAppendNode2 (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1PD_H245CommunicationModeCommand (OOCTXT* pctxt, H245CommunicationModeCommand* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode communicationModeTable */
   invokeStartElement (pctxt, "communicationModeTable", -1);

   stat = asn1PD_H245CommunicationModeCommand_communicationModeTable (pctxt, &pvalue->communicationModeTable);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "communicationModeTable", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245SubstituteConferenceIDCommand (OOCTXT* pctxt, H245SubstituteConferenceIDCommand* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode conferenceIdentifier */
   invokeStartElement (pctxt, "conferenceIdentifier", -1);

   stat = asn1PD_H245SubstituteConferenceIDCommand_conferenceIdentifier (pctxt, &pvalue->conferenceIdentifier);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "conferenceIdentifier", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245ConferenceCommand (OOCTXT* pctxt, H245ConferenceCommand* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 6);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* broadcastMyLogicalChannel */
         case 0:
            invokeStartElement (pctxt, "broadcastMyLogicalChannel", -1);

            stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->u.broadcastMyLogicalChannel);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "broadcastMyLogicalChannel", -1);

            break;

         /* cancelBroadcastMyLogicalChannel */
         case 1:
            invokeStartElement (pctxt, "cancelBroadcastMyLogicalChannel", -1);

            stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->u.cancelBroadcastMyLogicalChannel);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "cancelBroadcastMyLogicalChannel", -1);

            break;

         /* makeTerminalBroadcaster */
         case 2:
            invokeStartElement (pctxt, "makeTerminalBroadcaster", -1);

            pvalue->u.makeTerminalBroadcaster = memAllocTypeZ (pctxt,
               H245TerminalLabel);

            stat = asn1PD_H245TerminalLabel (pctxt, pvalue->u.makeTerminalBroadcaster);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "makeTerminalBroadcaster", -1);

            break;

         /* cancelMakeTerminalBroadcaster */
         case 3:
            invokeStartElement (pctxt, "cancelMakeTerminalBroadcaster", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "cancelMakeTerminalBroadcaster", -1);

            break;

         /* sendThisSource */
         case 4:
            invokeStartElement (pctxt, "sendThisSource", -1);

            pvalue->u.sendThisSource = memAllocTypeZ (pctxt,
               H245TerminalLabel);

            stat = asn1PD_H245TerminalLabel (pctxt, pvalue->u.sendThisSource);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "sendThisSource", -1);

            break;

         /* cancelSendThisSource */
         case 5:
            invokeStartElement (pctxt, "cancelSendThisSource", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "cancelSendThisSource", -1);

            break;

         /* dropConference */
         case 6:
            invokeStartElement (pctxt, "dropConference", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "dropConference", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 8;

      if (pvalue->t < 8) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt,
         (ASN1OCTET*)openType.data, openType.numocts);

      switch (pvalue->t) {
         /* substituteConferenceIDCommand */
         case 8:
            invokeStartElement (pctxt, "substituteConferenceIDCommand", -1);

            pvalue->u.substituteConferenceIDCommand = memAllocTypeZ (pctxt,
               H245SubstituteConferenceIDCommand);

            stat = asn1PD_H245SubstituteConferenceIDCommand (pctxt, pvalue->u.substituteConferenceIDCommand);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "substituteConferenceIDCommand", -1);

            break;

         default:;
      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

EXTERN int asn1PD_H245H223MultiplexReconfiguration_h223ModeChange (OOCTXT* pctxt, H245H223MultiplexReconfiguration_h223ModeChange* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 3);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* toLevel0 */
         case 0:
            invokeStartElement (pctxt, "toLevel0", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "toLevel0", -1);

            break;

         /* toLevel1 */
         case 1:
            invokeStartElement (pctxt, "toLevel1", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "toLevel1", -1);

            break;

         /* toLevel2 */
         case 2:
            invokeStartElement (pctxt, "toLevel2", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "toLevel2", -1);

            break;

         /* toLevel2withOptionalHeader */
         case 3:
            invokeStartElement (pctxt, "toLevel2withOptionalHeader", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "toLevel2withOptionalHeader", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 5;

      if (pvalue->t < 5) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245H223MultiplexReconfiguration_h223AnnexADoubleFlag (OOCTXT* pctxt, H245H223MultiplexReconfiguration_h223AnnexADoubleFlag* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* start */
         case 0:
            invokeStartElement (pctxt, "start", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "start", -1);

            break;

         /* stop */
         case 1:
            invokeStartElement (pctxt, "stop", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "stop", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245H223MultiplexReconfiguration (OOCTXT* pctxt, H245H223MultiplexReconfiguration* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* h223ModeChange */
         case 0:
            invokeStartElement (pctxt, "h223ModeChange", -1);

            pvalue->u.h223ModeChange = memAllocTypeZ (pctxt,
               H245H223MultiplexReconfiguration_h223ModeChange);

            stat = asn1PD_H245H223MultiplexReconfiguration_h223ModeChange (pctxt, pvalue->u.h223ModeChange);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "h223ModeChange", -1);

            break;

         /* h223AnnexADoubleFlag */
         case 1:
            invokeStartElement (pctxt, "h223AnnexADoubleFlag", -1);

            pvalue->u.h223AnnexADoubleFlag = memAllocTypeZ (pctxt,
               H245H223MultiplexReconfiguration_h223AnnexADoubleFlag);

            stat = asn1PD_H245H223MultiplexReconfiguration_h223AnnexADoubleFlag (pctxt, pvalue->u.h223AnnexADoubleFlag);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "h223AnnexADoubleFlag", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245NewATMVCCommand_aal_aal1_clockRecovery (OOCTXT* pctxt, H245NewATMVCCommand_aal_aal1_clockRecovery* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nullClockRecovery */
         case 0:
            invokeStartElement (pctxt, "nullClockRecovery", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "nullClockRecovery", -1);

            break;

         /* srtsClockRecovery */
         case 1:
            invokeStartElement (pctxt, "srtsClockRecovery", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "srtsClockRecovery", -1);

            break;

         /* adaptiveClockRecovery */
         case 2:
            invokeStartElement (pctxt, "adaptiveClockRecovery", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "adaptiveClockRecovery", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 4;

      if (pvalue->t < 4) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245NewATMVCCommand_aal_aal1_errorCorrection (OOCTXT* pctxt, H245NewATMVCCommand_aal_aal1_errorCorrection* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 3);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nullErrorCorrection */
         case 0:
            invokeStartElement (pctxt, "nullErrorCorrection", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "nullErrorCorrection", -1);

            break;

         /* longInterleaver */
         case 1:
            invokeStartElement (pctxt, "longInterleaver", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "longInterleaver", -1);

            break;

         /* shortInterleaver */
         case 2:
            invokeStartElement (pctxt, "shortInterleaver", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "shortInterleaver", -1);

            break;

         /* errorCorrectionOnly */
         case 3:
            invokeStartElement (pctxt, "errorCorrectionOnly", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "errorCorrectionOnly", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 5;

      if (pvalue->t < 5) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245NewATMVCCommand_aal_aal1 (OOCTXT* pctxt, H245NewATMVCCommand_aal_aal1* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode clockRecovery */
   invokeStartElement (pctxt, "clockRecovery", -1);

   stat = asn1PD_H245NewATMVCCommand_aal_aal1_clockRecovery (pctxt, &pvalue->clockRecovery);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "clockRecovery", -1);

   /* decode errorCorrection */
   invokeStartElement (pctxt, "errorCorrection", -1);

   stat = asn1PD_H245NewATMVCCommand_aal_aal1_errorCorrection (pctxt, &pvalue->errorCorrection);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "errorCorrection", -1);

   /* decode structuredDataTransfer */
   invokeStartElement (pctxt, "structuredDataTransfer", -1);

   stat = DECODEBIT (pctxt, &pvalue->structuredDataTransfer);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->structuredDataTransfer);
   invokeEndElement (pctxt, "structuredDataTransfer", -1);

   /* decode partiallyFilledCells */
   invokeStartElement (pctxt, "partiallyFilledCells", -1);

   stat = DECODEBIT (pctxt, &pvalue->partiallyFilledCells);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->partiallyFilledCells);
   invokeEndElement (pctxt, "partiallyFilledCells", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245NewATMVCCommand_aal_aal5 (OOCTXT* pctxt, H245NewATMVCCommand_aal_aal5* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode forwardMaximumSDUSize */
   invokeStartElement (pctxt, "forwardMaximumSDUSize", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->forwardMaximumSDUSize, 0, 65535);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->forwardMaximumSDUSize);
   invokeEndElement (pctxt, "forwardMaximumSDUSize", -1);

   /* decode backwardMaximumSDUSize */
   invokeStartElement (pctxt, "backwardMaximumSDUSize", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->backwardMaximumSDUSize, 0, 65535);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->backwardMaximumSDUSize);
   invokeEndElement (pctxt, "backwardMaximumSDUSize", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245NewATMVCCommand_aal (OOCTXT* pctxt, H245NewATMVCCommand_aal* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* aal1 */
         case 0:
            invokeStartElement (pctxt, "aal1", -1);

            pvalue->u.aal1 = memAllocTypeZ (pctxt,
               H245NewATMVCCommand_aal_aal1);

            stat = asn1PD_H245NewATMVCCommand_aal_aal1 (pctxt, pvalue->u.aal1);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "aal1", -1);

            break;

         /* aal5 */
         case 1:
            invokeStartElement (pctxt, "aal5", -1);

            pvalue->u.aal5 = memAllocTypeZ (pctxt,
               H245NewATMVCCommand_aal_aal5);

            stat = asn1PD_H245NewATMVCCommand_aal_aal5 (pctxt, pvalue->u.aal5);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "aal5", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245NewATMVCCommand_multiplex (OOCTXT* pctxt, H245NewATMVCCommand_multiplex* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* noMultiplex */
         case 0:
            invokeStartElement (pctxt, "noMultiplex", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "noMultiplex", -1);

            break;

         /* transportStream */
         case 1:
            invokeStartElement (pctxt, "transportStream", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "transportStream", -1);

            break;

         /* programStream */
         case 2:
            invokeStartElement (pctxt, "programStream", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "programStream", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 4;

      if (pvalue->t < 4) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245NewATMVCCommand_reverseParameters_multiplex (OOCTXT* pctxt, H245NewATMVCCommand_reverseParameters_multiplex* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* noMultiplex */
         case 0:
            invokeStartElement (pctxt, "noMultiplex", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "noMultiplex", -1);

            break;

         /* transportStream */
         case 1:
            invokeStartElement (pctxt, "transportStream", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "transportStream", -1);

            break;

         /* programStream */
         case 2:
            invokeStartElement (pctxt, "programStream", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "programStream", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 4;

      if (pvalue->t < 4) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245NewATMVCCommand_reverseParameters (OOCTXT* pctxt, H245NewATMVCCommand_reverseParameters* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode bitRate */
   invokeStartElement (pctxt, "bitRate", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->bitRate, 1, 65535);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->bitRate);
   invokeEndElement (pctxt, "bitRate", -1);

   /* decode bitRateLockedToPCRClock */
   invokeStartElement (pctxt, "bitRateLockedToPCRClock", -1);

   stat = DECODEBIT (pctxt, &pvalue->bitRateLockedToPCRClock);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->bitRateLockedToPCRClock);
   invokeEndElement (pctxt, "bitRateLockedToPCRClock", -1);

   /* decode bitRateLockedToNetworkClock */
   invokeStartElement (pctxt, "bitRateLockedToNetworkClock", -1);

   stat = DECODEBIT (pctxt, &pvalue->bitRateLockedToNetworkClock);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->bitRateLockedToNetworkClock);
   invokeEndElement (pctxt, "bitRateLockedToNetworkClock", -1);

   /* decode multiplex */
   invokeStartElement (pctxt, "multiplex", -1);

   stat = asn1PD_H245NewATMVCCommand_reverseParameters_multiplex (pctxt, &pvalue->multiplex);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "multiplex", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245NewATMVCCommand (OOCTXT* pctxt, H245NewATMVCCommand* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode resourceID */
   invokeStartElement (pctxt, "resourceID", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->resourceID, 0, 65535);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->resourceID);
   invokeEndElement (pctxt, "resourceID", -1);

   /* decode bitRate */
   invokeStartElement (pctxt, "bitRate", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->bitRate, 1, 65535);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->bitRate);
   invokeEndElement (pctxt, "bitRate", -1);

   /* decode bitRateLockedToPCRClock */
   invokeStartElement (pctxt, "bitRateLockedToPCRClock", -1);

   stat = DECODEBIT (pctxt, &pvalue->bitRateLockedToPCRClock);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->bitRateLockedToPCRClock);
   invokeEndElement (pctxt, "bitRateLockedToPCRClock", -1);

   /* decode bitRateLockedToNetworkClock */
   invokeStartElement (pctxt, "bitRateLockedToNetworkClock", -1);

   stat = DECODEBIT (pctxt, &pvalue->bitRateLockedToNetworkClock);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->bitRateLockedToNetworkClock);
   invokeEndElement (pctxt, "bitRateLockedToNetworkClock", -1);

   /* decode aal */
   invokeStartElement (pctxt, "aal", -1);

   stat = asn1PD_H245NewATMVCCommand_aal (pctxt, &pvalue->aal);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "aal", -1);

   /* decode multiplex */
   invokeStartElement (pctxt, "multiplex", -1);

   stat = asn1PD_H245NewATMVCCommand_multiplex (pctxt, &pvalue->multiplex);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "multiplex", -1);

   /* decode reverseParameters */
   invokeStartElement (pctxt, "reverseParameters", -1);

   stat = asn1PD_H245NewATMVCCommand_reverseParameters (pctxt, &pvalue->reverseParameters);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "reverseParameters", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245MobileMultilinkReconfigurationCommand_status (OOCTXT* pctxt, H245MobileMultilinkReconfigurationCommand_status* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* synchronized_ */
         case 0:
            invokeStartElement (pctxt, "synchronized_", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "synchronized_", -1);

            break;

         /* reconfiguration */
         case 1:
            invokeStartElement (pctxt, "reconfiguration", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "reconfiguration", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245MobileMultilinkReconfigurationCommand (OOCTXT* pctxt, H245MobileMultilinkReconfigurationCommand* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode sampleSize */
   invokeStartElement (pctxt, "sampleSize", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->sampleSize, 1, 255);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->sampleSize);
   invokeEndElement (pctxt, "sampleSize", -1);

   /* decode samplesPerFrame */
   invokeStartElement (pctxt, "samplesPerFrame", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->samplesPerFrame, 1, 255);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->samplesPerFrame);
   invokeEndElement (pctxt, "samplesPerFrame", -1);

   /* decode status */
   invokeStartElement (pctxt, "status", -1);

   stat = asn1PD_H245MobileMultilinkReconfigurationCommand_status (pctxt, &pvalue->status);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "status", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245CommandMessage (OOCTXT* pctxt, H245CommandMessage* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 6);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            invokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = memAllocTypeZ (pctxt,
               H245NonStandardMessage);

            stat = asn1PD_H245NonStandardMessage (pctxt, pvalue->u.nonStandard);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* maintenanceLoopOffCommand */
         case 1:
            invokeStartElement (pctxt, "maintenanceLoopOffCommand", -1);

            pvalue->u.maintenanceLoopOffCommand = memAllocTypeZ (pctxt,
               H245MaintenanceLoopOffCommand);

            stat = asn1PD_H245MaintenanceLoopOffCommand (pctxt, pvalue->u.maintenanceLoopOffCommand);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "maintenanceLoopOffCommand", -1);

            break;

         /* sendTerminalCapabilitySet */
         case 2:
            invokeStartElement (pctxt, "sendTerminalCapabilitySet", -1);

            pvalue->u.sendTerminalCapabilitySet = memAllocTypeZ (pctxt,
               H245SendTerminalCapabilitySet);

            stat = asn1PD_H245SendTerminalCapabilitySet (pctxt, pvalue->u.sendTerminalCapabilitySet);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "sendTerminalCapabilitySet", -1);

            break;

         /* encryptionCommand */
         case 3:
            invokeStartElement (pctxt, "encryptionCommand", -1);

            pvalue->u.encryptionCommand = memAllocTypeZ (pctxt,
               H245EncryptionCommand);

            stat = asn1PD_H245EncryptionCommand (pctxt, pvalue->u.encryptionCommand);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "encryptionCommand", -1);

            break;

         /* flowControlCommand */
         case 4:
            invokeStartElement (pctxt, "flowControlCommand", -1);

            pvalue->u.flowControlCommand = memAllocTypeZ (pctxt,
               H245FlowControlCommand);

            stat = asn1PD_H245FlowControlCommand (pctxt, pvalue->u.flowControlCommand);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "flowControlCommand", -1);

            break;

         /* endSessionCommand */
         case 5:
            invokeStartElement (pctxt, "endSessionCommand", -1);

            pvalue->u.endSessionCommand = memAllocTypeZ (pctxt,
               H245EndSessionCommand);

            stat = asn1PD_H245EndSessionCommand (pctxt, pvalue->u.endSessionCommand);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "endSessionCommand", -1);

            break;

         /* miscellaneousCommand */
         case 6:
            invokeStartElement (pctxt, "miscellaneousCommand", -1);

            pvalue->u.miscellaneousCommand = memAllocTypeZ (pctxt,
               H245MiscellaneousCommand);

            stat = asn1PD_H245MiscellaneousCommand (pctxt, pvalue->u.miscellaneousCommand);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "miscellaneousCommand", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 8;

      if (pvalue->t < 8) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt,
         (ASN1OCTET*)openType.data, openType.numocts);

      switch (pvalue->t) {
         /* communicationModeCommand */
         case 8:
            invokeStartElement (pctxt, "communicationModeCommand", -1);

            pvalue->u.communicationModeCommand = memAllocTypeZ (pctxt,
               H245CommunicationModeCommand);

            stat = asn1PD_H245CommunicationModeCommand (pctxt, pvalue->u.communicationModeCommand);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "communicationModeCommand", -1);

            break;

         /* conferenceCommand */
         case 9:
            invokeStartElement (pctxt, "conferenceCommand", -1);

            pvalue->u.conferenceCommand = memAllocTypeZ (pctxt,
               H245ConferenceCommand);

            stat = asn1PD_H245ConferenceCommand (pctxt, pvalue->u.conferenceCommand);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "conferenceCommand", -1);

            break;

         /* h223MultiplexReconfiguration */
         case 10:
            invokeStartElement (pctxt, "h223MultiplexReconfiguration", -1);

            pvalue->u.h223MultiplexReconfiguration = memAllocTypeZ (pctxt,
               H245H223MultiplexReconfiguration);

            stat = asn1PD_H245H223MultiplexReconfiguration (pctxt, pvalue->u.h223MultiplexReconfiguration);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "h223MultiplexReconfiguration", -1);

            break;

         /* newATMVCCommand */
         case 11:
            invokeStartElement (pctxt, "newATMVCCommand", -1);

            pvalue->u.newATMVCCommand = memAllocTypeZ (pctxt,
               H245NewATMVCCommand);

            stat = asn1PD_H245NewATMVCCommand (pctxt, pvalue->u.newATMVCCommand);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "newATMVCCommand", -1);

            break;

         /* mobileMultilinkReconfigurationCommand */
         case 12:
            invokeStartElement (pctxt, "mobileMultilinkReconfigurationCommand", -1);

            pvalue->u.mobileMultilinkReconfigurationCommand
                = memAllocTypeZ (pctxt,
               H245MobileMultilinkReconfigurationCommand);

            stat = asn1PD_H245MobileMultilinkReconfigurationCommand (pctxt, pvalue->u.mobileMultilinkReconfigurationCommand);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "mobileMultilinkReconfigurationCommand", -1);

            break;

         /* genericCommand */
         case 13:
            invokeStartElement (pctxt, "genericCommand", -1);

            pvalue->u.genericCommand = memAllocTypeZ (pctxt,
               H245GenericMessage);

            stat = asn1PD_H245GenericMessage (pctxt, pvalue->u.genericCommand);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "genericCommand", -1);

            break;

         default:;
      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

EXTERN int asn1PD_H245FunctionNotUnderstood (OOCTXT* pctxt, H245FunctionNotUnderstood* pvalue)
{
   int stat = 0;
   OOUINT32 ui;

   stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
   if (stat != 0) return stat;
   else pvalue->t = ui + 1;

   switch (ui) {
      /* request */
      case 0:
         invokeStartElement (pctxt, "request", -1);

         pvalue->u.request = memAllocTypeZ (pctxt, H245RequestMessage);

         stat = asn1PD_H245RequestMessage (pctxt, pvalue->u.request);
         if (stat != 0) return stat;

         invokeEndElement (pctxt, "request", -1);

         break;

      /* response */
      case 1:
         invokeStartElement (pctxt, "response", -1);

         pvalue->u.response = memAllocTypeZ (pctxt, H245ResponseMessage);

         stat = asn1PD_H245ResponseMessage (pctxt, pvalue->u.response);
         if (stat != 0) return stat;

         invokeEndElement (pctxt, "response", -1);

         break;

      /* command */
      case 2:
         invokeStartElement (pctxt, "command", -1);

         pvalue->u.command = memAllocTypeZ (pctxt, H245CommandMessage);

         stat = asn1PD_H245CommandMessage (pctxt, pvalue->u.command);
         if (stat != 0) return stat;

         invokeEndElement (pctxt, "command", -1);

         break;

      default:
         return ASN_E_INVOPT;
   }

   return (stat);
}

EXTERN int asn1PD_H245MasterSlaveDeterminationRelease (OOCTXT* pctxt, H245MasterSlaveDeterminationRelease* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245TerminalCapabilitySetRelease (OOCTXT* pctxt, H245TerminalCapabilitySetRelease* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return stat;

            if (i < 1) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt,
                  (ASN1OCTET*)openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     if (openType.numocts == 0) break;

                     pvalue->m.genericInformationPresent = 1;

                     invokeStartElement (pctxt, "genericInformation", -1);

                     stat = asn1PD_H245_SeqOfH245GenericInformation (pctxt, &pvalue->genericInformation);
                     if (stat != 0) return stat;

                     invokeEndElement (pctxt, "genericInformation", -1);

                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245OpenLogicalChannelConfirm (OOCTXT* pctxt, H245OpenLogicalChannelConfirm* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   /* decode root elements */
   /* decode forwardLogicalChannelNumber */
   invokeStartElement (pctxt, "forwardLogicalChannelNumber", -1);

   stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->forwardLogicalChannelNumber);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "forwardLogicalChannelNumber", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return stat;

            if (i < 1) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt,
                  (ASN1OCTET*)openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     if (openType.numocts == 0) break;

                     pvalue->m.genericInformationPresent = 1;

                     invokeStartElement (pctxt, "genericInformation", -1);

                     stat = asn1PD_H245_SeqOfH245GenericInformation (pctxt, &pvalue->genericInformation);
                     if (stat != 0) return stat;

                     invokeEndElement (pctxt, "genericInformation", -1);

                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245RequestChannelCloseRelease (OOCTXT* pctxt, H245RequestChannelCloseRelease* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode forwardLogicalChannelNumber */
   invokeStartElement (pctxt, "forwardLogicalChannelNumber", -1);

   stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->forwardLogicalChannelNumber);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "forwardLogicalChannelNumber", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245MultiplexEntrySendRelease_multiplexTableEntryNumber (OOCTXT* pctxt, H245MultiplexEntrySendRelease_multiplexTableEntryNumber* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 15, 0 };
   int stat = 0;
   OOUINT32 xx1 = 0;

   /* decode length determinant */

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeLength (pctxt, &pvalue->n);
   if (stat != 0) return stat;

   /* decode elements */

   if (15 < pvalue->n) {
      return stat;
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      invokeStartElement (pctxt, "elem", xx1);

      stat = asn1PD_H245MultiplexTableEntryNumber (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "elem", xx1);

   }

   return (stat);
}

EXTERN int asn1PD_H245MultiplexEntrySendRelease (OOCTXT* pctxt, H245MultiplexEntrySendRelease* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode multiplexTableEntryNumber */
   invokeStartElement (pctxt, "multiplexTableEntryNumber", -1);

   stat = asn1PD_H245MultiplexEntrySendRelease_multiplexTableEntryNumber (pctxt, &pvalue->multiplexTableEntryNumber);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "multiplexTableEntryNumber", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245RequestMultiplexEntryRelease_entryNumbers (OOCTXT* pctxt, H245RequestMultiplexEntryRelease_entryNumbers* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 15, 0 };
   int stat = 0;
   OOUINT32 xx1 = 0;

   /* decode length determinant */

   addSizeConstraint (pctxt, &lsize1);

   stat = decodeLength (pctxt, &pvalue->n);
   if (stat != 0) return stat;

   /* decode elements */

   if (15 < pvalue->n) {
      return stat;
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      invokeStartElement (pctxt, "elem", xx1);

      stat = asn1PD_H245MultiplexTableEntryNumber (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "elem", xx1);

   }

   return (stat);
}

EXTERN int asn1PD_H245RequestMultiplexEntryRelease (OOCTXT* pctxt, H245RequestMultiplexEntryRelease* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode entryNumbers */
   invokeStartElement (pctxt, "entryNumbers", -1);

   stat = asn1PD_H245RequestMultiplexEntryRelease_entryNumbers (pctxt, &pvalue->entryNumbers);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "entryNumbers", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245RequestModeRelease (OOCTXT* pctxt, H245RequestModeRelease* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245MiscellaneousIndication_type_videoNotDecodedMBs (OOCTXT* pctxt, H245MiscellaneousIndication_type_videoNotDecodedMBs* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode firstMB */
   invokeStartElement (pctxt, "firstMB", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->firstMB, 1, 8192);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->firstMB);
   invokeEndElement (pctxt, "firstMB", -1);

   /* decode numberOfMBs */
   invokeStartElement (pctxt, "numberOfMBs", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->numberOfMBs, 1, 8192);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->numberOfMBs);
   invokeEndElement (pctxt, "numberOfMBs", -1);

   /* decode temporalReference */
   invokeStartElement (pctxt, "temporalReference", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->temporalReference, 0, 255);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->temporalReference);
   invokeEndElement (pctxt, "temporalReference", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245MiscellaneousIndication_type (OOCTXT* pctxt, H245MiscellaneousIndication_type* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 9);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* logicalChannelActive */
         case 0:
            invokeStartElement (pctxt, "logicalChannelActive", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "logicalChannelActive", -1);

            break;

         /* logicalChannelInactive */
         case 1:
            invokeStartElement (pctxt, "logicalChannelInactive", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "logicalChannelInactive", -1);

            break;

         /* multipointConference */
         case 2:
            invokeStartElement (pctxt, "multipointConference", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "multipointConference", -1);

            break;

         /* cancelMultipointConference */
         case 3:
            invokeStartElement (pctxt, "cancelMultipointConference", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "cancelMultipointConference", -1);

            break;

         /* multipointZeroComm */
         case 4:
            invokeStartElement (pctxt, "multipointZeroComm", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "multipointZeroComm", -1);

            break;

         /* cancelMultipointZeroComm */
         case 5:
            invokeStartElement (pctxt, "cancelMultipointZeroComm", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "cancelMultipointZeroComm", -1);

            break;

         /* multipointSecondaryStatus */
         case 6:
            invokeStartElement (pctxt, "multipointSecondaryStatus", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "multipointSecondaryStatus", -1);

            break;

         /* cancelMultipointSecondaryStatus */
         case 7:
            invokeStartElement (pctxt, "cancelMultipointSecondaryStatus", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "cancelMultipointSecondaryStatus", -1);

            break;

         /* videoIndicateReadyToActivate */
         case 8:
            invokeStartElement (pctxt, "videoIndicateReadyToActivate", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "videoIndicateReadyToActivate", -1);

            break;

         /* videoTemporalSpatialTradeOff */
         case 9:
            invokeStartElement (pctxt, "videoTemporalSpatialTradeOff", -1);

            stat = decodeConsUInt8 (pctxt, &pvalue->u.videoTemporalSpatialTradeOff, 0, 31);
            if (stat != 0) return stat;

            invokeUIntValue (pctxt, pvalue->u.videoTemporalSpatialTradeOff);
            invokeEndElement (pctxt, "videoTemporalSpatialTradeOff", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 11;

      if (pvalue->t < 11) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt,
         (ASN1OCTET*)openType.data, openType.numocts);

      switch (pvalue->t) {
         /* videoNotDecodedMBs */
         case 11:
            invokeStartElement (pctxt, "videoNotDecodedMBs", -1);

            pvalue->u.videoNotDecodedMBs = memAllocTypeZ (pctxt,
               H245MiscellaneousIndication_type_videoNotDecodedMBs);

            stat = asn1PD_H245MiscellaneousIndication_type_videoNotDecodedMBs (pctxt, pvalue->u.videoNotDecodedMBs);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "videoNotDecodedMBs", -1);

            break;

         /* transportCapability */
         case 12:
            invokeStartElement (pctxt, "transportCapability", -1);

            pvalue->u.transportCapability = memAllocTypeZ (pctxt,
               H245TransportCapability);

            stat = asn1PD_H245TransportCapability (pctxt, pvalue->u.transportCapability);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "transportCapability", -1);

            break;

         default:;
      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

EXTERN int asn1PD_H245MiscellaneousIndication (OOCTXT* pctxt, H245MiscellaneousIndication* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode logicalChannelNumber */
   invokeStartElement (pctxt, "logicalChannelNumber", -1);

   stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->logicalChannelNumber);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "logicalChannelNumber", -1);

   /* decode type */
   invokeStartElement (pctxt, "type", -1);

   stat = asn1PD_H245MiscellaneousIndication_type (pctxt, &pvalue->type);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "type", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245JitterIndication_scope (OOCTXT* pctxt, H245JitterIndication_scope* pvalue)
{
   int stat = 0;
   OOUINT32 ui;

   stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
   if (stat != 0) return stat;
   else pvalue->t = ui + 1;

   switch (ui) {
      /* logicalChannelNumber */
      case 0:
         invokeStartElement (pctxt, "logicalChannelNumber", -1);

         stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->u.logicalChannelNumber);
         if (stat != 0) return stat;

         invokeEndElement (pctxt, "logicalChannelNumber", -1);

         break;

      /* resourceID */
      case 1:
         invokeStartElement (pctxt, "resourceID", -1);

         stat = decodeConsUInt16 (pctxt, &pvalue->u.resourceID, 0, 65535);
         if (stat != 0) return stat;

         invokeUIntValue (pctxt, pvalue->u.resourceID);
         invokeEndElement (pctxt, "resourceID", -1);

         break;

      /* wholeMultiplex */
      case 2:
         invokeStartElement (pctxt, "wholeMultiplex", -1);

         /* NULL */

         invokeNullValue (pctxt);
         invokeEndElement (pctxt, "wholeMultiplex", -1);

         break;

      default:
         return ASN_E_INVOPT;
   }

   return (stat);
}

EXTERN int asn1PD_H245JitterIndication (OOCTXT* pctxt, H245JitterIndication* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.skippedFrameCountPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.additionalDecoderBufferPresent = optbit;

   /* decode root elements */
   /* decode scope */
   invokeStartElement (pctxt, "scope", -1);

   stat = asn1PD_H245JitterIndication_scope (pctxt, &pvalue->scope);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "scope", -1);

   /* decode estimatedReceivedJitterMantissa */
   invokeStartElement (pctxt, "estimatedReceivedJitterMantissa", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->estimatedReceivedJitterMantissa, 0, 3);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->estimatedReceivedJitterMantissa);
   invokeEndElement (pctxt, "estimatedReceivedJitterMantissa", -1);

   /* decode estimatedReceivedJitterExponent */
   invokeStartElement (pctxt, "estimatedReceivedJitterExponent", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->estimatedReceivedJitterExponent, 0, 7);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->estimatedReceivedJitterExponent);
   invokeEndElement (pctxt, "estimatedReceivedJitterExponent", -1);

   /* decode skippedFrameCount */
   if (pvalue->m.skippedFrameCountPresent) {
      invokeStartElement (pctxt, "skippedFrameCount", -1);

      stat = decodeConsUInt8 (pctxt, &pvalue->skippedFrameCount, 0, 15);
      if (stat != 0) return stat;

      invokeUIntValue (pctxt, pvalue->skippedFrameCount);
      invokeEndElement (pctxt, "skippedFrameCount", -1);

   }

   /* decode additionalDecoderBuffer */
   if (pvalue->m.additionalDecoderBufferPresent) {
      invokeStartElement (pctxt, "additionalDecoderBuffer", -1);

      stat = decodeConsUnsigned (pctxt, &pvalue->additionalDecoderBuffer, 0, 262143);
      if (stat != 0) return stat;

      invokeUIntValue (pctxt, pvalue->additionalDecoderBuffer);
      invokeEndElement (pctxt, "additionalDecoderBuffer", -1);

   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245H223SkewIndication (OOCTXT* pctxt, H245H223SkewIndication* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode logicalChannelNumber1 */
   invokeStartElement (pctxt, "logicalChannelNumber1", -1);

   stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->logicalChannelNumber1);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "logicalChannelNumber1", -1);

   /* decode logicalChannelNumber2 */
   invokeStartElement (pctxt, "logicalChannelNumber2", -1);

   stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->logicalChannelNumber2);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "logicalChannelNumber2", -1);

   /* decode skew */
   invokeStartElement (pctxt, "skew", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->skew, 0, 4095);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->skew);
   invokeEndElement (pctxt, "skew", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245NewATMVCIndication_aal_aal1_clockRecovery (OOCTXT* pctxt, H245NewATMVCIndication_aal_aal1_clockRecovery* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nullClockRecovery */
         case 0:
            invokeStartElement (pctxt, "nullClockRecovery", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "nullClockRecovery", -1);

            break;

         /* srtsClockRecovery */
         case 1:
            invokeStartElement (pctxt, "srtsClockRecovery", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "srtsClockRecovery", -1);

            break;

         /* adaptiveClockRecovery */
         case 2:
            invokeStartElement (pctxt, "adaptiveClockRecovery", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "adaptiveClockRecovery", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 4;

      if (pvalue->t < 4) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245NewATMVCIndication_aal_aal1_errorCorrection (OOCTXT* pctxt, H245NewATMVCIndication_aal_aal1_errorCorrection* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 3);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nullErrorCorrection */
         case 0:
            invokeStartElement (pctxt, "nullErrorCorrection", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "nullErrorCorrection", -1);

            break;

         /* longInterleaver */
         case 1:
            invokeStartElement (pctxt, "longInterleaver", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "longInterleaver", -1);

            break;

         /* shortInterleaver */
         case 2:
            invokeStartElement (pctxt, "shortInterleaver", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "shortInterleaver", -1);

            break;

         /* errorCorrectionOnly */
         case 3:
            invokeStartElement (pctxt, "errorCorrectionOnly", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "errorCorrectionOnly", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 5;

      if (pvalue->t < 5) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245NewATMVCIndication_aal_aal1 (OOCTXT* pctxt, H245NewATMVCIndication_aal_aal1* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode clockRecovery */
   invokeStartElement (pctxt, "clockRecovery", -1);

   stat = asn1PD_H245NewATMVCIndication_aal_aal1_clockRecovery (pctxt, &pvalue->clockRecovery);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "clockRecovery", -1);

   /* decode errorCorrection */
   invokeStartElement (pctxt, "errorCorrection", -1);

   stat = asn1PD_H245NewATMVCIndication_aal_aal1_errorCorrection (pctxt, &pvalue->errorCorrection);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "errorCorrection", -1);

   /* decode structuredDataTransfer */
   invokeStartElement (pctxt, "structuredDataTransfer", -1);

   stat = DECODEBIT (pctxt, &pvalue->structuredDataTransfer);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->structuredDataTransfer);
   invokeEndElement (pctxt, "structuredDataTransfer", -1);

   /* decode partiallyFilledCells */
   invokeStartElement (pctxt, "partiallyFilledCells", -1);

   stat = DECODEBIT (pctxt, &pvalue->partiallyFilledCells);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->partiallyFilledCells);
   invokeEndElement (pctxt, "partiallyFilledCells", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245NewATMVCIndication_aal_aal5 (OOCTXT* pctxt, H245NewATMVCIndication_aal_aal5* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode forwardMaximumSDUSize */
   invokeStartElement (pctxt, "forwardMaximumSDUSize", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->forwardMaximumSDUSize, 0, 65535);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->forwardMaximumSDUSize);
   invokeEndElement (pctxt, "forwardMaximumSDUSize", -1);

   /* decode backwardMaximumSDUSize */
   invokeStartElement (pctxt, "backwardMaximumSDUSize", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->backwardMaximumSDUSize, 0, 65535);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->backwardMaximumSDUSize);
   invokeEndElement (pctxt, "backwardMaximumSDUSize", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245NewATMVCIndication_aal (OOCTXT* pctxt, H245NewATMVCIndication_aal* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* aal1 */
         case 0:
            invokeStartElement (pctxt, "aal1", -1);

            pvalue->u.aal1 = memAllocTypeZ (pctxt,
               H245NewATMVCIndication_aal_aal1);

            stat = asn1PD_H245NewATMVCIndication_aal_aal1 (pctxt, pvalue->u.aal1);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "aal1", -1);

            break;

         /* aal5 */
         case 1:
            invokeStartElement (pctxt, "aal5", -1);

            pvalue->u.aal5 = memAllocTypeZ (pctxt,
               H245NewATMVCIndication_aal_aal5);

            stat = asn1PD_H245NewATMVCIndication_aal_aal5 (pctxt, pvalue->u.aal5);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "aal5", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245NewATMVCIndication_multiplex (OOCTXT* pctxt, H245NewATMVCIndication_multiplex* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* noMultiplex */
         case 0:
            invokeStartElement (pctxt, "noMultiplex", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "noMultiplex", -1);

            break;

         /* transportStream */
         case 1:
            invokeStartElement (pctxt, "transportStream", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "transportStream", -1);

            break;

         /* programStream */
         case 2:
            invokeStartElement (pctxt, "programStream", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "programStream", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 4;

      if (pvalue->t < 4) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245NewATMVCIndication_reverseParameters_multiplex (OOCTXT* pctxt, H245NewATMVCIndication_reverseParameters_multiplex* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* noMultiplex */
         case 0:
            invokeStartElement (pctxt, "noMultiplex", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "noMultiplex", -1);

            break;

         /* transportStream */
         case 1:
            invokeStartElement (pctxt, "transportStream", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "transportStream", -1);

            break;

         /* programStream */
         case 2:
            invokeStartElement (pctxt, "programStream", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "programStream", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 4;

      if (pvalue->t < 4) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245NewATMVCIndication_reverseParameters (OOCTXT* pctxt, H245NewATMVCIndication_reverseParameters* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode bitRate */
   invokeStartElement (pctxt, "bitRate", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->bitRate, 1, 65535);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->bitRate);
   invokeEndElement (pctxt, "bitRate", -1);

   /* decode bitRateLockedToPCRClock */
   invokeStartElement (pctxt, "bitRateLockedToPCRClock", -1);

   stat = DECODEBIT (pctxt, &pvalue->bitRateLockedToPCRClock);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->bitRateLockedToPCRClock);
   invokeEndElement (pctxt, "bitRateLockedToPCRClock", -1);

   /* decode bitRateLockedToNetworkClock */
   invokeStartElement (pctxt, "bitRateLockedToNetworkClock", -1);

   stat = DECODEBIT (pctxt, &pvalue->bitRateLockedToNetworkClock);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->bitRateLockedToNetworkClock);
   invokeEndElement (pctxt, "bitRateLockedToNetworkClock", -1);

   /* decode multiplex */
   invokeStartElement (pctxt, "multiplex", -1);

   stat = asn1PD_H245NewATMVCIndication_reverseParameters_multiplex (pctxt, &pvalue->multiplex);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "multiplex", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245NewATMVCIndication (OOCTXT* pctxt, H245NewATMVCIndication* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode resourceID */
   invokeStartElement (pctxt, "resourceID", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->resourceID, 0, 65535);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->resourceID);
   invokeEndElement (pctxt, "resourceID", -1);

   /* decode bitRate */
   invokeStartElement (pctxt, "bitRate", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->bitRate, 1, 65535);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->bitRate);
   invokeEndElement (pctxt, "bitRate", -1);

   /* decode bitRateLockedToPCRClock */
   invokeStartElement (pctxt, "bitRateLockedToPCRClock", -1);

   stat = DECODEBIT (pctxt, &pvalue->bitRateLockedToPCRClock);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->bitRateLockedToPCRClock);
   invokeEndElement (pctxt, "bitRateLockedToPCRClock", -1);

   /* decode bitRateLockedToNetworkClock */
   invokeStartElement (pctxt, "bitRateLockedToNetworkClock", -1);

   stat = DECODEBIT (pctxt, &pvalue->bitRateLockedToNetworkClock);
   if (stat != 0) return stat;

   invokeBoolValue (pctxt, pvalue->bitRateLockedToNetworkClock);
   invokeEndElement (pctxt, "bitRateLockedToNetworkClock", -1);

   /* decode aal */
   invokeStartElement (pctxt, "aal", -1);

   stat = asn1PD_H245NewATMVCIndication_aal (pctxt, &pvalue->aal);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "aal", -1);

   /* decode multiplex */
   invokeStartElement (pctxt, "multiplex", -1);

   stat = asn1PD_H245NewATMVCIndication_multiplex (pctxt, &pvalue->multiplex);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "multiplex", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return stat;

            if (i < 1) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt,
                  (ASN1OCTET*)openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     if (openType.numocts == 0) break;

                     pvalue->m.reverseParametersPresent = 1;

                     invokeStartElement (pctxt, "reverseParameters", -1);

                     stat = asn1PD_H245NewATMVCIndication_reverseParameters (pctxt, &pvalue->reverseParameters);
                     if (stat != 0) return stat;

                     invokeEndElement (pctxt, "reverseParameters", -1);

                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245UserInputIndication_userInputSupportIndication (OOCTXT* pctxt, H245UserInputIndication_userInputSupportIndication* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 3);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            invokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = memAllocTypeZ (pctxt,
               H245NonStandardParameter);

            stat = asn1PD_H245NonStandardParameter (pctxt, pvalue->u.nonStandard);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* basicString */
         case 1:
            invokeStartElement (pctxt, "basicString", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "basicString", -1);

            break;

         /* iA5String */
         case 2:
            invokeStartElement (pctxt, "iA5String", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "iA5String", -1);

            break;

         /* generalString */
         case 3:
            invokeStartElement (pctxt, "generalString", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "generalString", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 5;

      if (pvalue->t < 5) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt,
         (ASN1OCTET*)openType.data, openType.numocts);

      switch (pvalue->t) {
         /* encryptedBasicString */
         case 5:
            invokeStartElement (pctxt, "encryptedBasicString", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "encryptedBasicString", -1);

            break;

         /* encryptedIA5String */
         case 6:
            invokeStartElement (pctxt, "encryptedIA5String", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "encryptedIA5String", -1);

            break;

         /* encryptedGeneralString */
         case 7:
            invokeStartElement (pctxt, "encryptedGeneralString", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "encryptedGeneralString", -1);

            break;

         default:;
      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

EXTERN int asn1PD_H245UserInputIndication_signal_rtp (OOCTXT* pctxt, H245UserInputIndication_signal_rtp* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.timestampPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.expirationTimePresent = optbit;

   /* decode root elements */
   /* decode timestamp */
   if (pvalue->m.timestampPresent) {
      invokeStartElement (pctxt, "timestamp", -1);

      stat = decodeConsUnsigned (pctxt, &pvalue->timestamp, 0, OOUINT32_MAX);
      if (stat != 0) return stat;

      invokeUIntValue (pctxt, pvalue->timestamp);
      invokeEndElement (pctxt, "timestamp", -1);

   }

   /* decode expirationTime */
   if (pvalue->m.expirationTimePresent) {
      invokeStartElement (pctxt, "expirationTime", -1);

      stat = decodeConsUnsigned (pctxt, &pvalue->expirationTime, 0, OOUINT32_MAX);
      if (stat != 0) return stat;

      invokeUIntValue (pctxt, pvalue->expirationTime);
      invokeEndElement (pctxt, "expirationTime", -1);

   }

   /* decode logicalChannelNumber */
   invokeStartElement (pctxt, "logicalChannelNumber", -1);

   stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->logicalChannelNumber);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "logicalChannelNumber", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245Params (OOCTXT* pctxt, H245Params* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;
   OOUINT32 j = 0;
   OOBOOL optbits[3];

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   for (i = 0; i < 3; i++) {
      stat = DECODEBIT (pctxt, &optbits[i]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i = 0; i < 3; i++) {
      switch (i) {
         case 0:
         /* decode iv8 */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "iv8", -1);

            stat = asn1PD_H245IV8 (pctxt, &pvalue->iv8);

            pvalue->m.iv8Present = 1;
            invokeEndElement (pctxt, "iv8", -1);

         }
         break;

         case 1:
         /* decode iv16 */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "iv16", -1);

            stat = asn1PD_H245IV16 (pctxt, &pvalue->iv16);

            pvalue->m.iv16Present = 1;
            invokeEndElement (pctxt, "iv16", -1);

         }
         break;

         case 2:
         /* decode iv */
         if (optbits[j++]) {
            invokeStartElement (pctxt, "iv", -1);

            stat = decodeDynOctetString (pctxt, (ASN1DynOctStr*)&pvalue->iv);

            invokeOctStrValue (pctxt, pvalue->iv.numocts, pvalue->iv.data);
            pvalue->m.ivPresent = 1;
            invokeEndElement (pctxt, "iv", -1);

         }
         break;

         default: j++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

extern EXTERN const char* gs_MULTIMEDIA_SYSTEM_CONTROL_UserInputIndication_signal_signalType_CharSet;

EXTERN int asn1PD_H245UserInputIndication_signal (OOCTXT* pctxt, H245UserInputIndication_signal* pvalue)
{
   static Asn1SizeCnst signalType_lsize1 = { 0, 1, 1, 0 };
   int stat = 0;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.durationPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.rtpPresent = optbit;

   /* decode root elements */
   /* decode signalType */
   invokeStartElement (pctxt, "signalType", -1);

   addSizeConstraint (pctxt, &signalType_lsize1);

   stat = decodeConstrainedStringEx (pctxt, &pvalue->signalType, gs_MULTIMEDIA_SYSTEM_CONTROL_UserInputIndication_signal_signalType_CharSet, 8, 5, 7);
   if (stat != 0) return stat;

   invokeCharStrValue (pctxt, pvalue->signalType);
   invokeEndElement (pctxt, "signalType", -1);

   /* decode duration */
   if (pvalue->m.durationPresent) {
      invokeStartElement (pctxt, "duration", -1);

      stat = decodeConsUInt16 (pctxt, &pvalue->duration, 1, 65535);
      if (stat != 0) return stat;

      invokeUIntValue (pctxt, pvalue->duration);
      invokeEndElement (pctxt, "duration", -1);

   }

   /* decode rtp */
   if (pvalue->m.rtpPresent) {
      invokeStartElement (pctxt, "rtp", -1);

      stat = asn1PD_H245UserInputIndication_signal_rtp (pctxt, &pvalue->rtp);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "rtp", -1);

   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return stat;

            if (i < 4) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt,
                  (ASN1OCTET*)openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     if (openType.numocts == 0) openType.numocts = 1;

                     pvalue->m.rtpPayloadIndicationPresent = 1;

                     invokeStartElement (pctxt, "rtpPayloadIndication", -1);

                     /* NULL */

                     invokeNullValue (pctxt);
                     invokeEndElement (pctxt, "rtpPayloadIndication", -1);

                     break;

                  case 1:
                     if (openType.numocts == 0) break;

                     pvalue->m.paramSPresent = 1;

                     invokeStartElement (pctxt, "paramS", -1);

                     stat = asn1PD_H245Params (pctxt, &pvalue->paramS);
                     if (stat != 0) return stat;

                     invokeEndElement (pctxt, "paramS", -1);

                     break;

                  case 2:
                     if (openType.numocts == 0) break;

                     pvalue->m.encryptedSignalTypePresent = 1;

                     invokeStartElement (pctxt, "encryptedSignalType", -1);

                     stat = asn1PD_H245UserInputIndication_signal_encryptedSignalType (pctxt, &pvalue->encryptedSignalType);
                     if (stat != 0) return stat;

                     invokeEndElement (pctxt, "encryptedSignalType", -1);

                     break;

                  case 3:
                     if (openType.numocts == 0) break;

                     pvalue->m.algorithmOIDPresent = 1;

                     invokeStartElement (pctxt, "algorithmOID", -1);

                     stat = decodeObjectIdentifier (pctxt, &pvalue->algorithmOID);
                     if (stat != 0) return stat;

                     invokeOidValue (pctxt, pvalue->algorithmOID.numids, pvalue->algorithmOID.subid);
                     invokeEndElement (pctxt, "algorithmOID", -1);

                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245UserInputIndication_signalUpdate_rtp (OOCTXT* pctxt, H245UserInputIndication_signalUpdate_rtp* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode logicalChannelNumber */
   invokeStartElement (pctxt, "logicalChannelNumber", -1);

   stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->logicalChannelNumber);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "logicalChannelNumber", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245UserInputIndication_signalUpdate (OOCTXT* pctxt, H245UserInputIndication_signalUpdate* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.rtpPresent = optbit;

   /* decode root elements */
   /* decode duration */
   invokeStartElement (pctxt, "duration", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->duration, 1, 65535);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->duration);
   invokeEndElement (pctxt, "duration", -1);

   /* decode rtp */
   if (pvalue->m.rtpPresent) {
      invokeStartElement (pctxt, "rtp", -1);

      stat = asn1PD_H245UserInputIndication_signalUpdate_rtp (pctxt, &pvalue->rtp);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "rtp", -1);

   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245UserInputIndication_extendedAlphanumeric_encryptedAlphanumeric (OOCTXT* pctxt, H245UserInputIndication_extendedAlphanumeric_encryptedAlphanumeric* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.paramSPresent = optbit;

   /* decode root elements */
   /* decode algorithmOID */
   invokeStartElement (pctxt, "algorithmOID", -1);

   stat = decodeObjectIdentifier (pctxt, &pvalue->algorithmOID);
   if (stat != 0) return stat;

   invokeOidValue (pctxt, pvalue->algorithmOID.numids, pvalue->algorithmOID.subid);
   invokeEndElement (pctxt, "algorithmOID", -1);

   /* decode paramS */
   if (pvalue->m.paramSPresent) {
      invokeStartElement (pctxt, "paramS", -1);

      stat = asn1PD_H245Params (pctxt, &pvalue->paramS);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "paramS", -1);

   }

   /* decode encrypted */
   invokeStartElement (pctxt, "encrypted", -1);

   stat = decodeDynOctetString (pctxt, (ASN1DynOctStr*)&pvalue->encrypted);
   if (stat != 0) return stat;

   invokeOctStrValue (pctxt, pvalue->encrypted.numocts, pvalue->encrypted.data);
   invokeEndElement (pctxt, "encrypted", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245UserInputIndication_extendedAlphanumeric (OOCTXT* pctxt, H245UserInputIndication_extendedAlphanumeric* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.rtpPayloadIndicationPresent = optbit;

   /* decode root elements */
   /* decode alphanumeric */
   invokeStartElement (pctxt, "alphanumeric", -1);

   stat = decodeVarWidthCharString (pctxt, &pvalue->alphanumeric);
   if (stat != 0) return stat;

   invokeCharStrValue (pctxt, pvalue->alphanumeric);
   invokeEndElement (pctxt, "alphanumeric", -1);

   /* decode rtpPayloadIndication */
   if (pvalue->m.rtpPayloadIndicationPresent) {
      invokeStartElement (pctxt, "rtpPayloadIndication", -1);

      /* NULL */

      invokeNullValue (pctxt);
      invokeEndElement (pctxt, "rtpPayloadIndication", -1);

   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return stat;

            if (i < 1) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt,
                  (ASN1OCTET*)openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     if (openType.numocts == 0) break;

                     pvalue->m.encryptedAlphanumericPresent = 1;

                     invokeStartElement (pctxt, "encryptedAlphanumeric", -1);

                     stat = asn1PD_H245UserInputIndication_extendedAlphanumeric_encryptedAlphanumeric (pctxt, &pvalue->encryptedAlphanumeric);
                     if (stat != 0) return stat;

                     invokeEndElement (pctxt, "encryptedAlphanumeric", -1);

                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245UserInputIndication_encryptedAlphanumeric (OOCTXT* pctxt, H245UserInputIndication_encryptedAlphanumeric* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.paramSPresent = optbit;

   /* decode root elements */
   /* decode algorithmOID */
   invokeStartElement (pctxt, "algorithmOID", -1);

   stat = decodeObjectIdentifier (pctxt, &pvalue->algorithmOID);
   if (stat != 0) return stat;

   invokeOidValue (pctxt, pvalue->algorithmOID.numids, pvalue->algorithmOID.subid);
   invokeEndElement (pctxt, "algorithmOID", -1);

   /* decode paramS */
   if (pvalue->m.paramSPresent) {
      invokeStartElement (pctxt, "paramS", -1);

      stat = asn1PD_H245Params (pctxt, &pvalue->paramS);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "paramS", -1);

   }

   /* decode encrypted */
   invokeStartElement (pctxt, "encrypted", -1);

   stat = decodeDynOctetString (pctxt, (ASN1DynOctStr*)&pvalue->encrypted);
   if (stat != 0) return stat;

   invokeOctStrValue (pctxt, pvalue->encrypted.numocts, pvalue->encrypted.data);
   invokeEndElement (pctxt, "encrypted", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245UserInputIndication (OOCTXT* pctxt, H245UserInputIndication* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            invokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = memAllocTypeZ (pctxt,
               H245NonStandardParameter);

            stat = asn1PD_H245NonStandardParameter (pctxt, pvalue->u.nonStandard);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* alphanumeric */
         case 1:
            invokeStartElement (pctxt, "alphanumeric", -1);

            stat = decodeVarWidthCharString (pctxt, &pvalue->u.alphanumeric);
            if (stat != 0) return stat;

            invokeCharStrValue (pctxt, pvalue->u.alphanumeric);
            invokeEndElement (pctxt, "alphanumeric", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt,
         (ASN1OCTET*)openType.data, openType.numocts);

      switch (pvalue->t) {
         /* userInputSupportIndication */
         case 3:
            invokeStartElement (pctxt, "userInputSupportIndication", -1);

            pvalue->u.userInputSupportIndication = memAllocTypeZ (pctxt,
               H245UserInputIndication_userInputSupportIndication);

            stat = asn1PD_H245UserInputIndication_userInputSupportIndication (pctxt, pvalue->u.userInputSupportIndication);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "userInputSupportIndication", -1);

            break;

         /* signal */
         case 4:
            invokeStartElement (pctxt, "signal", -1);

            pvalue->u.signal = memAllocTypeZ (pctxt,
               H245UserInputIndication_signal);

            stat = asn1PD_H245UserInputIndication_signal (pctxt, pvalue->u.signal);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "signal", -1);

            break;

         /* signalUpdate */
         case 5:
            invokeStartElement (pctxt, "signalUpdate", -1);

            pvalue->u.signalUpdate = memAllocTypeZ (pctxt,
               H245UserInputIndication_signalUpdate);

            stat = asn1PD_H245UserInputIndication_signalUpdate (pctxt, pvalue->u.signalUpdate);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "signalUpdate", -1);

            break;

         /* extendedAlphanumeric */
         case 6:
            invokeStartElement (pctxt, "extendedAlphanumeric", -1);

            pvalue->u.extendedAlphanumeric = memAllocTypeZ (pctxt,
               H245UserInputIndication_extendedAlphanumeric);

            stat = asn1PD_H245UserInputIndication_extendedAlphanumeric (pctxt, pvalue->u.extendedAlphanumeric);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "extendedAlphanumeric", -1);

            break;

         /* encryptedAlphanumeric */
         case 7:
            invokeStartElement (pctxt, "encryptedAlphanumeric", -1);

            pvalue->u.encryptedAlphanumeric = memAllocTypeZ (pctxt,
               H245UserInputIndication_encryptedAlphanumeric);

            stat = asn1PD_H245UserInputIndication_encryptedAlphanumeric (pctxt, pvalue->u.encryptedAlphanumeric);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "encryptedAlphanumeric", -1);

            break;

         /* genericInformation */
         case 8:
            invokeStartElement (pctxt, "genericInformation", -1);

            pvalue->u.genericInformation = memAllocTypeZ (pctxt,
               H245_SeqOfH245GenericInformation);

            stat = asn1PD_H245_SeqOfH245GenericInformation (pctxt, pvalue->u.genericInformation);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "genericInformation", -1);

            break;

         default:;
      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

EXTERN int asn1PD_H245H2250MaximumSkewIndication (OOCTXT* pctxt, H245H2250MaximumSkewIndication* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode logicalChannelNumber1 */
   invokeStartElement (pctxt, "logicalChannelNumber1", -1);

   stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->logicalChannelNumber1);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "logicalChannelNumber1", -1);

   /* decode logicalChannelNumber2 */
   invokeStartElement (pctxt, "logicalChannelNumber2", -1);

   stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->logicalChannelNumber2);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "logicalChannelNumber2", -1);

   /* decode maximumSkew */
   invokeStartElement (pctxt, "maximumSkew", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->maximumSkew, 0, 4095);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->maximumSkew);
   invokeEndElement (pctxt, "maximumSkew", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245MCLocationIndication (OOCTXT* pctxt, H245MCLocationIndication* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode signalAddress */
   invokeStartElement (pctxt, "signalAddress", -1);

   stat = asn1PD_H245TransportAddress (pctxt, &pvalue->signalAddress);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "signalAddress", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245TerminalYouAreSeeingInSubPictureNumber (OOCTXT* pctxt, H245TerminalYouAreSeeingInSubPictureNumber* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode terminalNumber */
   invokeStartElement (pctxt, "terminalNumber", -1);

   stat = asn1PD_H245TerminalNumber (pctxt, &pvalue->terminalNumber);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "terminalNumber", -1);

   /* decode subPictureNumber */
   invokeStartElement (pctxt, "subPictureNumber", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->subPictureNumber, 0, 255);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->subPictureNumber);
   invokeEndElement (pctxt, "subPictureNumber", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245VideoIndicateCompose (OOCTXT* pctxt, H245VideoIndicateCompose* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode compositionNumber */
   invokeStartElement (pctxt, "compositionNumber", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->compositionNumber, 0, 255);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->compositionNumber);
   invokeEndElement (pctxt, "compositionNumber", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245ConferenceIndication (OOCTXT* pctxt, H245ConferenceIndication* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 9);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* sbeNumber */
         case 0:
            invokeStartElement (pctxt, "sbeNumber", -1);

            stat = decodeConsUInt8 (pctxt, &pvalue->u.sbeNumber, 0, 9);
            if (stat != 0) return stat;

            invokeUIntValue (pctxt, pvalue->u.sbeNumber);
            invokeEndElement (pctxt, "sbeNumber", -1);

            break;

         /* terminalNumberAssign */
         case 1:
            invokeStartElement (pctxt, "terminalNumberAssign", -1);

            pvalue->u.terminalNumberAssign = memAllocTypeZ (pctxt,
               H245TerminalLabel);

            stat = asn1PD_H245TerminalLabel (pctxt, pvalue->u.terminalNumberAssign);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "terminalNumberAssign", -1);

            break;

         /* terminalJoinedConference */
         case 2:
            invokeStartElement (pctxt, "terminalJoinedConference", -1);

            pvalue->u.terminalJoinedConference = memAllocTypeZ (pctxt,
               H245TerminalLabel);

            stat = asn1PD_H245TerminalLabel (pctxt, pvalue->u.terminalJoinedConference);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "terminalJoinedConference", -1);

            break;

         /* terminalLeftConference */
         case 3:
            invokeStartElement (pctxt, "terminalLeftConference", -1);

            pvalue->u.terminalLeftConference = memAllocTypeZ (pctxt,
               H245TerminalLabel);

            stat = asn1PD_H245TerminalLabel (pctxt, pvalue->u.terminalLeftConference);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "terminalLeftConference", -1);

            break;

         /* seenByAtLeastOneOther */
         case 4:
            invokeStartElement (pctxt, "seenByAtLeastOneOther", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "seenByAtLeastOneOther", -1);

            break;

         /* cancelSeenByAtLeastOneOther */
         case 5:
            invokeStartElement (pctxt, "cancelSeenByAtLeastOneOther", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "cancelSeenByAtLeastOneOther", -1);

            break;

         /* seenByAll */
         case 6:
            invokeStartElement (pctxt, "seenByAll", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "seenByAll", -1);

            break;

         /* cancelSeenByAll */
         case 7:
            invokeStartElement (pctxt, "cancelSeenByAll", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "cancelSeenByAll", -1);

            break;

         /* terminalYouAreSeeing */
         case 8:
            invokeStartElement (pctxt, "terminalYouAreSeeing", -1);

            pvalue->u.terminalYouAreSeeing = memAllocTypeZ (pctxt,
               H245TerminalLabel);

            stat = asn1PD_H245TerminalLabel (pctxt, pvalue->u.terminalYouAreSeeing);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "terminalYouAreSeeing", -1);

            break;

         /* requestForFloor */
         case 9:
            invokeStartElement (pctxt, "requestForFloor", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "requestForFloor", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 11;

      if (pvalue->t < 11) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt,
         (ASN1OCTET*)openType.data, openType.numocts);

      switch (pvalue->t) {
         /* withdrawChairToken */
         case 11:
            invokeStartElement (pctxt, "withdrawChairToken", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "withdrawChairToken", -1);

            break;

         /* floorRequested */
         case 12:
            invokeStartElement (pctxt, "floorRequested", -1);

            pvalue->u.floorRequested = memAllocTypeZ (pctxt,
               H245TerminalLabel);

            stat = asn1PD_H245TerminalLabel (pctxt, pvalue->u.floorRequested);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "floorRequested", -1);

            break;

         /* terminalYouAreSeeingInSubPictureNumber */
         case 13:
            invokeStartElement (pctxt, "terminalYouAreSeeingInSubPictureNumber", -1);

            pvalue->u.terminalYouAreSeeingInSubPictureNumber
                = memAllocTypeZ (pctxt,
               H245TerminalYouAreSeeingInSubPictureNumber);

            stat = asn1PD_H245TerminalYouAreSeeingInSubPictureNumber (pctxt, pvalue->u.terminalYouAreSeeingInSubPictureNumber);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "terminalYouAreSeeingInSubPictureNumber", -1);

            break;

         /* videoIndicateCompose */
         case 14:
            invokeStartElement (pctxt, "videoIndicateCompose", -1);

            pvalue->u.videoIndicateCompose = memAllocTypeZ (pctxt,
               H245VideoIndicateCompose);

            stat = asn1PD_H245VideoIndicateCompose (pctxt, pvalue->u.videoIndicateCompose);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "videoIndicateCompose", -1);

            break;

         default:;
      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

EXTERN int asn1PD_H245VendorIdentification (OOCTXT* pctxt, H245VendorIdentification* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.productNumberPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.versionNumberPresent = optbit;

   /* decode root elements */
   /* decode vendor */
   invokeStartElement (pctxt, "vendor", -1);

   stat = asn1PD_H245NonStandardIdentifier (pctxt, &pvalue->vendor);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "vendor", -1);

   /* decode productNumber */
   if (pvalue->m.productNumberPresent) {
      invokeStartElement (pctxt, "productNumber", -1);

      stat = asn1PD_H245VendorIdentification_productNumber (pctxt, &pvalue->productNumber);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "productNumber", -1);

   }

   /* decode versionNumber */
   if (pvalue->m.versionNumberPresent) {
      invokeStartElement (pctxt, "versionNumber", -1);

      stat = asn1PD_H245VendorIdentification_versionNumber (pctxt, &pvalue->versionNumber);
      if (stat != 0) return stat;

      invokeEndElement (pctxt, "versionNumber", -1);

   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245FunctionNotSupported_cause (OOCTXT* pctxt, H245FunctionNotSupported_cause* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* syntaxError */
         case 0:
            invokeStartElement (pctxt, "syntaxError", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "syntaxError", -1);

            break;

         /* semanticError */
         case 1:
            invokeStartElement (pctxt, "semanticError", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "semanticError", -1);

            break;

         /* unknownFunction */
         case 2:
            invokeStartElement (pctxt, "unknownFunction", -1);

            /* NULL */

            invokeNullValue (pctxt);
            invokeEndElement (pctxt, "unknownFunction", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 4;

      if (pvalue->t < 4) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245FunctionNotSupported (OOCTXT* pctxt, H245FunctionNotSupported* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */
   stat = DECODEBIT (pctxt, &optbit);
   if (stat != 0) return stat;
   pvalue->m.returnedFunctionPresent = optbit;

   /* decode root elements */
   /* decode cause */
   invokeStartElement (pctxt, "cause", -1);

   stat = asn1PD_H245FunctionNotSupported_cause (pctxt, &pvalue->cause);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "cause", -1);

   /* decode returnedFunction */
   if (pvalue->m.returnedFunctionPresent) {
      invokeStartElement (pctxt, "returnedFunction", -1);

      stat = decodeDynOctetString (pctxt, (ASN1DynOctStr*)&pvalue->returnedFunction);
      if (stat != 0) return stat;

      invokeOctStrValue (pctxt, pvalue->returnedFunction.numocts, pvalue->returnedFunction.data);
      invokeEndElement (pctxt, "returnedFunction", -1);

   }

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245MultilinkIndication_crcDesired (OOCTXT* pctxt, H245MultilinkIndication_crcDesired* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245MultilinkIndication_excessiveError (OOCTXT* pctxt, H245MultilinkIndication_excessiveError* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode connectionIdentifier */
   invokeStartElement (pctxt, "connectionIdentifier", -1);

   stat = asn1PD_H245ConnectionIdentifier (pctxt, &pvalue->connectionIdentifier);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "connectionIdentifier", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245MultilinkIndication (OOCTXT* pctxt, H245MultilinkIndication* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            invokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = memAllocTypeZ (pctxt,
               H245NonStandardMessage);

            stat = asn1PD_H245NonStandardMessage (pctxt, pvalue->u.nonStandard);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* crcDesired */
         case 1:
            invokeStartElement (pctxt, "crcDesired", -1);

            pvalue->u.crcDesired = memAllocTypeZ (pctxt,
               H245MultilinkIndication_crcDesired);

            stat = asn1PD_H245MultilinkIndication_crcDesired (pctxt, pvalue->u.crcDesired);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "crcDesired", -1);

            break;

         /* excessiveError */
         case 2:
            invokeStartElement (pctxt, "excessiveError", -1);

            pvalue->u.excessiveError = memAllocTypeZ (pctxt,
               H245MultilinkIndication_excessiveError);

            stat = asn1PD_H245MultilinkIndication_excessiveError (pctxt, pvalue->u.excessiveError);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "excessiveError", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 4;

      if (pvalue->t < 4) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

EXTERN int asn1PD_H245LogicalChannelRateRelease (OOCTXT* pctxt, H245LogicalChannelRateRelease* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245FlowControlIndication_scope (OOCTXT* pctxt, H245FlowControlIndication_scope* pvalue)
{
   int stat = 0;
   OOUINT32 ui;

   stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
   if (stat != 0) return stat;
   else pvalue->t = ui + 1;

   switch (ui) {
      /* logicalChannelNumber */
      case 0:
         invokeStartElement (pctxt, "logicalChannelNumber", -1);

         stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->u.logicalChannelNumber);
         if (stat != 0) return stat;

         invokeEndElement (pctxt, "logicalChannelNumber", -1);

         break;

      /* resourceID */
      case 1:
         invokeStartElement (pctxt, "resourceID", -1);

         stat = decodeConsUInt16 (pctxt, &pvalue->u.resourceID, 0, 65535);
         if (stat != 0) return stat;

         invokeUIntValue (pctxt, pvalue->u.resourceID);
         invokeEndElement (pctxt, "resourceID", -1);

         break;

      /* wholeMultiplex */
      case 2:
         invokeStartElement (pctxt, "wholeMultiplex", -1);

         /* NULL */

         invokeNullValue (pctxt);
         invokeEndElement (pctxt, "wholeMultiplex", -1);

         break;

      default:
         return ASN_E_INVOPT;
   }

   return (stat);
}

EXTERN int asn1PD_H245FlowControlIndication_restriction (OOCTXT* pctxt, H245FlowControlIndication_restriction* pvalue)
{
   int stat = 0;
   OOUINT32 ui;

   stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
   if (stat != 0) return stat;
   else pvalue->t = ui + 1;

   switch (ui) {
      /* maximumBitRate */
      case 0:
         invokeStartElement (pctxt, "maximumBitRate", -1);

         stat = decodeConsUnsigned (pctxt, &pvalue->u.maximumBitRate, 0, 16777215);
         if (stat != 0) return stat;

         invokeUIntValue (pctxt, pvalue->u.maximumBitRate);
         invokeEndElement (pctxt, "maximumBitRate", -1);

         break;

      /* noRestriction */
      case 1:
         invokeStartElement (pctxt, "noRestriction", -1);

         /* NULL */

         invokeNullValue (pctxt);
         invokeEndElement (pctxt, "noRestriction", -1);

         break;

      default:
         return ASN_E_INVOPT;
   }

   return (stat);
}

EXTERN int asn1PD_H245FlowControlIndication (OOCTXT* pctxt, H245FlowControlIndication* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode scope */
   invokeStartElement (pctxt, "scope", -1);

   stat = asn1PD_H245FlowControlIndication_scope (pctxt, &pvalue->scope);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "scope", -1);

   /* decode restriction */
   invokeStartElement (pctxt, "restriction", -1);

   stat = asn1PD_H245FlowControlIndication_restriction (pctxt, &pvalue->restriction);
   if (stat != 0) return stat;

   invokeEndElement (pctxt, "restriction", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245MobileMultilinkReconfigurationIndication (OOCTXT* pctxt, H245MobileMultilinkReconfigurationIndication* pvalue)
{
   int stat = 0;
   OOCTXT lctxt;
   OOUINT32 bitcnt;
   OOUINT32 i;
   OOBOOL optbit = FALSE;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   /* decode root elements */
   /* decode sampleSize */
   invokeStartElement (pctxt, "sampleSize", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->sampleSize, 1, 255);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->sampleSize);
   invokeEndElement (pctxt, "sampleSize", -1);

   /* decode samplesPerFrame */
   invokeStartElement (pctxt, "samplesPerFrame", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->samplesPerFrame, 1, 255);
   if (stat != 0) return stat;

   invokeUIntValue (pctxt, pvalue->samplesPerFrame);
   invokeEndElement (pctxt, "samplesPerFrame", -1);

   /* decode extension elements */
   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return stat;

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      copyContext (&lctxt, pctxt);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return stat;

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, 0, 0);
            if (stat != 0) return stat;

         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_H245IndicationMessage (OOCTXT* pctxt, H245IndicationMessage* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 13);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            invokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = memAllocTypeZ (pctxt,
               H245NonStandardMessage);

            stat = asn1PD_H245NonStandardMessage (pctxt, pvalue->u.nonStandard);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* functionNotUnderstood */
         case 1:
            invokeStartElement (pctxt, "functionNotUnderstood", -1);

            pvalue->u.functionNotUnderstood = memAllocTypeZ (pctxt,
               H245FunctionNotUnderstood);

            stat = asn1PD_H245FunctionNotUnderstood (pctxt, pvalue->u.functionNotUnderstood);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "functionNotUnderstood", -1);

            break;

         /* masterSlaveDeterminationRelease */
         case 2:
            invokeStartElement (pctxt, "masterSlaveDeterminationRelease", -1);

            pvalue->u.masterSlaveDeterminationRelease
                = memAllocTypeZ (pctxt,
               H245MasterSlaveDeterminationRelease);

            stat = asn1PD_H245MasterSlaveDeterminationRelease (pctxt, pvalue->u.masterSlaveDeterminationRelease);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "masterSlaveDeterminationRelease", -1);

            break;

         /* terminalCapabilitySetRelease */
         case 3:
            invokeStartElement (pctxt, "terminalCapabilitySetRelease", -1);

            pvalue->u.terminalCapabilitySetRelease = memAllocTypeZ (pctxt,
               H245TerminalCapabilitySetRelease);

            stat = asn1PD_H245TerminalCapabilitySetRelease (pctxt, pvalue->u.terminalCapabilitySetRelease);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "terminalCapabilitySetRelease", -1);

            break;

         /* openLogicalChannelConfirm */
         case 4:
            invokeStartElement (pctxt, "openLogicalChannelConfirm", -1);

            pvalue->u.openLogicalChannelConfirm = memAllocTypeZ (pctxt,
               H245OpenLogicalChannelConfirm);

            stat = asn1PD_H245OpenLogicalChannelConfirm (pctxt, pvalue->u.openLogicalChannelConfirm);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "openLogicalChannelConfirm", -1);

            break;

         /* requestChannelCloseRelease */
         case 5:
            invokeStartElement (pctxt, "requestChannelCloseRelease", -1);

            pvalue->u.requestChannelCloseRelease = memAllocTypeZ (pctxt,
               H245RequestChannelCloseRelease);

            stat = asn1PD_H245RequestChannelCloseRelease (pctxt, pvalue->u.requestChannelCloseRelease);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "requestChannelCloseRelease", -1);

            break;

         /* multiplexEntrySendRelease */
         case 6:
            invokeStartElement (pctxt, "multiplexEntrySendRelease", -1);

            pvalue->u.multiplexEntrySendRelease = memAllocTypeZ (pctxt,
               H245MultiplexEntrySendRelease);

            stat = asn1PD_H245MultiplexEntrySendRelease (pctxt, pvalue->u.multiplexEntrySendRelease);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "multiplexEntrySendRelease", -1);

            break;

         /* requestMultiplexEntryRelease */
         case 7:
            invokeStartElement (pctxt, "requestMultiplexEntryRelease", -1);

            pvalue->u.requestMultiplexEntryRelease = memAllocTypeZ (pctxt,
               H245RequestMultiplexEntryRelease);

            stat = asn1PD_H245RequestMultiplexEntryRelease (pctxt, pvalue->u.requestMultiplexEntryRelease);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "requestMultiplexEntryRelease", -1);

            break;

         /* requestModeRelease */
         case 8:
            invokeStartElement (pctxt, "requestModeRelease", -1);

            pvalue->u.requestModeRelease = memAllocTypeZ (pctxt,
               H245RequestModeRelease);

            stat = asn1PD_H245RequestModeRelease (pctxt, pvalue->u.requestModeRelease);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "requestModeRelease", -1);

            break;

         /* miscellaneousIndication */
         case 9:
            invokeStartElement (pctxt, "miscellaneousIndication", -1);

            pvalue->u.miscellaneousIndication = memAllocTypeZ (pctxt,
               H245MiscellaneousIndication);

            stat = asn1PD_H245MiscellaneousIndication (pctxt, pvalue->u.miscellaneousIndication);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "miscellaneousIndication", -1);

            break;

         /* jitterIndication */
         case 10:
            invokeStartElement (pctxt, "jitterIndication", -1);

            pvalue->u.jitterIndication = memAllocTypeZ (pctxt,
               H245JitterIndication);

            stat = asn1PD_H245JitterIndication (pctxt, pvalue->u.jitterIndication);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "jitterIndication", -1);

            break;

         /* h223SkewIndication */
         case 11:
            invokeStartElement (pctxt, "h223SkewIndication", -1);

            pvalue->u.h223SkewIndication = memAllocTypeZ (pctxt,
               H245H223SkewIndication);

            stat = asn1PD_H245H223SkewIndication (pctxt, pvalue->u.h223SkewIndication);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "h223SkewIndication", -1);

            break;

         /* newATMVCIndication */
         case 12:
            invokeStartElement (pctxt, "newATMVCIndication", -1);

            pvalue->u.newATMVCIndication = memAllocTypeZ (pctxt,
               H245NewATMVCIndication);

            stat = asn1PD_H245NewATMVCIndication (pctxt, pvalue->u.newATMVCIndication);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "newATMVCIndication", -1);

            break;

         /* userInput */
         case 13:
            invokeStartElement (pctxt, "userInput", -1);

            pvalue->u.userInput = memAllocTypeZ (pctxt,
               H245UserInputIndication);

            stat = asn1PD_H245UserInputIndication (pctxt, pvalue->u.userInput);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "userInput", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 15;

      if (pvalue->t < 15) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt,
         (ASN1OCTET*)openType.data, openType.numocts);

      switch (pvalue->t) {
         /* h2250MaximumSkewIndication */
         case 15:
            invokeStartElement (pctxt, "h2250MaximumSkewIndication", -1);

            pvalue->u.h2250MaximumSkewIndication = memAllocTypeZ (pctxt,
               H245H2250MaximumSkewIndication);

            stat = asn1PD_H245H2250MaximumSkewIndication (pctxt, pvalue->u.h2250MaximumSkewIndication);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "h2250MaximumSkewIndication", -1);

            break;

         /* mcLocationIndication */
         case 16:
            invokeStartElement (pctxt, "mcLocationIndication", -1);

            pvalue->u.mcLocationIndication = memAllocTypeZ (pctxt,
               H245MCLocationIndication);

            stat = asn1PD_H245MCLocationIndication (pctxt, pvalue->u.mcLocationIndication);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "mcLocationIndication", -1);

            break;

         /* conferenceIndication */
         case 17:
            invokeStartElement (pctxt, "conferenceIndication", -1);

            pvalue->u.conferenceIndication = memAllocTypeZ (pctxt,
               H245ConferenceIndication);

            stat = asn1PD_H245ConferenceIndication (pctxt, pvalue->u.conferenceIndication);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "conferenceIndication", -1);

            break;

         /* vendorIdentification */
         case 18:
            invokeStartElement (pctxt, "vendorIdentification", -1);

            pvalue->u.vendorIdentification = memAllocTypeZ (pctxt,
               H245VendorIdentification);

            stat = asn1PD_H245VendorIdentification (pctxt, pvalue->u.vendorIdentification);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "vendorIdentification", -1);

            break;

         /* functionNotSupported */
         case 19:
            invokeStartElement (pctxt, "functionNotSupported", -1);

            pvalue->u.functionNotSupported = memAllocTypeZ (pctxt,
               H245FunctionNotSupported);

            stat = asn1PD_H245FunctionNotSupported (pctxt, pvalue->u.functionNotSupported);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "functionNotSupported", -1);

            break;

         /* multilinkIndication */
         case 20:
            invokeStartElement (pctxt, "multilinkIndication", -1);

            pvalue->u.multilinkIndication = memAllocTypeZ (pctxt,
               H245MultilinkIndication);

            stat = asn1PD_H245MultilinkIndication (pctxt, pvalue->u.multilinkIndication);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "multilinkIndication", -1);

            break;

         /* logicalChannelRateRelease */
         case 21:
            invokeStartElement (pctxt, "logicalChannelRateRelease", -1);

            pvalue->u.logicalChannelRateRelease = memAllocTypeZ (pctxt,
               H245LogicalChannelRateRelease);

            stat = asn1PD_H245LogicalChannelRateRelease (pctxt, pvalue->u.logicalChannelRateRelease);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "logicalChannelRateRelease", -1);

            break;

         /* flowControlIndication */
         case 22:
            invokeStartElement (pctxt, "flowControlIndication", -1);

            pvalue->u.flowControlIndication = memAllocTypeZ (pctxt,
               H245FlowControlIndication);

            stat = asn1PD_H245FlowControlIndication (pctxt, pvalue->u.flowControlIndication);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "flowControlIndication", -1);

            break;

         /* mobileMultilinkReconfigurationIndication */
         case 23:
            invokeStartElement (pctxt, "mobileMultilinkReconfigurationIndication", -1);

            pvalue->u.mobileMultilinkReconfigurationIndication
                = memAllocTypeZ (pctxt,
               H245MobileMultilinkReconfigurationIndication);

            stat = asn1PD_H245MobileMultilinkReconfigurationIndication (pctxt, pvalue->u.mobileMultilinkReconfigurationIndication);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "mobileMultilinkReconfigurationIndication", -1);

            break;

         /* genericIndication */
         case 24:
            invokeStartElement (pctxt, "genericIndication", -1);

            pvalue->u.genericIndication = memAllocTypeZ (pctxt,
               H245GenericMessage);

            stat = asn1PD_H245GenericMessage (pctxt, pvalue->u.genericIndication);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "genericIndication", -1);

            break;

         default:;
      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

EXTERN int asn1PD_H245MultimediaSystemControlMessage (OOCTXT* pctxt, H245MultimediaSystemControlMessage* pvalue)
{
   int stat = 0;
   OOUINT32 ui;
   ASN1OpenType openType;
   OOBOOL extbit = FALSE;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != 0) return stat;

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 3);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* request */
         case 0:
            invokeStartElement (pctxt, "request", -1);

            pvalue->u.request = memAllocTypeZ (pctxt, H245RequestMessage);

            stat = asn1PD_H245RequestMessage (pctxt, pvalue->u.request);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "request", -1);

            break;

         /* response */
         case 1:
            invokeStartElement (pctxt, "response", -1);

            pvalue->u.response = memAllocTypeZ (pctxt,
               H245ResponseMessage);

            stat = asn1PD_H245ResponseMessage (pctxt, pvalue->u.response);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "response", -1);

            break;

         /* command */
         case 2:
            invokeStartElement (pctxt, "command", -1);

            pvalue->u.command = memAllocTypeZ (pctxt, H245CommandMessage);

            stat = asn1PD_H245CommandMessage (pctxt, pvalue->u.command);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "command", -1);

            break;

         /* indication */
         case 3:
            invokeStartElement (pctxt, "indication", -1);

            pvalue->u.indication = memAllocTypeZ (pctxt,
               H245IndicationMessage);

            stat = asn1PD_H245IndicationMessage (pctxt, pvalue->u.indication);
            if (stat != 0) return stat;

            invokeEndElement (pctxt, "indication", -1);

            break;

         default:
            return ASN_E_INVOPT;
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 5;

      if (pvalue->t < 5) return ASN_E_INVOPT;
      stat = decodeByteAlign (pctxt);
      if (stat != 0) return stat;

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

   }

   return (stat);
}

